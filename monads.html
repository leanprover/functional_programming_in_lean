<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Monads - Functional Programming in Lean</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">
        <link rel="stylesheet" href="pygments.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title.html">Functional Programming in Lean</a></li><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="acknowledgments.html">Acknowledgments</a></li><li class="chapter-item expanded "><a href="getting-to-know.html"><strong aria-hidden="true">1.</strong> Getting to Know Lean</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-to-know/evaluating.html"><strong aria-hidden="true">1.1.</strong> Evaluating Expressions</a></li><li class="chapter-item expanded "><a href="getting-to-know/types.html"><strong aria-hidden="true">1.2.</strong> Types</a></li><li class="chapter-item expanded "><a href="getting-to-know/functions-and-definitions.html"><strong aria-hidden="true">1.3.</strong> Functions and Definitions</a></li><li class="chapter-item expanded "><a href="getting-to-know/structures.html"><strong aria-hidden="true">1.4.</strong> Structures</a></li><li class="chapter-item expanded "><a href="getting-to-know/datatypes-and-patterns.html"><strong aria-hidden="true">1.5.</strong> Datatypes, Patterns and Recursion</a></li><li class="chapter-item expanded "><a href="getting-to-know/polymorphism.html"><strong aria-hidden="true">1.6.</strong> Polymorphism</a></li><li class="chapter-item expanded "><a href="getting-to-know/conveniences.html"><strong aria-hidden="true">1.7.</strong> Additional Conveniences</a></li><li class="chapter-item expanded "><a href="getting-to-know/summary.html"><strong aria-hidden="true">1.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="hello-world.html"><strong aria-hidden="true">2.</strong> Hello, World!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hello-world/running-a-program.html"><strong aria-hidden="true">2.1.</strong> Running a Program</a></li><li class="chapter-item expanded "><a href="hello-world/step-by-step.html"><strong aria-hidden="true">2.2.</strong> Step By Step</a></li><li class="chapter-item expanded "><a href="hello-world/starting-a-project.html"><strong aria-hidden="true">2.3.</strong> Starting a Project</a></li><li class="chapter-item expanded "><a href="hello-world/cat.html"><strong aria-hidden="true">2.4.</strong> Worked Example: cat</a></li><li class="chapter-item expanded "><a href="hello-world/conveniences.html"><strong aria-hidden="true">2.5.</strong> Additional Conveniences</a></li><li class="chapter-item expanded "><a href="hello-world/summary.html"><strong aria-hidden="true">2.6.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="props-proofs-indexing.html"><strong aria-hidden="true">3.</strong> Interlude: Propositions, Proofs, and Indexing</a></li><li class="chapter-item expanded "><a href="type-classes.html"><strong aria-hidden="true">4.</strong> Overloading and Type Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="type-classes/pos.html"><strong aria-hidden="true">4.1.</strong> Positive Numbers</a></li><li class="chapter-item expanded "><a href="type-classes/polymorphism.html"><strong aria-hidden="true">4.2.</strong> Type Classes and Polymorphism</a></li><li class="chapter-item expanded "><a href="type-classes/out-params.html"><strong aria-hidden="true">4.3.</strong> Controlling Instance Search</a></li><li class="chapter-item expanded "><a href="type-classes/indexing.html"><strong aria-hidden="true">4.4.</strong> Arrays and Indexing</a></li><li class="chapter-item expanded "><a href="type-classes/standard-classes.html"><strong aria-hidden="true">4.5.</strong> Standard Classes</a></li><li class="chapter-item expanded "><a href="type-classes/coercion.html"><strong aria-hidden="true">4.6.</strong> Coercions</a></li><li class="chapter-item expanded "><a href="type-classes/conveniences.html"><strong aria-hidden="true">4.7.</strong> Additional Conveniences</a></li><li class="chapter-item expanded "><a href="type-classes/summary.html"><strong aria-hidden="true">4.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="monads.html" class="active"><strong aria-hidden="true">5.</strong> Monads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="monads/class.html"><strong aria-hidden="true">5.1.</strong> The Monad Type Class</a></li><li class="chapter-item expanded "><a href="monads/arithmetic.html"><strong aria-hidden="true">5.2.</strong> Example: Arithmetic in Monads</a></li><li class="chapter-item expanded "><a href="monads/do.html"><strong aria-hidden="true">5.3.</strong> do-Notation for Monads</a></li><li class="chapter-item expanded "><a href="monads/io.html"><strong aria-hidden="true">5.4.</strong> The IO Monad</a></li><li class="chapter-item expanded "><a href="monads/conveniences.html"><strong aria-hidden="true">5.5.</strong> Additional Conveniences</a></li><li class="chapter-item expanded "><a href="monads/summary.html"><strong aria-hidden="true">5.6.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="functor-applicative-monad.html"><strong aria-hidden="true">6.</strong> Functors, Applicative Functors, and Monads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="functor-applicative-monad/inheritance.html"><strong aria-hidden="true">6.1.</strong> Structures and Inheritance</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/applicative.html"><strong aria-hidden="true">6.2.</strong> Applicative Functors</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/applicative-contract.html"><strong aria-hidden="true">6.3.</strong> The Applicative Contract</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/alternative.html"><strong aria-hidden="true">6.4.</strong> Alternatives</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/universes.html"><strong aria-hidden="true">6.5.</strong> Universes</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/complete.html"><strong aria-hidden="true">6.6.</strong> The Complete Definitions</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/summary.html"><strong aria-hidden="true">6.7.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="monad-transformers.html"><strong aria-hidden="true">7.</strong> Monad Transformers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="monad-transformers/reader-io.html"><strong aria-hidden="true">7.1.</strong> Combining IO and Reader</a></li><li class="chapter-item expanded "><a href="monad-transformers/transformers.html"><strong aria-hidden="true">7.2.</strong> A Monad Construction Kit</a></li><li class="chapter-item expanded "><a href="monad-transformers/order.html"><strong aria-hidden="true">7.3.</strong> Ordering Monad Transformers</a></li><li class="chapter-item expanded "><a href="monad-transformers/do.html"><strong aria-hidden="true">7.4.</strong> More do Features</a></li><li class="chapter-item expanded "><a href="monad-transformers/conveniences.html"><strong aria-hidden="true">7.5.</strong> Additional Conveniences</a></li><li class="chapter-item expanded "><a href="monad-transformers/summary.html"><strong aria-hidden="true">7.6.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="dependent-types.html"><strong aria-hidden="true">8.</strong> Programming with Dependent Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dependent-types/indexed-families.html"><strong aria-hidden="true">8.1.</strong> Indexed Families</a></li><li class="chapter-item expanded "><a href="dependent-types/universe-pattern.html"><strong aria-hidden="true">8.2.</strong> The Universe Design Pattern</a></li><li class="chapter-item expanded "><a href="dependent-types/typed-queries.html"><strong aria-hidden="true">8.3.</strong> Worked Example: Typed Queries</a></li><li class="chapter-item expanded "><a href="dependent-types/indices-parameters-universes.html"><strong aria-hidden="true">8.4.</strong> Indices, Parameters, and Universe Levels</a></li><li class="chapter-item expanded "><a href="dependent-types/pitfalls.html"><strong aria-hidden="true">8.5.</strong> Pitfalls of Programming with Dependent Types</a></li><li class="chapter-item expanded "><a href="dependent-types/summary.html"><strong aria-hidden="true">8.6.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="tactics-induction-proofs.html"><strong aria-hidden="true">9.</strong> Interlude: Tactics, Induction, and Proofs</a></li><li class="chapter-item expanded "><a href="programs-proofs.html"><strong aria-hidden="true">10.</strong> Programming, Proving, and Performance</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programs-proofs/tail-recursion.html"><strong aria-hidden="true">10.1.</strong> Tail Recursion</a></li><li class="chapter-item expanded "><a href="programs-proofs/tail-recursion-proofs.html"><strong aria-hidden="true">10.2.</strong> Proving Equivalence</a></li><li class="chapter-item expanded "><a href="programs-proofs/arrays-termination.html"><strong aria-hidden="true">10.3.</strong> Arrays and Termination</a></li><li class="chapter-item expanded "><a href="programs-proofs/inequalities.html"><strong aria-hidden="true">10.4.</strong> More Inequalities</a></li><li class="chapter-item expanded "><a href="programs-proofs/fin.html"><strong aria-hidden="true">10.5.</strong> Safe Array Indices</a></li><li class="chapter-item expanded "><a href="programs-proofs/insertion-sort.html"><strong aria-hidden="true">10.6.</strong> Insertion Sort and Array Mutation</a></li><li class="chapter-item expanded "><a href="programs-proofs/special-types.html"><strong aria-hidden="true">10.7.</strong> Special Types</a></li><li class="chapter-item expanded "><a href="programs-proofs/summary.html"><strong aria-hidden="true">10.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="next-steps.html">Next Steps</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Functional Programming in Lean</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="monads"><a class="header" href="#monads">Monads</a></h1>
<p>In C# and Kotlin, the <code>?.</code> operator is a way to look up a property or call a method on a potentially-null value.
If the reciever is <code>null</code>, the whole expression is null.
Otherwise, the underlying non-<code>null</code> value receives the call.
Uses of <code>?.</code> can be chained, in which case the first <code>null</code> result terminates the chain of lookups.
Chaining null-checks like this is much more convenient than writing and maintaining deeply nested <code>if</code>s.</p>
<p>Similarly, exceptions are significantly more convenient than manually checking and propagating error codes.
At the same time, logging is easiest to accomplish by having a dedicated logging framework, rather than having each function return both its log results and its return value.
Chained null checks and exceptions typically require language designers to anticipate this use case, while logging frameworks typically make use of side effects to decouple code that logs from the accumulation of the logs.</p>
<p>All these features and more can be implemented in library code as instances of a common API called <code>Monad</code>.
Lean provides dedicated syntax that makes this API convenient to use, but can also get in the way of understanding what is going on behind the scenes.
This chapter begins with the nitty-gritty presentation of manually nesting null checks, and builds from there to the convenient, general API.
Please suspend your disbelief in the meantime.</p>
<h2 id="checking-for-none-dont-repeat-yourself"><a class="header" href="#checking-for-none-dont-repeat-yourself">Checking for <code>none</code>: Don't Repeat Yourself</a></h2>
<p>In Lean, pattern matching can be used to chain checks for null.
Getting the first entry from a list can just use the optional indexing notation:</p>
<pre><code class="language-lean">def first (xs : List α) : Option α :=
  xs[0]?
</code></pre>
<p>The result must be an <code>Option</code> because empty lists have no first entry.
Extracting the first and third entries requires a check that each is not <code>none</code>:</p>
<pre><code class="language-lean">def firstThird (xs : List α) : Option (α × α) :=
  match xs[0]? with
  | none =&gt; none
  | some first =&gt;
    match xs[2]? with
    | none =&gt; none
    | some third =&gt;
      some (first, third)
</code></pre>
<p>Similarly, extracting the first, third, and fifth entries requires more checks that the values are not <code>none</code>:</p>
<pre><code class="language-lean">def firstThirdFifth (xs : List α) : Option (α × α × α) :=
  match xs[0]? with
  | none =&gt; none
  | some first =&gt;
    match xs[2]? with
    | none =&gt; none
    | some third =&gt;
      match xs[4]? with
      | none =&gt; none
      | some fifth =&gt;
        some (first, third, fifth)
</code></pre>
<p>And adding the seventh entry to this sequence begins to become quite unmanageable:</p>
<pre><code class="language-lean">def firstThirdFifthSeventh (xs : List α) : Option (α × α × α × α) :=
  match xs[0]? with
  | none =&gt; none
  | some first =&gt;
    match xs[2]? with
    | none =&gt; none
    | some third =&gt;
      match xs[4]? with
      | none =&gt; none
      | some fifth =&gt;
        match xs[6]? with
        | none =&gt; none
        | some seventh =&gt;
          some (first, third, fifth, seventh)
</code></pre>
<p>The fundamental problem with this code is that it addresses two concerns: extracting the numbers and checking that all of them are present, but the second concern is addressed by copying and pasting the code that handles the <code>none</code> case.
It is often good style to lift a repetitive segment into a helper function:</p>
<pre><code class="language-lean">def andThen (opt : Option α) (next : α → Option β) : Option β :=
  match opt with
  | none =&gt; none
  | some x =&gt; next x
</code></pre>
<p>This helper, which is used similarly to <code>?.</code> in C# and Kotlin, takes care of propagating <code>none</code> values.
It takes two arguments: an optional value and a function to apply when the value is not <code>none</code>.
If the first argument is <code>none</code>, then the helper returns <code>none</code>.
If the first argument is not <code>none</code>, then the function is applied to the contents of the <code>some</code> constructor.</p>
<p>Now, <code>firstThird</code> can be rewritten to use <code>andThen</code> instead of pattern matching:</p>
<pre><code class="language-lean">def firstThird (xs : List α) : Option (α × α) :=
  andThen xs[0]? fun first =&gt;
  andThen xs[2]? fun third =&gt;
  some (first, third)
</code></pre>
<p>In Lean, functions don't need to be enclosed in parentheses when passed as arguments.
The following equivalent definition uses more parentheses and indents the bodies of functions:</p>
<pre><code class="language-lean">def firstThird (xs : List α) : Option (α × α) :=
  andThen xs[0]? (fun first =&gt;
    andThen xs[2]? (fun third =&gt;
      some (first, third)))
</code></pre>
<p>The <code>andThen</code> helper provides a sort of &quot;pipeline&quot; through which values flow, and the version with the somewhat unusual indentation is more suggestive of this fact.
Improving the syntax used to write <code>andThen</code> can make these computations even easier to understand.</p>
<h3 id="infix-operators"><a class="header" href="#infix-operators">Infix Operators</a></h3>
<p>In Lean, infix operators can be declared using the <code>infix</code>, <code>infixl</code>, and <code>infixr</code> commands, which create (respectively) non-associative, left-associative, and right-associative operators.
When used multiple times in a row, a <em>left associative</em> operator stacks up the opening parentheses on the left side of the expression.
The addition operator <code>+</code> is left associative, so <code>w + x + y + z</code> is equivalent to <code>(((w + x) + y) + z)</code>.
The exponentiation operator <code>^</code> is right associative, so <code>w ^ x ^ y ^ z</code> is equivalent to <code>(w ^ (x ^ (y ^ z)))</code>.
Comparison operators such as <code>&lt;</code> are non-associative, so <code>x &lt; y &lt; z</code> is a syntax error and requires manual parentheses.</p>
<p>The following declaration makes <code>andThen</code> into an infix operator:</p>
<pre><code class="language-lean">infixl:55 &quot; ~~&gt; &quot; =&gt; andThen
</code></pre>
<p>The number following the colon declares the <em>precedence</em> of the new infix operator.
In ordinary mathematical notation, <code>x + y * z</code> is equivalent to <code>x + (y * z)</code> even though both <code>+</code> and <code>*</code> are left associative.
In Lean, <code>+</code> has precedence 65 and <code>*</code> has precedence 70.
Higher-precedence operators are applied before lower-precedence operators.
According to the declaration of <code>~~&gt;</code>, both <code>+</code> and <code>*</code> have higher precedence, and thus apply first.
Typically, figuring out the most convenient precedences for a group of operators requires some experimentation and a large collection of examples.</p>
<p>Following the new infix operator is a double arrow <code>=&gt;</code>, which specifies the named function to be used for the infix operator.
Lean's standard library uses this feature to define <code>+</code> and <code>*</code> as infix operators that point at <code>HAdd.hAdd</code> and <code>HMul.hMul</code>, respectively, allowing type classes to be used to overload the infix operators.
Here, however, <code>andThen</code> is just an ordinary function.</p>
<p>Having defined an infix operator for <code>andThen</code>, <code>firstThird</code> can be rewritten in a way that brings the &quot;pipeline&quot; feeling of <code>none</code>-checks front and center:</p>
<pre><code class="language-lean">def firstThirdInfix (xs : List α) : Option (α × α) :=
  xs[0]? ~~&gt; fun first =&gt;
  xs[2]? ~~&gt; fun third =&gt;
  some (first, third)
</code></pre>
<p>This style is much more concise when writing larger functions:</p>
<pre><code class="language-lean">def firstThirdFifthSeventh (xs : List α) : Option (α × α × α × α) :=
  xs[0]? ~~&gt; fun first =&gt;
  xs[2]? ~~&gt; fun third =&gt;
  xs[4]? ~~&gt; fun fifth =&gt;
  xs[6]? ~~&gt; fun seventh =&gt;
  some (first, third, fifth, seventh)
</code></pre>
<h2 id="propagating-error-messages"><a class="header" href="#propagating-error-messages">Propagating Error Messages</a></h2>
<p>Pure functional languages such as Lean have no built-in exception mechanism for error handling, because throwing or catching an exception is outside of the step-by-step evaluation model for expressions.
However, functional programs certainly need to handle errors.
In the case of <code>firstThirdFifthSeventh</code>, it is likely relevant for a user to know just how long the list was and where the lookup failed.</p>
<p>This is typically accomplished by defining a datatype that can be either an error or a result, and translating functions with exceptions into functions that return this datatype:</p>
<pre><code class="language-lean">inductive Except (ε : Type) (α : Type) where
  | error : ε → Except ε α
  | ok : α → Except ε α
deriving BEq, Hashable, Repr
</code></pre>
<p>The type variable <code>ε</code> stands for the type of errors that can be produced by the function.
Callers are expected to handle both errors and successes, which makes the type variable <code>ε</code> play a role that is a bit like that of a list of checked exceptions in Java.</p>
<p>Similarly to <code>Option</code>, <code>Except</code> can be used to indicate a failure to find an entry in a list.
In this case, the error type is a <code>String</code>:</p>
<pre><code class="language-lean">def get (xs : List α) (i : Nat) : Except String α :=
  match xs[i]? with
  | none =&gt; Except.error s!&quot;Index {i} not found (maximum is {xs.length - 1})&quot;
  | some x =&gt; Except.ok x
</code></pre>
<p>Looking up an in-bounds value yields an <code>Except.ok</code>:</p>
<pre><code class="language-lean">def ediblePlants : List String :=
  [&quot;ramsons&quot;, &quot;sea plantain&quot;, &quot;sea buckthorn&quot;, &quot;garden nasturtium&quot;]

#eval get ediblePlants 2
</code></pre>
<pre><code class="language-output info">Except.ok &quot;sea buckthorn&quot;
</code></pre>
<p>Looking up an out-of-bounds value yields an <code>Except.failure</code>:</p>
<pre><code class="language-lean">#eval get ediblePlants 4
</code></pre>
<pre><code class="language-output info">Except.error &quot;Index 4 not found (maximum is 3)&quot;
</code></pre>
<p>A single list lookup can conveniently return a value or an error:</p>
<pre><code class="language-lean">def first (xs : List α) : Except String α :=
  get xs 0
</code></pre>
<p>However, performing two list lookups requires handling potential failures:</p>
<pre><code class="language-lean">def firstThird (xs : List α) : Except String (α × α) :=
  match get xs 0 with
  | Except.error msg =&gt; Except.error msg
  | Except.ok first =&gt;
    match get xs 2 with
    | Except.error msg =&gt; Except.error msg
    | Except.ok third =&gt;
      Except.ok (first, third)
</code></pre>
<p>Adding another list lookup to the function requires still more error handling:</p>
<pre><code class="language-lean">def firstThirdFifth (xs : List α) : Except String (α × α × α) :=
  match get xs 0 with
  | Except.error msg =&gt; Except.error msg
  | Except.ok first =&gt;
    match get xs 2 with
    | Except.error msg =&gt; Except.error msg
    | Except.ok third =&gt;
      match get xs 4 with
      | Except.error msg =&gt; Except.error msg
      | Except.ok fifth =&gt;
        Except.ok (first, third, fifth)
</code></pre>
<p>And one more list lookup begins to become quite unmanageable:</p>
<pre><code class="language-lean">def firstThirdFifthSeventh (xs : List α) : Except String (α × α × α × α) :=
  match get xs 0 with
  | Except.error msg =&gt; Except.error msg
  | Except.ok first =&gt;
    match get xs 2 with
    | Except.error msg =&gt; Except.error msg
    | Except.ok third =&gt;
      match get xs 4 with
      | Except.error msg =&gt; Except.error msg
      | Except.ok fifth =&gt;
        match get xs 6 with
        | Except.error msg =&gt; Except.error msg
        | Except.ok seventh =&gt;
          Except.ok (first, third, fifth, seventh)
</code></pre>
<p>Once again, a common pattern can be factored out into a helper.
Each step through the function checks for an error, and only proceeds with the rest of the computation if the result was a success.
A new version of <code>andThen</code> can be defined for <code>Except</code>:</p>
<pre><code class="language-lean">def andThen (attempt : Except e α) (next : α → Except e β) : Except e β :=
  match attempt with
  | Except.error msg =&gt; Except.error msg
  | Except.ok x =&gt; next x
</code></pre>
<p>Just as with <code>Option</code>, this version of <code>andThen</code> allows a more concise definition of <code>firstThird</code>:</p>
<pre><code class="language-lean">def firstThird' (xs : List α) : Except String (α × α) :=
  andThen (get xs 0) fun first  =&gt;
  andThen (get xs 2) fun third =&gt;
  Except.ok (first, third)
</code></pre>
<p>In both the <code>Option</code> and <code>Except</code> case, there are two repeating patterns: there is the checking of intermediate results at each step, which has been factored out into <code>andThen</code>, and there is the final successful result, which is <code>some</code> or <code>Except.ok</code>, respectively.
For the sake of convenience, success can be factored out into a helper called <code>ok</code>:</p>
<pre><code class="language-lean">def ok (x : α) : Except ε α := Except.ok x
</code></pre>
<p>Similarly, failure can be factored out into a helper called <code>fail</code>:</p>
<pre><code class="language-lean">def fail (err : ε) : Except ε α := Except.error err
</code></pre>
<p>Using <code>ok</code> and <code>fail</code> makes <code>get</code> a little more readable:</p>
<pre><code class="language-lean">def get (xs : List α) (i : Nat) : Except String α :=
  match xs[i]? with
  | none =&gt; fail s!&quot;Index {i} not found (maximum is {xs.length - 1})&quot;
  | some x =&gt; ok x
</code></pre>
<p>After adding the infix declaration for <code>andThen</code>, <code>firstThird</code> can be just as concise as the version that returns an <code>Option</code>:</p>
<pre><code class="language-lean">infixl:55 &quot; ~~&gt; &quot; =&gt; andThen

def firstThird (xs : List α) : Except String (α × α) :=
  get xs 0 ~~&gt; fun first =&gt;
  get xs 2 ~~&gt; fun third =&gt;
  ok (first, third)
</code></pre>
<p>The technique scales similarly to larger functions:</p>
<pre><code class="language-lean">def firstThirdFifthSeventh (xs : List α) : Except String (α × α × α × α) :=
  get xs 0 ~~&gt; fun first =&gt;
  get xs 2 ~~&gt; fun third =&gt;
  get xs 4 ~~&gt; fun fifth =&gt;
  get xs 6 ~~&gt; fun seventh =&gt;
  ok (first, third, fifth, seventh)
</code></pre>
<h2 id="logging"><a class="header" href="#logging">Logging</a></h2>
<p>A number is even if dividing it by 2 leaves no remainder:</p>
<pre><code class="language-lean">def isEven (i : Int) : Bool :=
  i % 2 == 0
</code></pre>
<p>The function <code>sumAndFindEvens</code> computes the sum of a list while remembering the even numbers encountered along the way:</p>
<pre><code class="language-lean">def sumAndFindEvens : List Int → List Int × Int
  | [] =&gt; ([], 0)
  | i :: is =&gt;
    let (moreEven, sum) := sumAndFindEvens is
    (if isEven i then i :: moreEven else moreEven, sum + i)
</code></pre>
<p>This function is a simplified example of a common pattern.
Many programs need to traverse a data structure once, while both computing a main result and accumulating some kind of tertiary extra result.
One example of this is logging: a program that is an <code>IO</code> action can always log to a file on disk, but because the disk is outside of the mathematical world of Lean functions, it becomes much more difficult to prove things about logs based on <code>IO</code>.
Another example is a function that computes the sum of all the nodes in a tree with an inorder traversal, while simultaneously recording each nodes visited:</p>
<pre><code class="language-lean">def inorderSum : BinTree Int → List Int × Int
  | BinTree.leaf =&gt; ([], 0)
  | BinTree.branch l x r =&gt;
    let (leftVisited, leftSum) := inorderSum l
    let (hereVisited, hereSum) := ([x], x)
    let (rightVisited, rightSum) := inorderSum r
    (leftVisited ++ hereVisited ++ rightVisited, leftSum + hereSum + rightSum)
</code></pre>
<p>Both <code>sumAndFindEvens</code> and <code>inorderSum</code> have a common repetitive structure.
Each step of computation returns a pair that consists of a list of data that have been saved along with the primary result.
The lists are then appended, and the primary result is computed and paired with the appended lists.
The common structure becomes more apparent with a small rewrite of <code>sumAndFindEvens</code> that more cleanly separates the concerns of saving even numbers and computing the sum:</p>
<pre><code class="language-lean">def sumAndFindEvens : List Int → List Int × Int
  | [] =&gt; ([], 0)
  | i :: is =&gt;
    let (moreEven, sum) := sumAndFindEvens is
    let (evenHere, ()) := (if isEven i then [i] else [], ())
    (evenHere ++ moreEven, sum + i)
</code></pre>
<p>For the sake of clarity, a pair that consists of an accumulated result together with a value can be given its own name:</p>
<pre><code class="language-lean">structure WithLog (logged : Type) (α : Type) where
  log : List logged
  val : α
</code></pre>
<p>Similarly, the process of saving a list of accumulated results while passing a value on to the next step of a computation can be factored out into a helper, once again named <code>andThen</code>:</p>
<pre><code class="language-lean">def andThen (result : WithLog α β) (next : β → WithLog α γ) : WithLog α γ :=
  let {log := thisOut, val := thisRes} := result
  let {log := nextOut, val := nextRes} := next thisRes
  {log := thisOut ++ nextOut, val := nextRes}
</code></pre>
<p>In the case of errors, <code>ok</code> represents an operation that always succeeds.
Here, however, it is an operation that simply returns a value without logging anything:</p>
<pre><code class="language-lean">def ok (x : β) : WithLog α β := {log := [], val := x}
</code></pre>
<p>Just as <code>Except</code> provides <code>fail</code> as a possibility, <code>WithLog</code> should allow items to be added to a log.
This has no interesting return value associated with it, so it returns <code>Unit</code>:</p>
<pre><code class="language-lean">def save (data : α) : WithLog α Unit :=
  {log := [data], val := ()}
</code></pre>
<p><code>WithLog</code>, <code>andThen</code>, <code>ok</code>, and <code>save</code> can be used to separate the logging concern from the summing concern in both programs:</p>
<pre><code class="language-lean">def sumAndFindEvens : List Int → WithLog Int Int
  | [] =&gt; ok 0
  | i :: is =&gt;
    andThen (if isEven i then save i else ok ()) fun () =&gt;
    andThen (sumAndFindEvens is) fun sum =&gt;
    ok (i + sum)

def inorderSum : BinTree Int → WithLog Int Int
  | BinTree.leaf =&gt; ok 0
  | BinTree.branch l x r =&gt;
    andThen (inorderSum l) fun leftSum =&gt;
    andThen (save x) fun () =&gt;
    andThen (inorderSum r) fun rightSum =&gt;
    ok (leftSum + x + rightSum)
</code></pre>
<p>And, once again, the infix operator helps put focus on the correct steps:</p>
<pre><code class="language-lean">infixl:55 &quot; ~~&gt; &quot; =&gt; andThen

def sumAndFindEvens : List Int → WithLog Int Int
  | [] =&gt; ok 0
  | i :: is =&gt;
    (if isEven i then save i else ok ()) ~~&gt; fun () =&gt;
    sumAndFindEvens is ~~&gt; fun sum =&gt;
    ok (i + sum)

def inorderSum : BinTree Int → WithLog Int Int
  | BinTree.leaf =&gt; ok 0
  | BinTree.branch l x r =&gt;
    inorderSum l ~~&gt; fun leftSum =&gt;
    save x ~~&gt; fun () =&gt;
    inorderSum r ~~&gt; fun rightSum =&gt;
    ok (leftSum + x + rightSum)
</code></pre>
<h2 id="numbering-tree-nodes"><a class="header" href="#numbering-tree-nodes">Numbering Tree Nodes</a></h2>
<p>An <em>inorder numbering</em> of a tree associates each data point in the tree with the step it would be visited at in an inorder traversal of the tree.
For example, consider <code>aTree</code>:</p>
<pre><code class="language-lean">open BinTree in
def aTree :=
  branch
    (branch
       (branch leaf &quot;a&quot; (branch leaf &quot;b&quot; leaf))
       &quot;c&quot;
       leaf)
    &quot;d&quot;
    (branch leaf &quot;e&quot; leaf)
</code></pre>
<p>Its inorder numbering is:</p>
<pre><code class="language-output info">BinTree.branch
  (BinTree.branch
    (BinTree.branch (BinTree.leaf) (0, &quot;a&quot;) (BinTree.branch (BinTree.leaf) (1, &quot;b&quot;) (BinTree.leaf)))
    (2, &quot;c&quot;)
    (BinTree.leaf))
  (3, &quot;d&quot;)
  (BinTree.branch (BinTree.leaf) (4, &quot;e&quot;) (BinTree.leaf))
</code></pre>
<p>Trees are most naturally processed with recursive functions, but the usual pattern of recursion on trees makes it difficult to compute an inorder numbering.
This is because the highest number assigned anywhere in the left subtree is used to determine the numbering of a node's data value, and then again to determine the starting point for numbering the right subtree.
In an imperative language, this issue can be worked around by using a mutable variable that contains the next number to be assigned.
The following Python program computes an inorder numbering using a mutable variable:</p>
<pre><code class="language-python">class Branch:
    def __init__(self, value, left=None, right=None):
        self.left = left
        self.value = value
        self.right = right
    def __repr__(self):
        return f'Branch({self.value!r}, left={self.left!r}, right={self.right!r})'

def number(tree):
    num = 0
    def helper(t):
        nonlocal num
        if t is None:
            return None
        else:
            new_left = helper(t.left)
            new_value = (num, t.value)
            num += 1
            new_right = helper(t.right)
            return Branch(left=new_left, value=new_value, right=new_right)

    return helper(tree)
</code></pre>
<p>The numbering of the Python equivalent of <code>aTree</code> is:</p>
<pre><code class="language-python">a_tree = Branch(&quot;d&quot;,
                left=Branch(&quot;c&quot;,
                            left=Branch(&quot;a&quot;, left=None, right=Branch(&quot;b&quot;)),
                            right=None),
                right=Branch(&quot;e&quot;))
</code></pre>
<p>and its numbering is:</p>
<pre><code>&gt;&gt;&gt; number(a_tree)
Branch((3, 'd'), left=Branch((2, 'c'), left=Branch((0, 'a'), left=None, right=Branch((1, 'b'), left=None, right=None)), right=None), right=Branch((4, 'e'), left=None, right=None))
</code></pre>
<p>Even though Lean does not have mutable variables, a workaround exists.
From the point of view of the rest of the world, the mutable variable can be thought of as having two relevant aspects: its value when the function is called, and its value when the function returns.
In other words, a function that uses a mutable variable can be seen as a function that takes the mutable variable's starting value as an argument, returning a pair of the variable's final value and the function's result.
This final value can then be passed as an argument to the next step.</p>
<p>Just as the Python example uses an outer function that establishes a mutable variable and an inner helper function that changes the variable, a Lean version of the function uses an outer function that provides the variable's starting value and explicitly returns the function's result along with an inner helper function that threads the variable's value while computing the numbered tree:</p>
<pre><code class="language-lean">def number (t : BinTree α) : BinTree (Nat × α) :=
  let rec helper (n : Nat) : BinTree α → (Nat × BinTree (Nat × α))
    | BinTree.leaf =&gt; (n, BinTree.leaf)
    | BinTree.branch left x right =&gt;
      let (k, numberedLeft) := helper n left
      let (i, numberedRight) := helper (k + 1) right
      (i, BinTree.branch numberedLeft (k, x) numberedRight)
  (helper 0 t).snd
</code></pre>
<p>This code, like the <code>none</code>-propagating <code>Option</code> code, the <code>error</code>-propagating <code>Except</code> code, and the log-accumulating <code>WithLog</code> code, commingles two concerns: propagating the value of the counter, and actually traversing the tree to find the result.
Just as in those cases, an <code>andThen</code> helper can be defined to propagate state from one step of a computation to another.
The first step is to give a name to the pattern of taking an input state as an argument and returning an output state together with a value:</p>
<pre><code class="language-lean">def State (σ : Type) (α : Type) : Type :=
  σ → (σ × α)
</code></pre>
<p>In the case of <code>State</code>, <code>ok</code> is a function that returns the input state unchanged, along with the provided value:</p>
<pre><code class="language-lean">def ok (x : α) : State σ α :=
  fun s =&gt; (s, x)
</code></pre>
<p>When working with a mutable variable, there are two fundamental operations: reading the value and replacing it with a new one.
Reading the current value is accomplished with a function that places the input state unmodified into the output state, and also places it into the value field:</p>
<pre><code class="language-lean">def get : State σ σ :=
  fun s =&gt; (s, s)
</code></pre>
<p>Writing a new value consists of ignoring the input state, and placing the provided new value into the output state:</p>
<pre><code class="language-lean">def set (s : σ) : State σ Unit :=
  fun _ =&gt; (s, ())
</code></pre>
<p>Finally, two computations that use state can be sequenced by finding both the output state and return value of the first function, then passing them both into the next function:</p>
<pre><code class="language-lean">def andThen (first : State σ α) (next : α → State σ β) : State σ β :=
  fun s =&gt;
    let (s', x) := first s
    next x s'

infixl:55 &quot; ~~&gt; &quot; =&gt; andThen
</code></pre>
<p>Using <code>State</code> and its helpers, local mutable state can be simulated:</p>
<pre><code class="language-lean">def number (t : BinTree α) : BinTree (Nat × α) :=
  let rec helper : BinTree α → State Nat (BinTree (Nat × α))
    | BinTree.leaf =&gt; ok BinTree.leaf
    | BinTree.branch left x right =&gt;
      helper left ~~&gt; fun numberedLeft =&gt;
      get ~~&gt; fun n =&gt;
      set (n + 1) ~~&gt; fun () =&gt;
      helper right ~~&gt; fun numberedRight =&gt;
      ok (BinTree.branch numberedLeft (n, x) numberedRight)
  (helper t 0).snd
</code></pre>
<p>Because <code>State</code> simulates only a single local variable, <code>get</code> and <code>set</code> don't need to refer to any particular variable name.</p>
<h2 id="monads-a-functional-design-pattern"><a class="header" href="#monads-a-functional-design-pattern">Monads: A Functional Design Pattern</a></h2>
<p>Each of these examples has consisted of:</p>
<ul>
<li>A polymorphic type, such as <code>Option</code>, <code>Except ε</code>, <code>WithLog logged</code>, or <code>State σ</code></li>
<li>An operator <code>andThen</code> that takes care of some repetitive aspect of sequencing programs that have this type</li>
<li>An operator <code>ok</code> that is (in some sense) the most boring way to use the type</li>
<li>A collection of other operations, such as <code>none</code>, <code>fail</code>, <code>save</code>, and <code>get</code>, that name ways of using the type</li>
</ul>
<p>This style of API is called a <em>monad</em>.
While the idea of monads is derived from a branch of mathematics called category theory, no understanding of category theory is needed in order to use them for programming.
The key idea of monads is that each monad encodes a particular kind of side effect using the tools provided by the pure functional language Lean.
For example, <code>Option</code> represents programs that can fail by returning <code>none</code>, <code>Except</code> represents programs that can throw exceptions, <code>WithLog</code> represents programs that accumulate a log while running, and <code>State</code> represents programs with a single mutable variable.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="type-classes/summary.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="monads/class.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="type-classes/summary.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="monads/class.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
