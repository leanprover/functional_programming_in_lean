<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Functional Programming in Lean</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">
        <link rel="stylesheet" href="pygments.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title.html">Functional Programming in Lean</a></li><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="getting-to-know.html"><strong aria-hidden="true">1.</strong> Getting to Know Lean</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-to-know/evaluating.html"><strong aria-hidden="true">1.1.</strong> Evaluating Expressions</a></li><li class="chapter-item expanded "><a href="getting-to-know/types.html"><strong aria-hidden="true">1.2.</strong> Types</a></li><li class="chapter-item expanded "><a href="getting-to-know/functions-and-definitions.html"><strong aria-hidden="true">1.3.</strong> Functions and Definitions</a></li><li class="chapter-item expanded "><a href="getting-to-know/structures.html"><strong aria-hidden="true">1.4.</strong> Structures</a></li><li class="chapter-item expanded "><a href="getting-to-know/datatypes-and-patterns.html"><strong aria-hidden="true">1.5.</strong> Datatypes, Patterns and Recursion</a></li><li class="chapter-item expanded "><a href="getting-to-know/polymorphism.html"><strong aria-hidden="true">1.6.</strong> Polymorphism</a></li><li class="chapter-item expanded "><a href="getting-to-know/conveniences.html"><strong aria-hidden="true">1.7.</strong> Additional Conveniences</a></li><li class="chapter-item expanded "><a href="getting-to-know/summary.html"><strong aria-hidden="true">1.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="hello-world.html"><strong aria-hidden="true">2.</strong> Hello, World!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hello-world/running-a-program.html"><strong aria-hidden="true">2.1.</strong> Running a Program</a></li><li class="chapter-item expanded "><a href="hello-world/step-by-step.html"><strong aria-hidden="true">2.2.</strong> Step By Step</a></li><li class="chapter-item expanded "><a href="hello-world/starting-a-project.html"><strong aria-hidden="true">2.3.</strong> Starting a Project</a></li><li class="chapter-item expanded "><a href="hello-world/cat.html"><strong aria-hidden="true">2.4.</strong> Worked Example: cat</a></li><li class="chapter-item expanded "><a href="hello-world/conveniences.html"><strong aria-hidden="true">2.5.</strong> Additional Conveniences</a></li><li class="chapter-item expanded "><a href="hello-world/summary.html"><strong aria-hidden="true">2.6.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="props-proofs-indexing.html"><strong aria-hidden="true">3.</strong> Interlude: Propositions, Proofs, and Indexing</a></li><li class="chapter-item expanded "><a href="type-classes.html"><strong aria-hidden="true">4.</strong> Overloading and Type Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="type-classes/pos.html"><strong aria-hidden="true">4.1.</strong> Positive Numbers</a></li><li class="chapter-item expanded "><a href="type-classes/polymorphism.html"><strong aria-hidden="true">4.2.</strong> Type Classes and Polymorphism</a></li><li class="chapter-item expanded "><a href="type-classes/out-params.html"><strong aria-hidden="true">4.3.</strong> Controlling Instance Search</a></li><li class="chapter-item expanded "><a href="type-classes/indexing.html"><strong aria-hidden="true">4.4.</strong> Arrays and Indexing</a></li><li class="chapter-item expanded "><a href="type-classes/standard-classes.html"><strong aria-hidden="true">4.5.</strong> Standard Classes</a></li><li class="chapter-item expanded "><a href="type-classes/coercion.html"><strong aria-hidden="true">4.6.</strong> Coercions</a></li><li class="chapter-item expanded "><a href="type-classes/conveniences.html"><strong aria-hidden="true">4.7.</strong> Additional Conveniences</a></li><li class="chapter-item expanded "><a href="type-classes/summary.html"><strong aria-hidden="true">4.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Monads</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> IO Revisited</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Monad Transformers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Programming with Dependent Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> From Programming to Proving</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Functional Programming in Lean</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="functional-programming-in-lean"><a class="header" href="#functional-programming-in-lean">Functional Programming in Lean</a></h1>
<p><em>by David Thrane Christiansen</em></p>
<p>This is an in-progress book on using Lean 4 as a programming language.
The most recent release is found at <a href="https://leanprover.github.io/functional_programming_in_lean/">https://leanprover.github.io/functional_programming_in_lean/</a>, and it will be updated monthly.
This version of the text is written for Lean 4 release <code>nightly-2022-10-29</code>.</p>
<h2 id="release-history"><a class="header" href="#release-history">Release history</a></h2>
<h3 id="october-2022"><a class="header" href="#october-2022">October, 2022</a></h3>
<p>This release completes the chapter on type classes. In addition, a short interlude introducing propositions, proofs, and tactics has been added just before the chapter on type classes, because a small amount of familiarity with the concepts helps to understand some of the standard library type classes.</p>
<h3 id="september-2022"><a class="header" href="#september-2022">September, 2022</a></h3>
<p>This release adds the first half of a chapter on type classes, which are Lean's mechanism for overloading operators and an important means of organizing code and structuring libraries. Additionally, the second chapter has been updated to account for changes in Lean's stream API.</p>
<h3 id="august-2022"><a class="header" href="#august-2022">August, 2022</a></h3>
<p>This third public release adds a second chapter, which describes compiling and running programs along with Lean's model for side effects.</p>
<h3 id="july-2022"><a class="header" href="#july-2022">July, 2022</a></h3>
<p>The second public release completes the first chapter.</p>
<h3 id="june-2022"><a class="header" href="#june-2022">June, 2022</a></h3>
<p>This was the first public release, consisting of an introduction and part of the first chapter.</p>
<h2 id="about-the-author"><a class="header" href="#about-the-author">About the Author</a></h2>
<p>David Thrane Christiansen has been using functional languages for twenty years, and dependent types for ten.
Together with Daniel P. Friedman, he wrote <a href="https://thelittletyper.com/"><em>The Little Typer</em></a>, an introduction to the key ideas of dependent type theory.
He has a Ph.D. from the IT University of Copenhagen.
During his studies, he was a major contributor to the first version of the Idris language.
Since leaving academia, he has worked at Galois in Portland, Oregon and Deon Digital in Copenhagen, Denmark.
At the time of writing, he is the Executive Director of the Haskell Foundation.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Lean is an interactive theorem prover developed at Microsoft Research, based on dependent type theory.
Dependent type theory unites the worlds of programs and proofs; thus, Lean is also a programming language.
Lean takes its dual nature seriously, and it is designed to be suitable for use as a general-purpose programming language—Lean is even implemented in itself.
This book is about writing programs in Lean.</p>
<p>When viewed as a programming language, Lean is a strict pure functional language with dependent types.
A large part of learning to program with Lean consists of learning how each of these attributes affects the way programs are written, and how to think like a functional programmer.
<em>Strictness</em> means that function calls in Lean work similarly to the way they do in most languages: the arguments are fully computed before the function's body begins running.
<em>Purity</em> means that Lean programs cannot have side effects such as modifying locations in memory, sending emails, or deleting files without the program's type saying so.
Lean is a <em>functional</em> language in the sense that functions are first-class values like any other and that the execution model is inspired by the evaluation of mathematical expressions.
<em>Dependent types</em>, which are the most unusual feature of Lean, make types into a first-class part of the language, allowing types to contain programs and programs to compute types.</p>
<p>This book is intended for programmers who want to learn Lean, but who have not necessarily used a functional programming language before.
Familiarity with functional languages such as Haskell, OCaml, or F# is not required.
On the other hand, this book does assume knowledge of concepts like loops, functions, and data structures that are common to most programming languages.
While this book is intended to be a good first book on functional programming, it is not a good first book on programming in general.</p>
<p>Mathematicians who are using Lean as a proof assistant will likely need to write custom proof automation tools at some point.
This book is also for them.
As these tools become more sophisticated, they begin to resemble programs in functional languages, but most working mathematicians are trained in languages like Python and Mathematica.
This book can help bridge the gap, empowering more mathematicians to write maintainable and understandable proof automation tools.</p>
<p>This book is intended to be read linearly, from the beginning to the end.
Concepts are introduced one at a time, and later sections assume familiarity with earlier sections.
Sometimes, later chapters will go into depth on a topic that was only briefly addressed earlier on.
Some sections of the book contain exercises.
These are worth doing, in order to cement your understanding of the section.
It is also useful to explore Lean as you read the book, finding creative new ways to use what you have learned.</p>
<h1 id="getting-lean"><a class="header" href="#getting-lean">Getting Lean</a></h1>
<p>Before writing and running programs written in Lean, you'll need to set up Lean on your own computer.
The Lean tooling consists of the following:</p>
<ul>
<li><code>elan</code> manages the Lean compiler toolchains, similarly to <code>rustup</code> or <code>ghcup</code>.</li>
<li><code>lake</code> builds Lean packages and their dependencies, similarly to <code>cargo</code>, <code>make</code>, or Gradle.</li>
<li><code>lean</code> type checks and compiles individual Lean files as well as providing information to programmer tools about files that are currently being written.
Normally, <code>lean</code> is invoked by other tools rather than directly by users.</li>
<li>Plugins for editors, such as Visual Studio Code or Emacs, that communicate with <code>lean</code> and present its information conveniently.</li>
</ul>
<p>Please refer to the <a href="https://leanprover.github.io/lean4/doc/quickstart.html">Lean manual</a> for up-to-date instructions for installing Lean.</p>
<h1 id="typographical-conventions"><a class="header" href="#typographical-conventions">Typographical Conventions</a></h1>
<p>Code examples that are provided to Lean as <em>input</em> are formatted like this:</p>
<pre><code class="language-lean">def add1 (n : Nat) : Nat := n + 1

#eval add1 7
</code></pre>
<p>The last line above (beginning with <code>#eval</code>) is a command that instructs Lean to calculate an answer.
Lean's replies are formatted like this:</p>
<pre><code class="language-output info">8
</code></pre>
<p>Error messages returned by Lean are formatted like this:</p>
<pre><code class="language-output error">application type mismatch
  add1 &quot;seven&quot;
argument
  &quot;seven&quot;
has type
  String : Type
but is expected to have type
  Nat : Type
</code></pre>
<h1 id="unicode"><a class="header" href="#unicode">Unicode</a></h1>
<p>Idiomatic Lean code makes use of a variety of Unicode characters that are not part of ASCII.
For instance, Greek letters like <code>α</code> and <code>β</code> and the arrow <code>→</code> both occur in the first chapter of this book.
This allows Lean code to more closely resemble ordinary mathematical notation.</p>
<p>With the default Lean settings, both Visual Studio Code and Emacs allow these characters to be typed with a backslash (<code>\</code>) followed by a name.
For example, to enter <code>α</code>, type <code>\alpha</code>.
To find out how to type a character in Visual Studio Code, point the mouse at it and look at the tooltip.
In Emacs, use <code>C-c C-k</code> with point on the character in question.</p>
<div style="break-before: page; page-break-before: always;"></div><p>According to tradition, a programming language should be introduced by
compiling and running a program that displays <code>&quot;Hello, world!&quot;</code> on the
console. This simple program ensures that the language tooling is
installed correctly and that the programmer is able to run the
compiled code.</p>
<p>Since the 1970s, however, programming has changed. Today, compilers
are typically integrated into text editors, and the programming
environment offers feedback as the program is written. Lean is no
exception: it implements an extended version of the Language Server
Protocol that allows it to communicate with a text editor and provide
feedback as the user types.</p>
<p>Languages as varied as Python, Haskell, and JavaScript offer a read-eval-print-loop (REPL), also known as an interactive toplevel or a browser console, in which expressions or statements can be entered.
The language then computes and displays the result of the user's input.
Lean, on the other hand, integrates these features into the interaction with the editor, providing commands that cause the text editor to display feedback integrated into the program text itself.
This chapter provides a short introduction to interacting with Lean in an editor, while <a href="">Hello, World!</a> describes how to use Lean traditionally from the command line in batch mode.</p>
<p>It is best if you read this book with Lean open in your editor,
following along and typing in each example. Please play with the
examples, and see what happens!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="evaluating-expressions"><a class="header" href="#evaluating-expressions">Evaluating Expressions</a></h1>
<p>The most important thing to understand as a programmer learning Lean
is how evaluation works. Evaluation is the process of finding the
value of an expression, just as one does in arithmetic. For instance,
the value of 15 - 6 is 9 and the value of 2 × (3 + 1) is 8.
To find the value of the latter expression, 3 + 1 is first replaced by 4, yielding 2 × 4, which itself can be reduced to 8.
Sometimes, mathematical expressions contain variables: the value of <em>x</em> + 1 cannot be computed until we know what the value of <em>x</em> is.
In Lean, programs are first and foremost expressions, and the primary way to think about computation is as evaluating expressions to find their values.</p>
<p>Most programming languages are <em>imperative</em>, where a program consists
of a series of statements that should be carried out in order to find
the program's result. Programs have access to mutable memory, so the
value referred to by a variable can change over time. In addition to mutable state, programs may have other side
effects, such as deleting files, making outgoing network connections,
throwing or catching exceptions, and reading data from a
database. &quot;Side effects&quot; is essentially a catch-all term for
describing things that may happen in a program that don't follow the
model of evaluating mathematical expressions.</p>
<p>In Lean, however, programs work the same way as mathematical
expressions. Once given a value, variables cannot be reassigned. Evaluating an expression cannot have side effects. If two
expressions have the same value, then replacing one with the other
will not cause the program to compute a different result. This does
not mean that Lean cannot be used to write <code>Hello, world!</code> to the
console, but performing I/O is not a core part of the experience of
using Lean in the same way. Thus, this chapter focuses on how to
evaluate expressions interactively with Lean, while the next chapter
describes how to write, compile, and run the <code>Hello, world!</code> program.</p>
<p>To ask Lean to evaluate an expression, write <code>#eval</code> before it in your
editor, which will then report the result back. Typically, the result
is found by putting the cursor or mouse pointer over <code>#eval</code>. For
instance,</p>
<pre><code class="language-lean">#eval 1 + 2
</code></pre>
<p>yields the value <code>3</code>.</p>
<p>Lean obeys the ordinary rules of precedence and associativity for
arithmetic operators. That is,</p>
<pre><code class="language-lean">#eval 1 + 2 * 5
</code></pre>
<p>yields the value <code>11</code> rather than
<code>15</code>.</p>
<p>While both ordinary mathematical notation and the majority of
programming languages use parentheses (e.g. <code>f(x)</code>) to apply a function to its
arguments, Lean simply writes the function next to its
arguments (e.g. <code>f x</code>). Function application is one of the most common operations,
so it pays to keep it concise. Rather than writing</p>
<pre><code class="language-lean">#eval String.append(&quot;Hello, &quot;, &quot;Lean!&quot;)
</code></pre>
<p>to compute <code>&quot;Hello, Lean!&quot;</code>,
one would instead write</p>
<pre><code class="language-Lean">#eval String.append &quot;Hello, &quot; &quot;Lean!&quot;
</code></pre>
<p>where the function's two arguments are simply written next to
it with spaces.</p>
<p>Just as the order-of-operations rules for arithmetic demand
parentheses in the expression <code>(1 + 2) * 5</code>, parentheses are also
necessary when a function's argument is to be computed via another
function call. For instance, parentheses are required in</p>
<pre><code class="language-Lean">#eval String.append &quot;great &quot; (String.append &quot;oak &quot; &quot;tree&quot;)
</code></pre>
<p>because otherwise the second <code>String.append</code> would be interpreted as
an argument to the first, rather than as a function being passed
<code>&quot;oak &quot;</code> and <code>&quot;tree&quot;</code> as arguments. The value of the inner <code>String.append</code>
call must be found first, after which it can be appended to <code>&quot;great &quot;</code>,
yielding the final value <code>&quot;great oak tree&quot;</code>.</p>
<p>Imperative languages often have two kinds of conditional: a
conditional <em>statement</em> that determines which instructions to carry
out based on a Boolean value, and a conditional <em>expression</em> that
determines which of two expressions to evaluate based on a Boolean
value. For instance, in C and C++, the conditional statement is
written using <code>if</code> and <code>else</code>, while the conditional expression is
written with a ternary operator <code>?</code> and <code>:</code>. In Python, the
conditional statement begins with <code>if</code>, while the conditional
expression puts <code>if</code> in the middle.
Because Lean is an expression-oriented functional language, there are no conditional statements, only conditional expressions.
They are written using <code>if</code>, <code>then</code>, and <code>else</code>. For
instance,</p>
<pre><code class="language-Lean">String.append &quot;it is &quot; (if 1 &gt; 2 then &quot;yes&quot; else &quot;no&quot;)
</code></pre>
<p>evaluates to</p>
<pre><code class="language-Lean">String.append &quot;it is &quot; (if false then &quot;yes&quot; else &quot;no&quot;)
</code></pre>
<p>which evaluates to</p>
<pre><code class="language-lean">String.append &quot;it is &quot; &quot;no&quot;
</code></pre>
<p>which finally evaluates to <code>&quot;it is no&quot;</code>.</p>
<p>For the sake of brevity, a series of evaluation steps like this will sometimes be written with arrows between them:</p>
<pre><code class="language-lean">String.append &quot;it is &quot; (if 1 &gt; 2 then &quot;yes&quot; else &quot;no&quot;)
===&gt;
String.append &quot;it is &quot; (if false then &quot;yes&quot; else &quot;no&quot;)
===&gt;
String.append &quot;it is &quot; &quot;no&quot;
===&gt;
&quot;it is no&quot;
</code></pre>
<h2 id="messages-you-may-meet"><a class="header" href="#messages-you-may-meet">Messages You May Meet</a></h2>
<p>Asking Lean to evaluate a function application that is missing an argument will lead to an error message.
In particular, the example</p>
<pre><code class="language-lean">#eval String.append &quot;it is &quot;
</code></pre>
<p>yields a quite long error message:</p>
<pre><code class="language-output error">expression
  String.append &quot;it is &quot;
has type
  String → String
but instance
  Lean.MetaEval (String → String)
failed to be synthesized, this instance instructs Lean on how to display the resulting value, recall that any type implementing the `Repr` class also implements the `Lean.MetaEval` class
</code></pre>
<p>This message occurs because Lean functions that are applied to only some of their arguments return new functions that are waiting for the rest of the arguments.
Lean cannot display functions to users, and thus returns an error when asked to do so.</p>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<p>What are the values of the following expressions? Work them out by hand,
then enter them into Lean to check your work.</p>
<ul>
<li><code>42 + 19</code></li>
<li><code>String.append &quot;A&quot; (String.append &quot;B&quot; &quot;C&quot;)</code></li>
<li><code>String.append (String.append &quot;A&quot; &quot;B&quot;) &quot;C&quot;</code></li>
<li><code>if 3 == 3 then 5 else 7</code></li>
<li><code>if 3 == 4 then &quot;equal&quot; else &quot;not equal&quot;</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>Types classify programs based on the values that they can
compute. Types serve a number of roles in a program:</p>
<ol>
<li>
<p>They allow the compiler to make decisions about the in-memory
representation of a value.</p>
</li>
<li>
<p>They help programmers to communicate their intent to others,
serving as a lightweight specification for the inputs and outputs
of a function that the compiler can ensure the program adheres to.</p>
</li>
<li>
<p>They prevent various potential mistakes, such as adding a number
to a string, and thus reduce the number of tests that are
necessary for a program.</p>
</li>
<li>
<p>They help the Lean compiler automate the production of auxiliary code that can save boilerplate.</p>
</li>
</ol>
<p>Lean's type system is unusually expressive.
Types can encode strong specifications like &quot;this sorting function returns a permutation of its input&quot; and flexible specifications like &quot;this function has different return types, depending on the value of its argument&quot;.
The type system can even be used as a full-blown logic for proving mathematical theorems.
This cutting-edge expressive power doesn't obviate the need for simpler types, however, and understanding these simpler types is a prerequisite for using the more advanced features.</p>
<p>Every program in Lean must have a type. In particular, every
expression must have a type before it can be evaluated. In the
examples so far, Lean has been able to discover a type on its own, but
it is sometimes necessary to provide one. This is done using the colon
operator:</p>
<pre><code class="language-lean">#eval (1 + 2 : Nat)
</code></pre>
<p>Here, <code>Nat</code> is the type of <em>natural numbers</em>, which are arbitrary-precision unsigned integers.
In Lean, <code>Nat</code> is the default type for non-negative integer literals.
This default type is not always the best choice.
In C, unsigned integers underflow to the largest representable numbers when subtraction would otherwise yield a result less than zero.
<code>Nat</code>, however, can represent arbitrarily-large unsigned numbers, so there is no largest number to underflow to.
Thus, subtraction on <code>Nat</code> returns <code>0</code> when the answer would have otherwise been negative.
For instance,</p>
<pre><code class="language-lean">#eval 1 - 2
</code></pre>
<p>evaluates to <code>0</code> rather
than <code>-1</code>. To use a type that can represent the negative integers,
provide a it directly:</p>
<pre><code class="language-lean">#eval (1 - 2 : Int)
</code></pre>
<p>With this type, the result is <code>-1</code>, as expected.</p>
<p>To check the type of an expression without evaluating it, use <code>#check</code>
instead of <code>#eval</code>. For instance:</p>
<pre><code class="language-lean">#check (1 - 2 : Int)
</code></pre>
<p>reports <code>1 - 2 : Int</code> without actually performing the subtraction.</p>
<p>When a program can't be given a type, an error is returned from both
<code>#check</code> and <code>#eval</code>. For instance:</p>
<pre><code class="language-lean">#check String.append &quot;hello&quot; [&quot; &quot;, &quot;world&quot;]
</code></pre>
<p>outputs</p>
<pre><code class="language-output error">application type mismatch
  String.append &quot;hello&quot; [&quot; &quot;, &quot;world&quot;]
argument
  [&quot; &quot;, &quot;world&quot;]
has type
  List String : Type
but is expected to have type
  String : Type
</code></pre>
<p>because the second argument to <code>String.append</code> is expected to be a
string, but a list of strings was provided instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-and-definitions"><a class="header" href="#functions-and-definitions">Functions and Definitions</a></h1>
<p>In Lean, definitions are introduced using the <code>def</code> keyword. For instance, to define the name <code>hello</code> to refer to the string <code>&quot;Hello&quot;</code>, write:</p>
<pre><code class="language-lean">def hello := &quot;Hello&quot;
</code></pre>
<p>In Lean, new names are defined using the colon-equal operator<code>:=</code>
rather than <code>=</code>. This is because <code>=</code> is used to describe equalities
between existing expressions, and using two different operators helps
prevent confusion.</p>
<p>In the definition of <code>hello</code>, the expression <code>&quot;Hello&quot;</code> is simple enough that Lean is able to determine the definition's type automatically.
However, most definitions are not so simple, so it will usually be necessary to add a type.
This is done using a colon after the name being defined.</p>
<pre><code class="language-lean">def lean : String := &quot;Lean&quot;
</code></pre>
<p>Now that the names have been defined, they can be used, so</p>
<pre><code class="language-Lean">#eval String.append hello (String.append &quot; &quot; lean)
</code></pre>
<p>outputs</p>
<pre><code class="language-Lean info">&quot;Hello Lean&quot;
</code></pre>
<p>In Lean, defined names may only be used after their definitions.</p>
<p>In many languages, definitions of functions use a different syntax than definitions of other values.
For instance, Python function definitions begin with the <code>def</code> keyword, while other definitions are defined with an equals sign.
In Lean, functions are defined using the same <code>def</code> keyword as other values.
Nonetheless, definitions such as <code>hello</code> introduce names that refer <em>directly</em> to their values, rather than to zero-argument functions that return equivalent results each time they are called.</p>
<h2 id="defining-functions"><a class="header" href="#defining-functions">Defining Functions</a></h2>
<p>There are a variety of ways to define functions in Lean. The simplest is to place the function's arguments before the definition's type, separated by spaces. For instance, a function that adds one to its argument can be written:</p>
<pre><code class="language-lean">def add1 (n : Nat) : Nat := n + 1
</code></pre>
<p>Testing this function with <code>#eval</code> gives <code>8</code>, as expected:</p>
<pre><code class="language-lean">#eval add1 7
</code></pre>
<p>Just as functions are applied to multiple arguments just by writing spaces between each argument, functions that accept multiple arguments are defined with spaces between the arguments' names and types. The function <code>maximum</code>, whose result is equal to the greatest of its two arguments, takes two <code>Nat</code> arguments <code>n</code> and <code>k</code> and returns a <code>Nat</code>.</p>
<pre><code class="language-lean">def maximum (n : Nat) (k : Nat) : Nat :=
  if n &lt; k then
    k
  else n
</code></pre>
<p>When a defined function like <code>maximum</code> has been provided with its arguments, the result is determined by first replacing the argument names with the provided values in the body, and then evaluating the resulting body. For example:</p>
<pre><code class="language-lean">maximum (5 + 8) (2 * 7)
===&gt;
maximum 13 14
===&gt;
if 13 &lt; 14 then 14 else 13
===&gt;
14
</code></pre>
<p>Expressions that evaluate to natural numbers, integers, and strings have types that say this (<code>Nat</code>, <code>Int</code>, and <code>String</code>, respectively). This is also true of functions. A function that accepts a <code>Nat</code> and returns a <code>Bool</code> has type <code>Nat → Bool</code>, and a function that accepts two <code>Nat</code>s and returns a <code>Nat</code> has type <code>Nat → Nat → Nat</code>.
Entering <code>#check add1</code> yields <code>add1 : Nat → Nat</code> and <code>#check maximum</code> yields <code>maximum : Nat → Nat → Nat</code>.
This arrow can also be written with an ASCII alternative arrow <code>-&gt;</code>, so the preceding function types can be written <code>Nat -&gt; Bool</code> and <code>Nat -&gt; Nat -&gt; Nat</code>, respectively.</p>
<p>Behind the scenes, all functions actually expect precisely one argument.
Functions like <code>maximum</code> that seem to take more than one argument are in fact functions that take one argument and then return a new function.
This new function takes the next argument, and the process continues until no more arguments are expected.
This can be seen by providing one argument to a multiple-argument function: <code>#check maximum 3</code> yields <code>maximum 3 : Nat → Nat</code> and <code>#check String.append &quot;Hello &quot;</code> yields <code>String.append &quot;Hello &quot; : String → String</code>.
Using a function that returns a function to implement multiple-argument functions is called <em>currying</em> after the mathematician Haskell Curry.
Function arrows associate to the right, which means that <code>Nat → Nat → Nat</code> should be parenthesized <code>Nat → (Nat → Nat)</code>.</p>
<h3 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h3>
<ul>
<li>Define the function <code>joinStringsWith</code> with type <code>String -&gt; String -&gt; String -&gt; String</code> that creates a new string by placing its first argument between its second and third arguments. <code>joinStringsWith &quot;, &quot; &quot;one&quot; &quot;and another&quot;</code> should evaluate to <code>&quot;one, and another&quot;</code>.</li>
<li>What is the type of <code>joinStringsWith &quot;: &quot;</code>? Check your answer with Lean.</li>
<li>Define a function <code>volume</code> with type <code>Nat → Nat → Nat → Nat</code> that computes the volume of a rectangular prism with the given height, width, and depth.</li>
</ul>
<h2 id="defining-types"><a class="header" href="#defining-types">Defining Types</a></h2>
<p>Most typed programming languages have some means of defining aliases for types, such as C's <code>typedef</code>.
In Lean, however, types are a first-class part of the language - they are expressions like any other.
This means that definitions can refer to types just as well as they can refer to other values.</p>
<p>For instance, if <code>String</code> is too much to type, a shorter abbreviation <code>Str</code> can be defined:</p>
<pre><code class="language-lean">def Str : Type := String
</code></pre>
<p>It is then possible to use <code>Str</code> as a definition's type instead of <code>String</code>:</p>
<pre><code class="language-lean">def aStr : Str := &quot;This is a string.&quot;
</code></pre>
<p>The reason this works is that types follow the same rules as the rest of Lean.
Types are expressions, and in an expression, a defined name can be replaced with its definition.
Because <code>Str</code> has been defined to mean <code>String</code>, the definition of <code>aStr</code> makes sense.</p>
<h3 id="messages-you-may-meet-1"><a class="header" href="#messages-you-may-meet-1">Messages You May Meet</a></h3>
<p>Experimenting with using definitions for types is made more complicated by a feature of Lean that has not yet been introduced.
If <code>Nat</code> is too short, a longer name <code>NaturalNumber</code> can be defined:</p>
<pre><code class="language-lean">def NaturalNumber : Type := Nat
</code></pre>
<p>However, using <code>NaturalNumber</code> as a definition's type instead of <code>Nat</code> does not have the expected effect.
In particular, the definition:</p>
<pre><code class="language-lean">def thirtyEight : NaturalNumber := 38
</code></pre>
<p>results in the following error:</p>
<pre><code class="language-output error">failed to synthesize instance
  OfNat NaturalNumber 38
</code></pre>
<p>This error occurs because Lean allows number literals to be <em>overloaded</em>.
When it makes sense to do so, natural number literals can be used for new types, just as if those types were built in to the system.
This is part of Lean's mission of making it convenient to represent mathematics, and different branches of mathematics use number notation for very different purposes.
The specific feature that allows this overloading does not replace all defined names with their definitions before looking for overloading, which is what leads to the error message above.</p>
<p>One way to work around this limitation is by providing the type <code>Nat</code> on the right-hand side of the definition, causing <code>Nat</code>'s overloading rules to be used for <code>38</code>:</p>
<pre><code class="language-lean">def thirtyEight : NaturalNumber := (38 : Nat)
</code></pre>
<p>The definition is still type-correct because <code>NaturalNumber</code> is the same type as <code>Nat</code>—by definition!</p>
<p>Another solution is to define an overloading for <code>NaturalNumber</code> that works equivalently to the one for <code>Nat</code>.
This requires more advanced features of Lean, however.</p>
<p>Finally, defining the new name for <code>Nat</code> using <code>abbrev</code> instead of <code>def</code> allows overloading resolution to replace the defined name with its definition.
Definitions written using <code>abbrev</code> are always unfolded.
For instance,</p>
<pre><code class="language-lean">abbrev N : Type := Nat
</code></pre>
<p>and</p>
<pre><code class="language-lean">def thirtyNine : N := 39
</code></pre>
<p>are accepted without issue.</p>
<p>Behind the scenes, some definitions are internally marked as being unfoldable during during overload resolution, while others are not.
Definitions that are to be unfolded are called <em>reducible</em>.
Control over reducibility is essential to allow Lean to scale: fully unfolding all definitions can result in very large types that are slow for a machine to process and difficult for users to understand.
Definitions produced with <code>abbrev</code> are marked as reducible.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structures"><a class="header" href="#structures">Structures</a></h1>
<p>The first step in writing a program is usually to identify the problem domain's concepts, and then find suitable representations for them in code.
Sometimes, a domain concept is a collection of other, simpler, concepts.
In that case, it can be convenient to group these simpler components together into a single &quot;package&quot;, which can then be given a meaningful name.
In Lean, this is done using <em>structures</em>, which are analogous to <code>struct</code>s in C or Rust and <code>record</code>s in C#.</p>
<p>Defining a structure introduces a completely new type to Lean that can't be reduced to any other type.
This is useful because multiple structures might represent different concepts that nonetheless contain the same data.
For instance, a point might be represented using either Cartesian or polar coordinates, each being a pair of floating-point numbers.
Defining separate structures prevents API clients from confusing one for another.</p>
<p>Lean's floating-point number type is called <code>Float</code>, and floating-point numbers are written in the usual notation.</p>
<pre><code class="language-lean">#check 1.2
</code></pre>
<pre><code class="language-output info">1.2 : Float
</code></pre>
<pre><code class="language-lean">#check -454.2123215
</code></pre>
<pre><code class="language-output info">-454.2123215 : Float
</code></pre>
<pre><code class="language-lean">#check 0.0
</code></pre>
<pre><code class="language-output info">0.0 : Float
</code></pre>
<p>When floating point numbers are written with the decimal point, Lean will infer the type <code>Float</code>. If they are written without it, then a type annotation may be necessary.</p>
<pre><code class="language-lean">#check 0
</code></pre>
<pre><code class="language-output info">0 : Nat
</code></pre>
<pre><code class="language-lean">#check (0 : Float)
</code></pre>
<pre><code class="language-output info">0 : Float
</code></pre>
<p>A Cartesian point is a structure with two <code>Float</code> fields, called <code>x</code> and <code>y</code>.
This is declared using the <code>structure</code> keyword.</p>
<pre><code class="language-lean">structure Point where
  x : Float
  y : Float
deriving Repr
</code></pre>
<p>After this declaration, <code>Point</code> is a new structure type.
The final line, which says <code>deriving Repr</code>, asks Lean to generate code to display values of type <code>Point</code>.
This code is used by <code>#eval</code> to render the result of evaluation for consumption by programmers, analogous to the <code>repr</code> functions in Python and Rust.
It is also possible to override the compiler's generated display code.</p>
<p>The typical way to create a instance of a structure type is to provide values for all of its fields inside of curly braces.
The origin of a Cartesian plane is where both <code>x</code> and <code>y</code> are both zero:</p>
<pre><code class="language-lean">def origin : Point := { x := 0.0, y := 0.0 }
</code></pre>
<p>If the <code>deriving Repr</code> line in <code>Point</code>'s definition were omitted, then attempting <code>#eval origin</code> would yield an error similar to that which occurs when omitting a function's argument:</p>
<pre><code class="language-output error">expression
  origin
has type
  Point
but instance
  Lean.MetaEval Point
failed to be synthesized, this instance instructs Lean on how to display the resulting value, recall that any type implementing the `Repr` class also implements the `Lean.MetaEval` class
</code></pre>
<p>That message is saying that the evaluation machinery doesn't know how to communicate the result of evaluation back to the user.</p>
<p>Happily, with <code>deriving Repr</code>, the result of <code>#eval origin</code> looks very much like the definition of <code>origin</code>.</p>
<pre><code class="language-output info">{ x := 0.000000, y := 0.000000 }
</code></pre>
<p>Because structures exist to &quot;bundle up&quot; a collection of data, naming it and treating it as a single unit, it is also important to be able to extract the individual fields of a structure.
This is done using dot notation, as in C, Python, or Rust.</p>
<pre><code class="language-lean">#eval origin.x
</code></pre>
<pre><code class="language-output info">0.000000
</code></pre>
<pre><code class="language-lean">#eval origin.y
</code></pre>
<pre><code class="language-output info">0.000000
</code></pre>
<p>This can be used to define functions that take structures as arguments.
For instance, addition of points is performed by adding the underlying coordinate values.
It should be the case that <code>#eval addPoints { x := 1.5, y := 32 } { x := -8, y := 0.2 }</code> yields</p>
<pre><code class="language-output info">{ x := -6.500000, y := 32.200000 }
</code></pre>
<p>The function itself takes two <code>Points</code> as arguments, called <code>p1</code> and <code>p2</code>.
The resulting point is based on the <code>x</code> and <code>y</code> fields of both <code>p1</code> and <code>p2</code>:</p>
<pre><code class="language-lean">def addPoints (p1 : Point) (p2 : Point) : Point :=
  { x := p1.x + p2.x, y := p1.y + p2.y }
</code></pre>
<p>Similarly, the distance between two points, which is the square root of the sum of the squares of the differences in their <code>x</code> and <code>y</code> components, can be written:</p>
<pre><code class="language-lean">def distance (p1 : Point) (p2 : Point) : Float :=
  Float.sqrt (((p2.x - p1.x) ^ 2.0) + ((p2.y - p1.y) ^ 2.0))
</code></pre>
<p>For example, the distance between (1, 2) and (5, -1) is 5:</p>
<pre><code class="language-lean">#eval distance { x := 1.0, y := 2.0 } { x := 5.0, y := -1.0 }
</code></pre>
<pre><code class="language-output info">5.000000
</code></pre>
<p>Multiple structures may have fields with the same names.
For instance, a three-dimensional point datatype may share the fields <code>x</code> and <code>y</code>, and be instantiated with the same field names:</p>
<pre><code class="language-lean">structure Point3D where
  x : Float
  y : Float
  z : Float
deriving Repr

def origin3D : Point3D := { x := 0.0, y := 0.0, z := 0.0 }
</code></pre>
<p>This means that the structure's expected type must be known in order to use the curly-brace syntax.
If the type is not known, Lean will not be able to instantiate the structure.
For instance,</p>
<pre><code class="language-lean">#check { x := 0.0, y := 0.0 }
</code></pre>
<p>leads to the error</p>
<pre><code class="language-output error">invalid {...} notation, expected type is not known
</code></pre>
<p>As usual, the situation can be remedied by providing a type annotation.</p>
<pre><code class="language-lean">#check ({ x := 0.0, y := 0.0 } : Point)
</code></pre>
<pre><code class="language-output info">{ x := 0.0, y := 0.0 } : Point
</code></pre>
<p>To make programs more concise, Lean also allows the structure type annotation inside the curly braces.</p>
<pre><code class="language-lean">#check { x := 0.0, y := 0.0 : Point}
</code></pre>
<pre><code class="language-output info">{ x := 0.0, y := 0.0 } : Point
</code></pre>
<h2 id="updating-structures"><a class="header" href="#updating-structures">Updating Structures</a></h2>
<p>Imagine a function <code>zeroX</code> that replaces the <code>x</code> field of a <code>Point</code> with <code>0.0</code>.
In most programming language communities, this sentence would mean that the memory location pointed to by <code>x</code> was to be overwritten with a new value.
However, Lean does not have mutable state.
In functional programming communities, what is almost always meant by this kind of statement is that a fresh <code>Point</code> is allocated with the <code>x</code> field pointing to the new value, and all other fields pointing to the original values from the input.
One way to write <code>zeroX</code> is to follow this description literally, filling out the new value for <code>x</code> and manually transferring <code>y</code>:</p>
<pre><code class="language-lean">def zeroX (p : Point) : Point :=
  { x := 0, y := p.y }
</code></pre>
<p>This style of programming has drawbacks, however.
First off, if a new field is added to a structure, then every site that updates any field at all must be updated, causing maintenance difficulties.
Secondly, if the structure contains multiple fields with the same type, then there is a real risk of copy-paste coding leading to field contents being duplicated or switched.
Finally, the program becomes long and bureaucratic.</p>
<p>Lean provides a convenient syntax for replacing some fields in a structure while leaving the others alone.
This is done by using the <code>with</code> keyword in a structure initialization.
The source of unchanged fields occurs before the <code>with</code>, and the new fields occur after.
For instance, <code>zeroX</code> can be written with only the new <code>x</code> value:</p>
<pre><code class="language-lean">def zeroX (p : Point) : Point :=
  { p with x := 0 }
</code></pre>
<p>Remember that this structure update syntax does not modify existing values—it creates new values that share some fields with old values.
For instance, given the point <code>fourAndThree</code>:</p>
<pre><code class="language-lean">def fourAndThree : Point :=
  { x := 4.3, y := 3.4 }
</code></pre>
<p>evaluating it, then evaluating an update of it using <code>zeroX</code>, then evaluating it again yields the original value:</p>
<pre><code class="language-lean">#eval fourAndThree
</code></pre>
<pre><code class="language-output info">{ x := 4.300000, y := 3.400000 }
</code></pre>
<pre><code class="language-lean">#eval zeroX fourAndThree
</code></pre>
<pre><code class="language-output info">{ x := 0.000000, y := 3.400000 }
</code></pre>
<pre><code class="language-lean">#eval fourAndThree
</code></pre>
<pre><code class="language-output info">{ x := 4.300000, y := 3.400000 }
</code></pre>
<p>One consequence of the fact that structure updates do not modify the original structure is that it becomes easier to reason about cases where the new value is computed from the old one.
All references to the old structure continue to refer to the same field values in all of the new values provided.</p>
<h2 id="behind-the-scenes"><a class="header" href="#behind-the-scenes">Behind the Scenes</a></h2>
<p>Every structure has a <em>constructor</em>.
Here, the term &quot;constructor&quot; may be a source of confusion.
Unlike constructors in languages such as Java or Python, constructors in Lean are not arbitrary code to be run when a datatype is initialized.
Instead, constructors simply gather the data to be stored in the newly-allocated data structure.
It is not possible to provide a custom constructor that pre-processes data or rejects invalid arguments.
This is really a case of the word &quot;constructor&quot; having different, but related, meanings in the two contexts.</p>
<p>By default, the constructor for a structure named <code>S</code> is named <code>S.mk</code>.
Here, <code>S</code> is a namespace qualifier, and <code>mk</code> is the name of the constructor itself.
Instead of using curly-brace initialization syntax, the constructor can also be applied directly.</p>
<pre><code class="language-lean">#check Point.mk 1.5 2.8
</code></pre>
<p>However, this is not generally considered to be good Lean style, and Lean even returns its feedback using the standard structure initializer syntax.</p>
<pre><code class="language-output info">{ x := 1.5, y := 2.8 } : Point
</code></pre>
<p>Constructors have function types, which means that they can be used anywhere that a function is expected.
For instance, <code>Point.mk</code> is a function that accepts two <code>Float</code>s (respectively <code>x</code> and <code>y</code>) and returns a new <code>Point</code>.</p>
<pre><code class="language-lean">#check Point.mk
</code></pre>
<pre><code class="language-output info">Point.mk : Float → Float → Point
</code></pre>
<p>To override a structure's constructor name, write it with two colons at the beginning.
For instance, to use <code>Point.point</code> instead of <code>Point.mk</code>, write:</p>
<pre><code class="language-lean">structure Point where
  point ::
  x : Float
  y : Float
deriving Repr
</code></pre>
<p>In addition to the constructor, an accessor function is defined for each field of a structure.
These have the same name as the field, in the structure's namespace.
For <code>Point</code>, accessor functions <code>Point.x</code> and <code>Point.y</code> are generated.</p>
<pre><code class="language-lean">#check Point.x
</code></pre>
<pre><code class="language-output info">Point.x : Point → Float
</code></pre>
<pre><code class="language-lean">#check Point.y
</code></pre>
<pre><code class="language-output info">Point.y : Point → Float
</code></pre>
<p>In fact, just as the curly-braced structure construction syntax is converted to a call to the structure's constructor behind the scenes, the syntax <code>p1.x</code> in the prior definition of <code>addPoints</code> is converted into a call to the <code>Point.x</code> accessor.
That is, <code>#eval origin.x</code> and <code>#eval Point.x origin</code> both yield</p>
<pre><code class="language-output info">0.000000
</code></pre>
<p>Accessor dot notation is usable with more than just structure fields.
It can also be used for functions that take any number of arguments.
More generally, accessor notation has the form <code>TARGET.f ARG1 ARG2 ...</code>.
If <code>TARGET</code> has type <code>T</code>, the function named <code>T.f</code> is called.
<code>TARGET</code> becomes its leftmost argument of type <code>T</code>, which is often but not always the first one, and <code>ARG1 ARG2 ...</code> are provided in order as the remaining arguments.
For instance, <code>String.append</code> can be invoked from a string with accessor notation, even though <code>String</code> is not a structure with an <code>append</code> field.</p>
<pre><code class="language-lean">#eval &quot;one string&quot;.append &quot; and another&quot;
</code></pre>
<pre><code class="language-output info">&quot;one string and another&quot;
</code></pre>
<p>In that example, <code>TARGET</code> represents <code>&quot;one string&quot;</code> and <code>ARG1</code> represents <code>&quot; and another&quot;</code>.</p>
<p>The function <code>Point.modifyBoth</code> (that is, <code>modifyBoth</code> defined in the <code>Point</code> namespace) applies a function to both fields in a <code>Point</code>:</p>
<pre><code class="language-lean">def Point.modifyBoth (f : Float → Float) (p : Point) : Point :=
  { x:= f p.x, y := f p.y }
</code></pre>
<p>Even though the <code>Point</code> argument comes after the function argument, it can be used with dot notation as well:</p>
<pre><code class="language-lean">#eval fourAndThree.modifyBoth Float.floor
</code></pre>
<pre><code class="language-output info">{ x := 4.000000, y := 3.000000 }
</code></pre>
<p>In this case, <code>TARGET</code> represents <code>fourAndThree</code>, while <code>ARG1</code> is <code>Float.floor</code>.
This is because the target of the accessor notation is used as the first argument in which the type matches, not necessarily the first argument.</p>
<h2 id="exercises-2"><a class="header" href="#exercises-2">Exercises</a></h2>
<ul>
<li>Define a structure named <code>RectangularPrism</code> that contains the height, width, and depth of a rectangular prism, each as a <code>Float</code>.</li>
<li>Define a function named <code>volume : RectangularPrism → Float</code> that computes the volume of a rectangular prism.</li>
<li>Define a structure named <code>Segment</code> that represents a line segment by its endpoints, and define a function <code>length : Segment → Float</code> that computes the length of a line segment. <code>Segment</code> should have at most two fields.</li>
<li>Which names are introduced by the declaration of <code>RectangularPrism</code>?</li>
<li>Which names are introduced by the following declarations of <code>Hamster</code> and <code>Book</code>? What are their types?</li>
</ul>
<pre><code class="language-lean">structure Hamster where
  name : String
  fluffy : Bool
</code></pre>
<pre><code class="language-lean">structure Book where
  makeBook ::
  title : String
  author : String
  price : Float
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="datatypes-and-patterns"><a class="header" href="#datatypes-and-patterns">Datatypes and Patterns</a></h1>
<p>Structures enable multiple independent pieces of data to be combined into a coherent whole that is represented by a brand new type.
Types such as structures that group together a collection of values are called <em>product types</em>.
Many domain concepts, however, can't be naturally represented as structures.
For instance, an application might need to track user permissions, where some users are document owners, some may edit documents, and others may only read them.
A calculator has a number of binary operators, such as addition, subtraction, and multiplication.
Structures do not provide an easy way to encode multiple choices.</p>
<p>Similarly, while a structure is an excellent way to keep track of a fixed set of fields, many applications require data that may contain an arbitrary number of elements.
Most classic data structures, such as trees and lists, have a recursive structure, where the tail of a list is itself a list, or where the left and right branches of a binary tree are themselves binary trees.
In the aforementioned calculator, the structure of expressions themselves is recursive.
The summands in an addition expression may themselves be multiplication expressions, for instance.</p>
<p>Datatypes that allow choices are called <em>sum types</em> and datatypes that can include instances of themselves are called <em>recursive datatypes</em>.
Recursive sum types are called <em>inductive datatypes</em>, because mathematical induction may be used to prove statements about them.
Most user-defined types are inductive datatypes.
When programming, inductive datatypes are consumed through pattern matching and recursive functions.</p>
<p>Many of the built-in types are actually inductive datatypes in the standard library.
For instance, <code>Bool</code> is an inductive datatype:</p>
<pre><code class="language-lean">inductive Bool where
  | false : Bool
  | true : Bool
</code></pre>
<p>This definition has two main parts.
The first line provides the name of the new type (<code>Bool</code>), while the remaining lines each describe a constructor.
As with constructors of structures, constructors of inductive datatypes are mere inert receivers of and containers for other data, rather than places to insert arbitrary initialization and validation code.
Unlike structures, inductive datatypes may have multiple constructors.
Here, there are two constructors, <code>true</code> and <code>false</code>, and neither takes any arguments.
Just as a structure declaration places its names in a namespace named after the declared type, an inductive datatype places the names of its constructors in a namespace.
In the Lean standard library, <code>true</code> and <code>false</code> are re-exported from this namespace so that they can be written alone, rather than as <code>Bool.true</code> and <code>Bool.false</code>, respectively.</p>
<p>From a data modeling perspective, inductive datatypes are used in many of the same contexts where a sealed abstract class might be used in other languages.
In languages like C# or Java, one might write a similar definition of definition of <code>Bool</code>:</p>
<pre><code class="language-C#">abstract class Bool {}
class True : Bool {}
class False : Bool {}
</code></pre>
<p>However, the specifics of these representations are fairly different. In particular, each non-abstract class creates both a new type and new ways of allocating data. In the object-oriented example, <code>True</code> and <code>False</code> are both types that are more specific than <code>Bool</code>, while the Lean definition introduces only the new type <code>Bool</code>.</p>
<p>The type <code>Nat</code> of non-negative integers is an inductive datatype:</p>
<pre><code class="language-lean">inductive Nat where
  | zero : Nat
  | succ (n : Nat) : Nat
</code></pre>
<p>Here, <code>zero</code> represents 0, while <code>succ</code> represents the successor of some other number.
The <code>Nat</code> mentioned in <code>succ</code>'s declaration is the very type <code>Nat</code> that is in the process of being defined.
<em>Successor</em> means &quot;one greater than&quot;, so the successor of five is six and the successor of 32,185 is 32,186.
Using this definition, <code>4</code> is represented as <code>Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero)))</code>.
This definition is almost like the definition of <code>Bool</code> with slightly different names.
The only real difference is that <code>succ</code> is followed by <code>(n : Nat)</code>, which specifies that the constructor <code>succ</code> takes an argument of type <code>Nat</code> which happens to be named <code>n</code>.
The names <code>zero</code> and <code>succ</code> are in a namespace named after their type, so they must be referred to as <code>Nat.zero</code> and <code>Nat.succ</code>, respectively.</p>
<p>Argument names, such as <code>n</code>, may occur in Lean's error messages and in feedback provided when writing mathematical proofs.
Lean also has an optional syntax for providing arguments by name.
Generally, however, the choice of argument name is less important than the choice of a structure field name, as it does not form as large a part of the API.</p>
<p>In C# or Java, <code>Nat</code> could be defined as follows:</p>
<pre><code class="language-C#">abstract class Nat {}
class Zero : Nat {}
class Succ : Nat {
  public Nat n;
  public Succ(Nat pred) {
	n = pred;
  }
}
</code></pre>
<p>Just as in the <code>Bool</code> example above, this defines more types than the Lean equivalent.
Additionally, this example highlights how Lean datatype constructors are much more like subclasses of an abstract class than they are like constructors in C# or Java, as the constructor shown here contains initialization code to be executed.</p>
<h2 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h2>
<p>In many languages, these kinds of data are consumed by first using an instance-of operator to check which subclass has been received and then reading the values of the fields that are available in the given subclass.
The instance-of check determines which code to run, ensuring that the data needed by this code is available, while the fields themselves provide the data.
In Lean, both of these purposes are simultaneously served by <em>pattern matching</em>.</p>
<p>An example of a function that uses pattern matching is <code>isZero</code>, which is a function that returns <code>true</code> when its argument is <code>Nat.zero</code>, or false otherwise.</p>
<pre><code class="language-lean">def isZero (n : Nat) : Bool :=
  match n with
  | Nat.zero =&gt; true
  | Nat.succ k =&gt; false
</code></pre>
<p>The <code>match</code> expression is provided the function's argument <code>n</code> for destructuring.
If <code>n</code> was constructed by <code>Nat.zero</code>, then the first branch of the pattern match is taken, and the result is <code>true</code>.
If <code>n</code> was constructed by <code>Nat.succ</code>, then the second branch is taken, and the result is <code>false</code>.</p>
<p>Step-by-step, evaluation of <code>isZero Nat.zero</code> proceeds as follows:</p>
<pre><code class="language-lean">isZero Nat.zero
===&gt;
match Nat.zero with
| Nat.zero =&gt; true
| Nat.succ k =&gt; false
===&gt;
true
</code></pre>
<p>Evaluation of <code>isZero 5</code> proceeds similarly:</p>
<pre><code class="language-lean">isZero 5
===&gt;
isZero (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero)))))
===&gt;
match Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero)))) with
| Nat.zero =&gt; true
| Nat.succ k =&gt; false
===&gt;
false
</code></pre>
<p>The <code>k</code> in the second branch of the pattern in <code>isZero</code> is not decorative.
It makes the <code>Nat</code> that is the argument to <code>succ</code> visible, with the provided name.
That smaller number can then be used to compute the final result of the expression.</p>
<p>Just as the successor of some number <em>n</em> is one greater than <em>n</em> (that is, <em>n</em> + 1), the predecessor of a number is one less than it.
If <code>pred</code> is a function that finds the predecessor of a <code>Nat</code>, then it should be the case that the following examples find the expected result:</p>
<pre><code class="language-lean">#eval pred 5
</code></pre>
<pre><code class="language-output info">4
</code></pre>
<pre><code class="language-lean">#eval pred 839
</code></pre>
<pre><code class="language-output info">838
</code></pre>
<p>Because <code>Nat</code> cannot represent negative numbers, <code>0</code> is a bit of a conundrum.
Usually, when working with <code>Nat</code>, operators that would ordinarily produce a negative number are redefined to produce <code>0</code> itself:</p>
<pre><code class="language-lean">#eval pred 0
</code></pre>
<pre><code class="language-output info">0
</code></pre>
<p>To find the predecessor of a <code>Nat</code>, the first step is to check which constructor was used to create it.
If it was <code>Nat.zero</code>, then the result is <code>Nat.zero</code>.
If it was <code>Nat.succ</code>, then the name <code>k</code> is used to refer to the <code>Nat</code> underneath it.
And this <code>Nat</code> is the desired predecessor, so the result of the <code>Nat.succ</code> branch is <code>k</code>.</p>
<pre><code class="language-lean">def pred (n : Nat) : Nat :=
  match n with
  | Nat.zero =&gt; Nat.zero
  | Nat.succ k =&gt; k
</code></pre>
<p>Applying this function to <code>5</code> yields the following steps:</p>
<pre><code class="language-lean">pred 5
===&gt;
pred (Nat.succ 4)
===&gt;
match Nat.succ 4 with
| Nat.zero =&gt; Nat.zero
| Nat.succ k =&gt; k
===&gt;
4
</code></pre>
<p>Pattern matching can be used with structures as well as with sum types.
For instance, a function that extracts the third dimension from a <code>Point3D</code> can be written as follows:</p>
<pre><code class="language-lean">def depth (p : Point3D) : Float :=
  match p with
  | { x:= h, y := w, z := d } =&gt; d
</code></pre>
<p>In this case, it would have been much simpler to just use the <code>z</code> accessor, but structure patterns are occasionally the simplest way to write a function.</p>
<h2 id="recursive-functions"><a class="header" href="#recursive-functions">Recursive Functions</a></h2>
<p>Definitions that refer to the name being defined are called <em>recursive definitions</em>.
Inductive datatypes are allowed to be recursive; indeed, <code>Nat</code> is an example of such a datatype because <code>succ</code> demands another <code>Nat</code>.
Recursive datatypes can represent arbitrarily large data, limited only by technical factors like available memory.
Just as it would be impossible to write down one constructor for each natural number in the datatype definition, it is also impossible to write down a pattern match case for each possibility.</p>
<p>Recursive datatypes are nicely complemented by recursive functions.
A simple recursive function over <code>Nat</code> checks whether its argument is even.
In this case, <code>zero</code> is even.
Non-recursive branches of the code like this one are called <em>base cases</em>.
The successor of an odd number is even, and the successor of an even number is odd.
This means that a number built with <code>succ</code> is even if and only if its argument is not even.</p>
<pre><code class="language-lean">def even (n : Nat) : Bool :=
  match n with
  | Nat.zero =&gt; true
  | Nat.succ k =&gt; not (even k)
</code></pre>
<p>This pattern of thought is typical for writing recursive functions on <code>Nat</code>.
First, identify what to do for <code>zero</code>.
Then, determine how to transform a result for an arbitrary <code>Nat</code> into a result for its successor, and apply this transformation to the result of the recursive call.
This pattern is called <em>structural recursion</em>.</p>
<p>Unlike many languages, Lean ensures by default that every recursive function will eventually reach a base case.
From a programming perspective, this rules out accidental infinite loops.
But this feature is especially important when proving theorems, where infinite loops cause major difficulties.
A consequence of this is that Lean will not accept a version of <code>even</code> that attempts to invoke itself recursively on the original number:</p>
<pre><code class="language-lean">def evenLoops (n : Nat) : Bool :=
  match n with
  | Nat.zero =&gt; true
  | Nat.succ k =&gt; not (evenLoops n)
</code></pre>
<p>The important part of the error message is that Lean could not determine that the recursive function always reaches a base case (because it doesn't).</p>
<pre><code class="language-output error">fail to show termination for
  evenLoops
with errors
structural recursion cannot be used

well-founded recursion cannot be used, 'evenLoops' does not take any (non-fixed) arguments
</code></pre>
<p>Even though addition takes two arguments, only one of them needs to be inspected.
To add zero to a number <em>n</em>, just return <em>n</em>.
To add the successor of <em>k</em> to <em>n</em>, take the successor of the result of adding <em>k</em> to <em>n</em>.</p>
<pre><code class="language-lean">def plus (n : Nat) (k : Nat) : Nat :=
  match k with
  | Nat.zero =&gt; n
  | Nat.succ k' =&gt; Nat.succ (plus n k')
</code></pre>
<p>In the definition of <code>plus</code>, the name <code>k'</code> is chosen to indicate that it is connected to, but not identical with, the argument <code>k</code>.
For instance, walking through the evaluation of <code>plus 3 2</code> yields the following steps:</p>
<pre><code class="language-lean">plus 3 2
===&gt;
plus 3 (Nat.succ (Nat.succ Nat.zero))
===&gt;
match Nat.succ (Nat.succ Nat.zero) with
| Nat.zero =&gt; 3
| Nat.succ k' =&gt; Nat.succ (plus 3 k')
===&gt;
Nat.succ (plus 3 (Nat.succ Nat.zero))
===&gt;
Nat.succ (match Nat.succ Nat.zero with
| Nat.zero =&gt; 3
| Nat.succ k' =&gt; Nat.succ (plus 3 k'))
===&gt;
Nat.succ (Nat.succ (plus 3 Nat.zero))
===&gt;
Nat.succ (Nat.succ (match Nat.zero with
| Nat.zero =&gt; 3
| Nat.succ k' =&gt; Nat.succ (plus 3 k')))
===&gt;
Nat.succ (Nat.succ 3)
===&gt;
5
</code></pre>
<p>One way to think about addition is that <em>n</em> + <em>k</em> applies <code>Nat.succ</code> <em>k</em> times to <em>n</em>.
Similarly, multiplication <em>n</em> × <em>k</em> adds <em>n</em> to itself <em>k</em> times and subtraction <em>n</em> - <em>k</em> takes <em>n</em>'s predecessor <em>k</em> times.</p>
<pre><code class="language-lean">def times (n : Nat) (k : Nat) : Nat :=
  match k with
  | Nat.zero =&gt; Nat.zero
  | Nat.succ k' =&gt; plus n (times n k')

def minus (n : Nat) (k : Nat) : Nat :=
  match k with
  | Nat.zero =&gt; n
  | Nat.succ k' =&gt; pred (minus n k')
</code></pre>
<p>Not every function can be easily written using structural recursion.
The understanding of addition as iterated <code>Nat.succ</code>, multiplication as iterated addition, and subtraction as iterated predecessor suggests an implementation of division as iterated subtraction.
In this case, if the numerator is less that the divisor, the result is zero.
Otherwise, the result is the successor of dividing the numerator minus the divisor by the divisor.</p>
<pre><code class="language-lean">def div (n : Nat) (k : Nat) : Nat :=
  if n &lt; k then
    0
  else Nat.succ (div (n - k) k)
</code></pre>
<p>This program terminates for all inputs, as it always makes progress towards the base case.
However, it is not structurally recursive, because it doesn't follow the pattern of finding a result for zero and transforming a result for a smaller <code>Nat</code> into a result for its successor.
In particular, the recursive invocation of the function is applied to the result of another function call, rather than to an input constructor's argument.
Thus, Lean rejects it with the following message:</p>
<pre><code class="language-output error">fail to show termination for
  div
with errors
argument #1 was not used for structural recursion
  failed to eliminate recursive application
    div (n - k) k

argument #2 was not used for structural recursion
  failed to eliminate recursive application
    div (n - k) k

structural recursion cannot be used

failed to prove termination, use `termination_by` to specify a well-founded relation
</code></pre>
<p>This message means that <code>div</code> requires a manual proof of termination.
This topic will be explored in a later chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polymorphism"><a class="header" href="#polymorphism">Polymorphism</a></h1>
<p>Just as in most languages, types in Lean can take arguments.
For instance, the type <code>List Nat</code> describes lists of natural numbers, <code>List String</code> describes lists of strings, and <code>List (List Point)</code> describes lists of lists of points.
This is very similar to <code>List&lt;Nat&gt;</code>, <code>List&lt;String&gt;</code>, or <code>List&lt;List&lt;Point&gt;&gt;</code> in a language like C# or Java.
Just as Lean uses a space to pass an argument to a function, it uses a space to pass an argument to a type.</p>
<p>In functional programming, the term <em>polymorphism</em> typically refers to datatypes and definitions that take types as arguments.
This is different from the object-oriented programming community, where the term typically refers to subclasses that may override some behavior of their superclass.
In this book, &quot;polymorphism&quot; always refers to the first sense of the word.
These type arguments can be used in the datatype or definition, which allows the same datatype or definition to be used with any type that results from replacing the arguments' names with some other types.</p>
<p>The <code>Point</code> structure requires that both the <code>x</code> and <code>y</code> fields are <code>Float</code>s.
There is, however, nothing about points that require a specific representation for each coordinate.
A polymorphic version of <code>Point</code>, called <code>PPoint</code>, can take a type as an argument, and then use that type for both fields:</p>
<pre><code class="language-lean">structure PPoint (α : Type) where
  x : α
  y : α
deriving Repr
</code></pre>
<p>Just as a function definition's arguments are written immediately after the name being defined, a structure's arguments are written immediately after the structure's name.
It is customary to use Greek letters to name type arguments in Lean when no more specific name suggests itself.
<code>Type</code> is a type that describes other types, so <code>Nat</code>, <code>List String</code>, and <code>PPoint Int</code> all have type <code>Type</code>.</p>
<p>Just like <code>List</code>, <code>PPoint</code> can be used by providing a specific type as its argument:</p>
<pre><code class="language-lean">def natOrigin : PPoint Nat :=
  { x := Nat.zero, y := Nat.zero }
</code></pre>
<p>In this example, both fields are expected to be <code>Nat</code>s.
Just as a function is called by replacing its argument variables with its argument values, providing <code>PPoint</code> with the type <code>Nat</code> as an argument yields a structure in which the fields <code>x</code> and <code>y</code> have the type <code>Nat</code>, because the argument name <code>α</code> has been replaced by the argument type <code>Nat</code>.
Because types are ordinary expressions in Lean, passing arguments to polymorphic types (like <code>PPoint</code>) doesn't require any special syntax.</p>
<p>Definitions may also take types as arguments, which makes them polymorphic.
The function <code>replaceX</code> replaces the <code>x</code> field of a <code>PPoint</code> with a new value.
In order to allow <code>replaceX</code> to work with <em>any</em> polymorphic point, it must be polymorphic itself.
This is achieved by having its first argument be the type of the point's fields, with later arguments referring back to the first argument's name.</p>
<pre><code class="language-lean">def replaceX (α : Type) (point : PPoint α) (newX : α) : PPoint α :=
  { point with x := newX }
</code></pre>
<p>In other words, when the types of the arguments <code>point</code> and <code>newX</code> mention <code>α</code>, they are referring to <em>whichever type was provided as the first argument</em>.
This is similar to the way that function argument names refer to the values that were provided when they occur in the function's body.</p>
<p>This can be seen by asking Lean to check the type of <code>replaceX</code>, and then asking it to check the type of <code>replaceX Nat</code>.</p>
<pre><code class="language-lean">#check replaceX
</code></pre>
<pre><code class="language-output info">replaceX : (α : Type) → PPoint α → α → PPoint α
</code></pre>
<p>This function type includes the <em>name</em> of the first argument, and later arguments in the type refer back to this name.
Just as the value of a function application is found by replacing the argument name with the provided argument value in the function's body, the type of a function application is found by replacing the argument's name with the provided value in the function's return type.
Providing the first argument, <code>Nat</code>, causes all occurrences of <code>α</code> in the remainder of the type to be replaced with <code>Nat</code>:</p>
<pre><code class="language-lean">#check replaceX Nat
</code></pre>
<pre><code class="language-output info">replaceX Nat : PPoint Nat → Nat → PPoint Nat
</code></pre>
<p>Because the remaining arguments are not explicitly named, no further substitution occurs as more arguments are provided:</p>
<pre><code class="language-lean">#check replaceX Nat natOrigin
</code></pre>
<pre><code class="language-output info">replaceX Nat natOrigin : Nat → PPoint Nat
</code></pre>
<pre><code class="language-lean">#check replaceX Nat natOrigin 5
</code></pre>
<pre><code class="language-output info">replaceX Nat natOrigin 5 : PPoint Nat
</code></pre>
<p>The fact that the type of the whole function application expression was determined by passing a type as an argument has no bearing on the ability to evaluate it.</p>
<pre><code class="language-lean">#eval replaceX Nat natOrigin 5
</code></pre>
<pre><code class="language-output info">{ x := 5, y := 0 }
</code></pre>
<p>Polymorphic functions work by taking a named type argument and having later types refer to the argument's name.
However, there's nothing special about type arguments that allows them to be named.
Given a datatype that represents positive or negative signs:</p>
<pre><code class="language-lean">inductive Sign where
  | pos
  | neg
</code></pre>
<p>it is possible to write a function whose argument is a sign.
If the argument is positive, the function returns a <code>Nat</code>, while if it's negative, it returns an <code>Int</code>:</p>
<pre><code class="language-lean">def posOrNegThree (s : Sign) : match s with | Sign.pos =&gt; Nat | Sign.neg =&gt; Int :=
  match s with
  | Sign.pos =&gt; (3 : Nat)
  | Sign.neg =&gt; (-3 : Int)
</code></pre>
<p>Because types are first class and can be computed using the ordinary rules of the Lean language, they can be computed by pattern-matching against a datatype.
When Lean is checking this function, it uses the fact that the function's body pattern-matches to run the same pattern in the type, showing that <code>Nat</code> is the expected type for the <code>pos</code> case and that <code>Int</code> is the expected type for the <code>neg</code> case.</p>
<h2 id="linked-lists"><a class="header" href="#linked-lists">Linked Lists</a></h2>
<p>Lean's standard library includes a canonical linked list datatype, called <code>List</code>, and special syntax that makes it more convenient to use.
Lists are written in square brackets.
For instance, a list that contains the prime numbers less than 10 can be written:</p>
<pre><code class="language-lean">def primesUnder10 : List Nat := [2, 3, 5, 7]
</code></pre>
<p>Behind the scenes, <code>List</code> is an inductive datatype, defined like this:</p>
<pre><code class="language-lean">inductive List (α : Type) where
  | nil : List α
  | cons : α → List α → List α
</code></pre>
<p>The actual definition in the standard library is slightly different, because it uses features that have not yet been presented, but it is substantially similar.
This definition says that <code>List</code> takes a single type as its argument, just as <code>PPoint</code> did.
This type is the type of the entries stored in the list.
According to the constructors, a <code>List α</code> can be built with either <code>nil</code> or <code>cons</code>.
The constructor <code>nil</code> represents empty lists, and the constructor <code>cons</code> represents a single element in the linked list.
The first argument to <code>cons</code> is the head of the list, and the second argument is its tail.</p>
<p>The <code>primesUnder10</code> example can be written more explicitly by using <code>List</code>'s constructors directly:</p>
<pre><code class="language-lean">def explicitPrimesUnder10 : List Nat :=
  List.cons 2 (List.cons 3 (List.cons 5 (List.cons 7 List.nil)))
</code></pre>
<p>These two definitions are completely equivalent, but <code>primesUnder10</code> is much easier to read than <code>explicitPrimesUnder10</code>.</p>
<p>Functions that consume <code>List</code>s can be defined in much the same way as functions that consume <code>Nat</code>s.
Indeed, one way to think of a linked list is as a <code>Nat</code> that has an extra data field dangling off each <code>succ</code> constructor.
From this point of view, computing the length of a list is the process of replacing each <code>cons</code> with a <code>succ</code> and the final <code>nil</code> with a <code>zero</code>.
Just as <code>replaceX</code> took the type of the fields of the point as an argument, <code>length</code> takes the type of the list's entries.
For example, if the list contains strings, then the first argument is <code>String</code>: <code>length String [&quot;Sourdough&quot;, &quot;bread&quot;]</code>.
It should compute like this:</p>
<pre><code>length String [&quot;Sourdough&quot;, &quot;bread&quot;]
===&gt;
length String (List.cons &quot;Sourdough&quot; (List.cons &quot;bread&quot; List.nil))
===&gt;
Nat.succ (length String (List.cons &quot;bread&quot; List.nil))
===&gt;
Nat.succ (Nat.succ (length String List.nil))
===&gt;
Nat.succ (Nat.succ Nat.zero)
===&gt;
2
</code></pre>
<p>The definition of <code>length</code> is both polymorphic (because it takes the list entry type as an argument) and recursive (because it refers to itself).
Generally, functions follow the shape of the data: recursive datatypes lead to recursive functions, and polymorphic datatypes lead to polymorphic functions.</p>
<pre><code class="language-lean">def length (α : Type) (xs : List α) : Nat :=
  match xs with
  | List.nil =&gt; Nat.zero
  | List.cons y ys =&gt; Nat.succ (length α ys)
</code></pre>
<p>Names such as <code>xs</code> and <code>ys</code> are conventionally used to stand for lists of unknown values.
The <code>s</code> in the name indicates that they are plural, so they are pronounced &quot;exes&quot; and &quot;whys&quot; rather than &quot;x s&quot; and &quot;y s&quot;.</p>
<p>To make it easier to read functions on lists, the bracket notation <code>[]</code> can be used to pattern-match against <code>nil</code>, and an infix <code>::</code> can be used in place of <code>cons</code>:</p>
<pre><code class="language-lean">def length (α : Type) (xs : List α) : Nat :=
  match xs with
  | [] =&gt; 0
  | y :: ys =&gt; Nat.succ (length α ys)
</code></pre>
<h2 id="implicit-arguments"><a class="header" href="#implicit-arguments">Implicit Arguments</a></h2>
<p>Both <code>replaceX</code> and <code>length</code> are somewhat bureaucratic to use, because the type argument is typically uniquely determined by the later values.
Indeed, in most languages, the compiler is perfectly capable of determining type arguments on its own, and only occasionally needs help from users.
This is also the case in Lean.
Arguments can be declared <em>implicit</em> by wrapping them in curly braces instead of parentheses when defining a function.
For instance, a version of <code>replaceX</code> with an implicit type argument looks like this:</p>
<pre><code class="language-lean">def replaceX {α : Type} (point : PPoint α) (newX : α) : PPoint α :=
  { point with x := newX }
</code></pre>
<p>It can be used with <code>natOrigin</code> without providing <code>Nat</code> explicitly, because Lean can <em>infer</em> the value of <code>α</code> from the later arguments:</p>
<pre><code class="language-lean">#eval replaceX natOrigin 5
</code></pre>
<pre><code class="language-output info">{ x := 5, y := 0 }
</code></pre>
<p>Similarly, <code>length</code> can be redefined to take the entry type implicitly:</p>
<pre><code class="language-lean">def length {α : Type} (xs : List α) : Nat :=
  match xs with
  | [] =&gt; 0
  | y :: ys =&gt; Nat.succ (length ys)
</code></pre>
<p>This <code>length</code> function can be applied directly to <code>primesUnder10</code>:</p>
<pre><code class="language-lean">#eval length primesUnder10
</code></pre>
<pre><code class="language-output info">4
</code></pre>
<p>In the standard library, Lean calls this function <code>List.length</code>, which means that the dot syntax that is used for structure field access can also be used to find the length of a list:</p>
<pre><code class="language-lean">#eval primesUnder10.length
</code></pre>
<pre><code class="language-output info">4
</code></pre>
<p>Just as C# and Java require type arguments to provided explicitly from time to time, Lean is not always capable of finding implicit arguments.
In these cases, they can be provided using their names.
For instance, a version of <code>List.length</code> that only works for lists of integers can be specified by setting <code>α</code> to <code>Int</code>:</p>
<pre><code class="language-lean">#check List.length (α := Int)
</code></pre>
<pre><code class="language-output info">List.length : List Int → Nat
</code></pre>
<h2 id="more-built-in-datatypes"><a class="header" href="#more-built-in-datatypes">More Built-In Datatypes</a></h2>
<p>In addition to lists, Lean's standard library contains a number of other structures and inductive datatypes that can be used in a variety of contexts.</p>
<h3 id="option"><a class="header" href="#option"><code>Option</code></a></h3>
<p>Not every list has a first entry—some lists are empty.
Many operations on collections may fail to find what they are looking for.
For instance, a function that finds the first entry in a list may not find any such entry.
It must therefore have a way to signal that there was no first entry.</p>
<p>Many languages have a <code>null</code> value that represents the absence of a value.
Instead of equipping existing types with a special <code>null</code> value, Lean provides a datatype called <code>Option</code> that equips some other type with an indicator for missing values.
For instance, a nullable <code>Int</code> is represented by <code>Option Int</code>, and a nullable list of strings is represented by the type <code>Option (List String)</code>.
Introducing a new type to represent nullability means that the type system ensures that checks for <code>null</code> cannot be forgotten, because an <code>Option Int</code> can't be used in a context where an <code>Int</code> is expected.</p>
<p><code>Option</code> has two constructors, called <code>some</code> and <code>none</code>, that respectively represent the non-null and null versions of the underlying type.
The non-null constructor, <code>some</code>, contains the underlying value, while <code>none</code> takes no arguments:</p>
<pre><code class="language-lean">inductive Option (α : Type) : Type where
  | none : Option α
  | some (val : α) : Option α
</code></pre>
<p>The <code>Option</code> type is very similar to nullable types in languages like C# and Kotlin, but it is not identical.
In these languages, if a type (say, <code>Boolean</code>) always refers to actual values of the type (<code>true</code> and <code>false</code>), the type <code>Boolean?</code> or <code>Nullable&lt;Boolean&gt;</code> additionally admits the <code>null</code> value.
Tracking this in the type system is very useful: the type checker and other tooling can help programmers remember to check for null, and APIs that explicitly describe nullability through type signatures are more informative than ones that don't.
However, these nullable types differ from Lean's <code>Option</code> in one very important way, which is that they don't allow multiple layers of optionality.
<code>Option (Option Int)</code> can be constructed with <code>none</code>, <code>some none</code>, or <code>some (some 360)</code>.
C#, on the other hand, forbids multiple layers of nullability by only allowing <code>?</code> to be added to non-nullable types, while Kotlin treats <code>T??</code> as being equivalent to <code>T?</code>.
This subtle difference is rarely relevant in practice, but it can matter from time to time.</p>
<p>To find the first entry in a list, if it exists, use <code>List.head?</code>.
The question mark is part of the name, and is not related to the use of question marks to indicate nullable types in C# or Kotlin.
In the definition of <code>List.head?</code>, an underscore is used to represent the tail of the list.
In patterns, underscores match anything at all, but do not introduce variables to refer to the matched data.
Using underscores instead of names is a way to clearly communicate to readers that part of the input is ignored.</p>
<pre><code class="language-lean">def List.head? {α : Type} (xs : List α) : Option α :=
  match xs with
  | [] =&gt; none
  | y :: _ =&gt; some y
</code></pre>
<p>A Lean naming convention is to define operations that might fail in groups using the suffixes <code>?</code> for a version that returns an <code>Option</code>, <code>!</code> for a version that crashes when provided with invalid input, and <code>D</code> for a version that returns a default value when the operation would otherwise fail.
For instance, <code>head</code> requires the caller to provide mathematical evidence that the list is not empty, <code>head?</code> returns an <code>Option</code>, <code>head!</code> crashes the program when passed an empty list, and <code>headD</code> takes a default value to return in case the list is empty.
The question mark and exclamation mark are part of the name, not special syntax, as Lean's naming rules are more liberal than many languages.</p>
<p>Because <code>head?</code> is defined in the <code>List</code> namespace, it can be used with accessor notation:</p>
<pre><code class="language-lean">#eval primesUnder10.head?
</code></pre>
<pre><code class="language-output info">some 2
</code></pre>
<p>However, attempting to test it on the empty list leads to two errors:</p>
<pre><code class="language-lean">#eval [].head?
</code></pre>
<pre><code class="language-output error">don't know how to synthesize implicit argument
  @List.nil ?m.19130
context:
⊢ Type ?u.19127

don't know how to synthesize implicit argument
  @_root_.List.head? ?m.19130 []
context:
⊢ Type ?u.19127
</code></pre>
<p>This is because Lean was unable to fully determine the expression's type.
In particular, it could neither find the implicit type argument to <code>List.head?</code>, nor could it find the implicit type argument to <code>List.nil</code>.
In Lean's output, <code>?m.XYZ</code> represents a part of a program that could not be inferred.
These unknown parts are called <em>metavariables</em>, and they occur in some error messages.
In order to evaluate an expression, Lean needs to be able to find its type, and the type was unavailable because the empty list does not have any entries from which the type can be found.
Explicitly providing a type allows Lean to proceed:</p>
<pre><code class="language-lean">#eval [].head? (α := Int)
</code></pre>
<pre><code class="language-output info">none
</code></pre>
<p>The error messages provide a useful clue.
Both messages use the <em>same</em> metavariable to describe the missing implicit argument, which means that Lean has determined that the two missing pieces will share a solution, even though it was unable to determine the actual value of the solution.</p>
<h3 id="prod"><a class="header" href="#prod"><code>Prod</code></a></h3>
<p>The <code>Prod</code> structure, short for &quot;Product&quot;, is a generic way of joining two values together.
For instance, a <code>Prod Nat String</code> contains a <code>Nat</code> and a <code>String</code>.
In other words, <code>PPoint Nat</code> could be replaced by <code>Prod Nat Nat</code>.
<code>Prod</code> is very much like C#'s tuples, the <code>Pair</code> and <code>Triple</code> types in Kotlin, and <code>tuple</code> in C++.
Many applications are best served by defining their own structures, even for simple cases like <code>Point</code>, because using domain terminology can make it easier to read the code.</p>
<p>On the other hand, there are some cases where it is not worth the overhead of defining a new type.
Additionally, some libraries are sufficiently generic that there is no more specific concept than &quot;pair&quot;.
Finally, the standard library contains a variety of convenience functions that make it easier to work with the built-in pair type.</p>
<p>The standard pair structure is called <code>Prod</code>.</p>
<pre><code class="language-lean">structure Prod (α : Type) (β : Type) : Type where
  fst : α
  snd : β
</code></pre>
<p>Lists are used so frequently that there is special syntax to make them more readable.
For the same reason, both the product type and its constructor have special syntax.
The type <code>Prod α β</code> is typically written <code>α × β</code>, mirroring the usual notation for a Cartesian product of sets.
Similarly, the usual mathematical notation for pairs is available for <code>Prod</code>.
In other words, instead of writing:</p>
<pre><code class="language-lean">def fives : String × Int := { fst := &quot;five&quot;, snd := 5 }
</code></pre>
<p>it suffices to write:</p>
<pre><code class="language-lean">def fives : String × Int := (&quot;five&quot;, 5)
</code></pre>
<p>Both notations are right-associative.
This means that the following definitions are equivalent:</p>
<pre><code class="language-lean">def sevens : String × Int × Nat := (&quot;VII&quot;, 7, 4 + 3)

def sevens : String × (Int × Nat) := (&quot;VII&quot;, (7, 4 + 3))
</code></pre>
<p>In other words, all products of more than two types, and their corresponding constructors, are actually nested products and nested pairs behind the scenes.</p>
<h3 id="sum"><a class="header" href="#sum"><code>Sum</code></a></h3>
<p>The <code>Sum</code> datatype is a generic way of allowing a choice between values of two different types.
For instance, a <code>Sum String Int</code> is either a <code>String</code> or an <code>Int</code>.
Like <code>Prod</code>, <code>Sum</code> should be used either when writing very generic code, for a very small section of code where there is no sensible domain-specific type, or when the standard library contains useful functions.
In most situations, it is more readable and maintainable to use a custom inductive type.</p>
<p>Values of type <code>Sum α β</code> are either the constructor <code>inl</code> applied to a value of type <code>α</code> or the constructor <code>inr</code> applied to a value of type <code>β</code>:</p>
<pre><code class="language-lean">inductive Sum (α : Type) (β : Type) : Type where
  | inl : α → Sum α β
  | inr : β → Sum α β
</code></pre>
<p>These names are abbreviations for &quot;left injection&quot; and &quot;right injection&quot;, respectively.
Just as the Cartesian product notation is used for <code>Prod</code>, a &quot;circled plus&quot; notation is used for <code>Sum</code>, so <code>α ⊕ β</code> is another way to write <code>Sum α β</code>.
There is no special syntax for <code>Sum.inl</code> and <code>Sum.inr</code>.</p>
<p>For instance, if pet names can either be dog names or cat names, then a type for them can be introduced as a sum of strings:</p>
<pre><code class="language-lean">def PetName : Type := String ⊕ String
</code></pre>
<p>In a real program, it would usually be better to define a custom inductive datatype for this purpose with informative constructor names.
Here, <code>Sum.inl</code> is to be used for dog names, and <code>Sum.inr</code> is to be used for cat names.
These constructors can be used to write a list of animal names:</p>
<pre><code class="language-lean">def animals : List PetName :=
  [Sum.inl &quot;Spot&quot;, Sum.inr &quot;Tiger&quot;, Sum.inl &quot;Fifi&quot;, Sum.inl &quot;Rex&quot;, Sum.inr &quot;Floof&quot;]
</code></pre>
<p>Pattern matching can be used to distinguish between the two constructors.
For instance, a function that counts the number of dogs in a list of animal names (that is, the number of <code>Sum.inl</code> constructors) looks like this:</p>
<pre><code class="language-lean">def howManyDogs (pets : List PetName) : Nat :=
  match pets with
  | [] =&gt; 0
  | Sum.inl _ :: morePets =&gt; howManyDogs morePets + 1
  | Sum.inr _ :: morePets =&gt; howManyDogs morePets
</code></pre>
<p>Function calls are evaluated before infix operators, so <code>howManyDogs morePets + 1</code> is the same as <code>(howManyDogs morePets) + 1</code>.
As expected, <code>#eval howManyDogs animals</code> yields <code>3</code>.</p>
<h3 id="unit"><a class="header" href="#unit"><code>Unit</code></a></h3>
<p><code>Unit</code> is a type with just one argumentless constructor, called <code>unit</code>.
In other words, it describes only a single value, which consists of said constructor applied to no arguments whatsoever.
<code>Unit</code> is defined as follows:</p>
<pre><code class="language-lean">inductive Unit : Type where
  | unit : Unit
</code></pre>
<p>On its own, <code>Unit</code> is not particularly useful.
However, in polymorphic code, it can be used as a placeholder for data that is missing.
For instance, the following inductive datatype represents arithmetic expressions:</p>
<pre><code class="language-lean">inductive ArithExpr (ann : Type) : Type where
  | int : ann → Int → ArithExpr ann
  | plus : ann → ArithExpr ann → ArithExpr ann → ArithExpr ann
  | minus : ann → ArithExpr ann → ArithExpr ann → ArithExpr ann
  | times : ann → ArithExpr ann → ArithExpr ann → ArithExpr ann
</code></pre>
<p>The type argument <code>ann</code> stands for annotations, and each constructor is annotated.
Expressions coming from a parser might be annotated with source locations, so a return type of <code>ArithExpr SourcePos</code> ensures that the parser put a <code>SourcePos</code> at each subexpression.
Expressions that don't come from the parser, however, will not have source locations, so their type can be <code>ArithExpr Unit</code>.</p>
<p>Additionally, because all Lean functions have arguments, zero-argument functions in other languages can be represented as functions that take a <code>Unit</code> argument.
In a return position, the <code>Unit</code> type is similar to <code>void</code> in languages derived from C.
In the C family, a function that returns <code>void</code> will return control to its caller, but it will not return any interesting value.
By being an intentionally uninteresting value, <code>Unit</code> allows this to be expressed without requiring a special-purpose <code>void</code> feature in the type system.
Unit's constructor can be written as empty parentheses: <code>() : Unit</code>.</p>
<h3 id="empty"><a class="header" href="#empty"><code>Empty</code></a></h3>
<p>The <code>Empty</code> datatype has no constructors whatsoever.
Thus, it indicates unreachable code, because no series of calls can ever terminate with a value at type <code>Empty</code>.</p>
<p><code>Empty</code> is not used nearly as often as <code>Unit</code>.
However, it is useful in some specialized contexts.
Many polymorphic datatypes do not use all of their type arguments in all of their constructors.
For instance, <code>Sum.inl</code> and <code>Sum.inr</code> each use only one of <code>Sum</code>'s type arguments.
Using <code>Empty</code> as one of the type arguments to <code>Sum</code> can rule out one of the constructors at a particular point in a program.
This can allow generic code to be used in contexts that have additional restrictions.</p>
<h3 id="naming-sums-products-and-units"><a class="header" href="#naming-sums-products-and-units">Naming: Sums, Products, and Units</a></h3>
<p>Generally speaking, types that offer multiple constructors are called <em>sum types</em>, while types whose single constructor takes multiple arguments are called <em>product types</em>.
These terms are related to sums and products used in ordinary arithmetic.
The relationship is easiest to see when the types involved contain a finite number of values.
If <code>α</code> and <code>β</code> are types that contain <em>n</em> and <em>k</em> distinct values, respectively, then <code>α ⊕ β</code> contains <em>n</em> + <em>k</em> distinct values and <code>α × β</code> contains <em>n</em> × <em>k</em> distinct values.
For instance, <code>Bool</code> has two values: <code>true</code> and <code>false</code>, and <code>Unit</code> has one value: <code>Unit.unit</code>.
The product <code>Bool × Unit</code> has the two values <code>(true, Unit.unit)</code> and <code>(false, Unit.unit)</code>, and the sum <code>Bool ⊕ Unit</code> has the three values <code>Sum.inl true</code>, <code>Sum.inl false</code>, and <code>Sum.inr unit</code>.
Similarly, 2 × 1 = 2, and 2 + 1 = 3.</p>
<h2 id="messages-you-may-meet-2"><a class="header" href="#messages-you-may-meet-2">Messages You May Meet</a></h2>
<p>Not all definable structures or inductive types can have the type <code>Type</code>.
In particular, if a constructor takes an arbitrary type as an argument, then the inductive type must have a different type.
These errors usually state something about &quot;universe levels&quot;.
For example, for this inductive type:</p>
<pre><code class="language-lean">inductive MyType : Type where
  | ctor : (α : Type) → α → MyType
</code></pre>
<p>Lean gives the following error:</p>
<pre><code class="language-output error">invalid universe level in constructor 'MyType.ctor', parameter 'α' has type
  Type
at universe level
  2
it must be smaller than or equal to the inductive datatype universe level
  1
</code></pre>
<p>A later chapter describes why this is the case, and how to modify definitions to make them work.
For now, try making the type an argument to the inductive type as a whole, rather than to the constructor.</p>
<p>Similarly, if a constructor's argument is a function that takes the datatype being defined as an argument, then the definition is rejected.
For example:</p>
<pre><code class="language-lean">inductive MyType : Type where
  | ctor : (MyType → Int) → MyType
</code></pre>
<p>yields the message:</p>
<pre><code class="language-output error">(kernel) arg #1 of 'MyType.ctor' has a non positive occurrence of the datatypes being declared
</code></pre>
<p>For technical reasons, allowing these datatypes could make it possible to undermine Lean's internal logic, making it unsuitable for use as a theorem prover.</p>
<p>Forgetting an argument to an inductive type can also yield a confusing message.
For example, when the argument <code>α</code> is not passed to <code>MyType</code> in <code>ctor</code>'s type:</p>
<pre><code class="language-lean">inductive MyType (α : Type) : Type where
  | ctor : α → MyType
</code></pre>
<p>Lean replies with the following error:</p>
<pre><code class="language-output error">type expected, got
  (MyType : Type → Type)
</code></pre>
<p>The error message is saying that <code>MyType</code>'s type, which is <code>Type → Type</code>, does not itself describe types.
<code>MyType</code> requires an argument to become an actual honest-to-goodness type.</p>
<p>The same message can appear when type arguments are omitted in other contexts, such as in a type signature for a definition:</p>
<pre><code class="language-lean">inductive MyType (α : Type) : Type where
  | ctor : α → MyType α

def ofFive : MyType := ctor 5
</code></pre>
<h2 id="exercises-3"><a class="header" href="#exercises-3">Exercises</a></h2>
<ul>
<li>Write a function to find the last entry in a list. It should return an <code>Option</code>.</li>
<li>Write a function that finds the first entry in a list that satisfies a given predicate. Start the definition with <code>def List.findFirst? {α : Type} (xs : List α) (predicate : α → Bool) : Option α :=</code></li>
<li>Write a function <code>Prod.swap</code> that swaps the two fields in a pair. Start the definition with <code>def Prod.swap {α β : Type} (pair : α × β) : β × α :=</code></li>
<li>Rewrite the <code>PetName</code> example to use a custom datatype and compare it to the version that uses <code>Sum</code>.</li>
<li>Write a function <code>zip</code> that combines two lists into a list of pairs. The resulting list should be as long as the shortest input list. Start the definition with <code>def zip {α β : Type} (xs : List α) (ys : List β) : List (α × β) :=</code>.</li>
<li>Write a polymorphic function <code>take</code> that returns the first <em>n</em> entries in a list, where <em>n</em> is a <code>Nat</code>. If the list contains fewer than <code>n</code> entries, then the resulting list should be the input list. <code>#eval take 3 [&quot;bolete&quot;, &quot;oyster&quot;]</code> should yield <code>[&quot;bolete&quot;, &quot;oyster&quot;]</code>, and <code>#eval take 1 [&quot;bolete&quot;, &quot;oyster&quot;]</code> should yield <code>[&quot;bolete&quot;]</code>.</li>
<li>Using the analogy between types and arithmetic, write a function that distributes products over sums. In other words, it should have type <code>α × (β ⊕ γ) → (α × β) ⊕ (α × γ)</code>.</li>
<li>Using the analogy between types and arithmetic, write a function that turns multiplication by two into a sum. In other words, it should have type <code>Bool × α → α ⊕ α</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="additional-conveniences"><a class="header" href="#additional-conveniences">Additional Conveniences</a></h1>
<p>Lean contains a number of convenience features that make programs much more concise.</p>
<h2 id="automatic-implicit-arguments"><a class="header" href="#automatic-implicit-arguments">Automatic Implicit Arguments</a></h2>
<p>When writing polymorphic functions in Lean, it is typically not necessary to list all the implicit arguments.
Instead, they can simply be mentioned.
If Lean can determine their type, then they are automatically inserted as implicit arguments.
In other words, the previous definition of <code>length</code>:</p>
<pre><code class="language-lean">def length {α : Type} (xs : List α) : Nat :=
  match xs with
  | [] =&gt; 0
  | y :: ys =&gt; Nat.succ (length ys)
</code></pre>
<p>can be written without <code>{α : Type}</code>:</p>
<pre><code class="language-lean">def length (xs : List α) : Nat :=
  match xs with
  | [] =&gt; 0
  | y :: ys =&gt; Nat.succ (length ys)
</code></pre>
<p>This can greatly simplify highly polymorphic definitions that take many implicit arguments.</p>
<h2 id="pattern-matching-definitions"><a class="header" href="#pattern-matching-definitions">Pattern-Matching Definitions</a></h2>
<p>When defining functions with <code>def</code>, it is quite common to name an argument and then immediately use it with pattern matching.
For instance, in <code>length</code>, the argument <code>xs</code> is used only in <code>match</code>.
In these situations, the cases of the <code>match</code> expression can be written directly, without naming the argument at all.</p>
<p>The first step is to move the arguments' types to the right of the definition's type, in the form of a function type.
For instance, the type of <code>length</code> is <code>List α → Nat</code>.
Then, replace the <code>:=</code> with each case of the pattern match:</p>
<pre><code class="language-lean">def length : List α → Nat
  | [] =&gt; 0
  | y :: ys =&gt; Nat.succ (length ys)
</code></pre>
<p>This syntax can also be used to define functions that take more than one argument.
In this case, their patterns are separated by commas.
For instance, <code>drop</code> takes a number <em>n</em> and a list, and returns the list after removing the first <em>n</em> entries.</p>
<pre><code class="language-lean">def drop : Nat → List α → List α
  | Nat.zero, xs =&gt; xs
  | _, [] =&gt; []
  | Nat.succ n, x :: xs =&gt; drop n xs
</code></pre>
<p>Named arguments and patterns can also be used in the same definition.
For instance, a function that takes a default value and an optional value, and returns the default when the optional value is <code>none</code>, can be written:</p>
<pre><code class="language-lean">def fromOption (default : α) : Option α → α
  | none =&gt; default
  | some x =&gt; x
</code></pre>
<p>This function is called <code>Option.getD</code> in the standard library, and can be called with dot notation:</p>
<pre><code class="language-lean">#eval (some &quot;salmonberry&quot;).getD &quot;&quot;
</code></pre>
<pre><code class="language-output info">&quot;salmonberry&quot;
</code></pre>
<pre><code class="language-lean">#eval none.getD &quot;&quot;
</code></pre>
<pre><code class="language-output info">&quot;&quot;
</code></pre>
<h2 id="local-definitions"><a class="header" href="#local-definitions">Local Definitions</a></h2>
<p>It is often useful to name intermediate steps in a computation.
In many cases, intermediate values represent useful concepts all on their own, and naming them explicitly can make the program easier to read.
In other cases, the intermediate value is used more than once.
As in most other languages, writing down the same code twice in Lean causes it to be computed twice, while saving the result in a variable leads to the result of the computation being saved and re-used.</p>
<p>For instance, <code>unzip</code> is a function that transforms a list of pairs into a pair of lists.
When the list of pairs is empty, then the result of <code>unzip</code> is a pair of empty lists.
When the list of pairs has a pair at its head, then the two fields of the pair are added to the result of unzipping the rest of the list.
This definition of <code>unzip</code> follows that description exactly:</p>
<pre><code class="language-lean">def unzip : List (α × β) → List α × List β
  | [] =&gt; ([], [])
  | (x, y) :: xys =&gt;
    (x :: (unzip xys).fst, y :: (unzip xys).snd)
</code></pre>
<p>Unfortunately, there is a problem: this code is slower than it needs to be.
Each entry in the list of pairs leads to two recursive calls, which makes this function take exponential time.
However, both recursive calls will have the same result, so there is no reason to make the recursive call twice.</p>
<p>In Lean, the result of the recursive call can be named, and thus saved, using <code>let</code>.
Local definitions with <code>let</code> resemble top-level definitions with <code>def</code>: it takes a name to be locally defined, arguments if desired, a type signature, and then a body following <code>:=</code>.
After the local definition, the expression in which the local definition is available (called the <em>body</em> of the <code>let</code>-expression) must be on a new line, starting at a column in the file that is less than or equal to that of the <code>let</code> keyword.
For instance, <code>let</code> can be used in <code>unzip</code> like this:</p>
<pre><code class="language-lean">def unzip : List (α × β) → List α × List β
  | [] =&gt; ([], [])
  | (x, y) :: xys =&gt;
    let unzipped : List α × List β := unzip xys
    (x :: unzipped.fst, y :: unzipped.snd)
</code></pre>
<p>To use <code>let</code> on a single line, separate the local definition from the body with a semicolon.</p>
<p>Local definitions with <code>let</code> may also use pattern matching when one pattern is enough to match all cases of a datatype.
In the case of <code>unzip</code>, the result of the recursive call is a pair.
Because pairs have only a single constructor, the name <code>unzipped</code> can be replaced with a pair pattern:</p>
<pre><code class="language-lean">def unzip : List (α × β) → List α × List β
  | [] =&gt; ([], [])
  | (x, y) :: xys =&gt;
    let (xs, ys) : List α × List β := unzip xys
    (x :: xs, y :: ys)
</code></pre>
<p>Judicious use of patterns with <code>let</code> can make code easier to read, compared to writing the accessor calls by hand.</p>
<p>The biggest difference between <code>let</code> and <code>def</code> is that recursive <code>let</code> definitions must be explicitly indicated by writing <code>let rec</code>.
For instance, one way to reverse a list involves a recursive helper function, as in this definition:</p>
<pre><code class="language-lean">def reverse (xs : List α) : List α :=
  let rec helper : List α → List α → List α
    | [], soFar =&gt; soFar
    | y :: ys, soFar =&gt; helper ys (y :: soFar)
  helper xs []
</code></pre>
<p>The helper function walks down the input list, moving one entry at a time over to <code>soFar</code>.
When it reaches the end of the input list, <code>soFar</code> contains a reversed version of the input.</p>
<h2 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h2>
<p>In many situations, Lean can automatically determine an expression's type.
In these cases, explicit types may be omitted from both top-level definitions (with <code>def</code>) and local definitions (with <code>let</code>).
For instance, the recursive call to <code>unzip</code> does not need an annotation:</p>
<pre><code class="language-lean">def unzip : List (α × β) → List α × List β
  | [] =&gt; ([], [])
  | (x, y) :: xys =&gt;
    let unzipped := unzip xys
    (x :: unzipped.fst, y :: unzipped.snd)
</code></pre>
<p>As a rule of thumb, omitting the types of literal values (like strings and numbers) usually works, although Lean may pick a type for literal numbers that is more specific than the intended type.
Lean can usually determine a type for a function application, because it already knows the argument types and the return type.
Omitting return types for function definitions will often work, but function arguments typically require annotations.
Definitions that are not functions, like <code>unzipped</code> in the example, do not need type annotations if their bodies do not need type annotations, and the body of this definition is a function application.</p>
<p>Omitting the return type for <code>unzip</code> is possible when using an explicit <code>match</code> expression:</p>
<pre><code class="language-lean">def unzip (pairs : List (α × β)) :=
  match pairs with
  | [] =&gt; ([], [])
  | (x, y) :: xys =&gt;
    let unzipped := unzip xys
    (x :: unzipped.fst, y :: unzipped.snd)
</code></pre>
<p>Generally speaking, it is a good idea to err on the side of too many, rather than too few, type annotations.
First off, explicit types communicate assumptions about the code to readers.
Even if Lean can determine the type on its own, it can still be easier to read code without having to repeatedly query Lean for type information.
Secondly, explicit types help localize errors.
The more explicit a program is about its types, the more informative the error messages can be.
This is especially important in a language like Lean that has a very expressive type system.
Thirdly, explicit types make it easier to write the program in the first place.
The type is a specification, and the compiler's feedback can be a helpful tool in writing a program that meets the specification.
Finally, Lean's type inference is a best-effort system.
Because Lean's type system is so expressive, there is no &quot;best&quot; or most general type to find for all expressions.
This means that even if you get a type, there's no guarantee that it's the <em>right</em> type for a given application.
For instance, <code>14</code> can be a <code>Nat</code> or an <code>Int</code>:</p>
<pre><code class="language-lean">#check 14
</code></pre>
<pre><code class="language-output info">14 : Nat
</code></pre>
<pre><code class="language-lean">#check (14 : Int)
</code></pre>
<pre><code class="language-output info">14 : Int
</code></pre>
<p>Missing type annotations can give confusing error messages.
Omitting all types from the definition of <code>unzip</code>:</p>
<pre><code class="language-lean">def unzip pairs :=
  match pairs with
  | [] =&gt; ([], [])
  | (x, y) :: xys =&gt;
    let unzipped := unzip xys
    (x :: unzipped.fst, y :: unzipped.snd)
</code></pre>
<p>leads to a message about the <code>match</code> expression:</p>
<pre><code class="language-output error">invalid match-expression, pattern contains metavariables
  []
</code></pre>
<p>This is because <code>match</code> needs to know the type of the value being inspected, but that type was not available.
A &quot;metavariable&quot; is an unknown part of a program, written <code>?m.XYZ</code> in error messages—they are described in the <a href="getting-to-know/polymorphism.html">section on Polymorphism</a>.
In this program, the type annotation on the argument is required.</p>
<p>Even some very simple programs require type annotations.
For instance, the identity function just returns whatever argument it is passed.
With argument and type annotations, it looks like this:</p>
<pre><code class="language-lean">def id (x : α) : α := x
</code></pre>
<p>Lean is capable of determining the return type on its own:</p>
<pre><code class="language-lean">def id (x : α) := x
</code></pre>
<p>Omitting the argument type, however, causes an error:</p>
<pre><code class="language-lean">def id x := x
</code></pre>
<pre><code class="language-output error">failed to infer binder type
</code></pre>
<p>In general, messages that say something like &quot;failed to infer&quot; or that mention metavariables are often a sign that more type annotations are necessary.
Especially while still learning Lean, it is useful to provide most types explicitly.</p>
<h2 id="simultaneous-matching"><a class="header" href="#simultaneous-matching">Simultaneous Matching</a></h2>
<p>Pattern-matching expressions, just like pattern-matching definitions, can match on multiple values at once.
Both the expressions to be inspected and the patterns that they match against are written with commas between them, similarly to the syntax used for definitions.
Here is a version of <code>drop</code> that uses simultaneous matching:</p>
<pre><code class="language-lean">def drop (n : Nat) (xs : List α) : List α :=
  match n, xs with
  | Nat.zero, ys =&gt; ys
  | _, [] =&gt; []
  | Nat.succ n , y :: ys =&gt; drop n ys
</code></pre>
<h2 id="natural-number-patterns"><a class="header" href="#natural-number-patterns">Natural Number Patterns</a></h2>
<p>In the section on <a href="getting-to-know/datatypes-and-patterns.html">datatypes and patterns</a>, <code>even</code> was defined like this:</p>
<pre><code class="language-lean">def even (n : Nat) : Bool :=
  match n with
  | Nat.zero =&gt; true
  | Nat.succ k =&gt; not (even k)
</code></pre>
<p>Just as there is special syntax to make list patterns more readable than using <code>List.cons</code> and <code>List.nil</code> directly, natural numbers can be matched using literal numbers and <code>+</code>.
For instance, <code>even</code> can also be defined like this:</p>
<pre><code class="language-lean">def even : Nat → Bool
  | 0 =&gt; true
  | n + 1 =&gt; not (even n)
</code></pre>
<p>In this notation, the arguments to the <code>+</code> pattern serve different roles.
Behind the scenes, the left argument (<code>n</code> above) becomes an argument to some number of <code>Nat.succ</code> patterns, and the right argument (<code>1</code> above) determines how many <code>Nat.succ</code>s to wrap around the pattern.
The explicit patterns in <code>halve</code>, which divides a <code>Nat</code> by two and drops the remainder:</p>
<pre><code class="language-lean">def halve : Nat → Nat
  | Nat.zero =&gt; 0
  | Nat.succ Nat.zero =&gt; 0
  | Nat.succ (Nat.succ n) =&gt; halve n + 1
</code></pre>
<p>can be replaced by numeric literals and <code>+</code>:</p>
<pre><code class="language-lean">def halve : Nat → Nat
  | 0 =&gt; 0
  | 1 =&gt; 0
  | n + 2 =&gt; halve n + 1
</code></pre>
<p>Behind the scenes, both definitions are completely equivalent.
Remember: <code>halve n + 1</code> is equivalent to <code>(halve n) + 1</code>, not <code>halve (n + 1)</code>.</p>
<p>When using this syntax, the second argument to <code>+</code> should always be a literal <code>Nat</code>.
Even though addition is commutative, flipping the arguments in a pattern can result in errors like the following:</p>
<pre><code class="language-lean">def halve : Nat → Nat
  | 0 =&gt; 0
  | 1 =&gt; 0
  | 2 + n =&gt; halve n + 1
</code></pre>
<pre><code class="language-output error">invalid patterns, `n` is an explicit pattern variable, but it only occurs in positions that are inaccessible to pattern matching
  .(Nat.add 2 n)
</code></pre>
<p>This restriction enables Lean to transform all uses of the <code>+</code> notation in a pattern into uses of the underlying <code>Nat.succ</code>, keeping the language simpler behind the scenes.</p>
<h2 id="anonymous-functions"><a class="header" href="#anonymous-functions">Anonymous Functions</a></h2>
<p>Functions in Lean need not be defined at the top level.
As expressions, functions are produced with the <code>fun</code> syntax.
Function expressions begin with the keyword <code>fun</code>, followed by one or more arguments, which are separated from the return expression using <code>=&gt;</code>.
For instance, a function that adds one to a number can be written:</p>
<pre><code class="language-lean">#check fun x =&gt; x + 1
</code></pre>
<pre><code class="language-output info">fun x =&gt; x + 1 : Nat → Nat
</code></pre>
<p>Type annotations are written the same way as on <code>def</code>, using parentheses and colons:</p>
<pre><code class="language-lean">#check fun (x : Int) =&gt; x + 1
</code></pre>
<pre><code class="language-output info">fun x =&gt; x + 1 : Int → Int
</code></pre>
<p>Similarly, implicit arguments may be written with curly braces:</p>
<pre><code class="language-lean">#check fun {α : Type} (x : α) =&gt; x
</code></pre>
<pre><code class="language-output info">fun {α} x =&gt; x : {α : Type} → α → α
</code></pre>
<p>This style of anonymous function expression is often referred to as a <em>lambda expression</em>, because the typical notation used in mathematical descriptions of programming languages uses the Greek letter λ (lambda) where Lean has the keyword <code>fun</code>.
Even though Lean does permit <code>λ</code> to be used instead of <code>fun</code>, it is most common to write <code>fun</code>.</p>
<p>Anonymous functions also support the multiple-pattern style used in <code>def</code>.
For instance, a function that returns the predecessor of a natural number if it exists can be written:</p>
<pre><code class="language-lean">#check fun
  | 0 =&gt; none
  | n + 1 =&gt; some n
</code></pre>
<pre><code class="language-output info">fun x =&gt;
  match x with
  | 0 =&gt; none
  | Nat.succ n =&gt; some n : Nat → Option Nat
</code></pre>
<p>Note that Lean's own description of the function has a named argument and a <code>match</code> expression.
Many of Lean's convenient syntactic shorthands are expanded to simpler syntax behind the scenes, and the abstraction sometimes leaks.</p>
<p>Definitions using <code>def</code> that take arguments may be rewritten as function expressions.
For instance, a function that doubles its argument can be written as follows:</p>
<pre><code class="language-lean">def double : Nat → Nat := fun
  | 0 =&gt; 0
  | k + 1 =&gt; double k + 2
</code></pre>
<p>When an anonymous function is very simple, like <code>fun x =&gt; x + 1</code>, the syntax for creating the function can be fairly verbose.
In that particular example, six non-whitespace characters are used to introduce the function, and its body consists of only three non-whitespace characters.
For these simple cases, Lean provides a shorthand.
In an expression surrounded by parentheses, a centered dot character <code>·</code> can stand for an argument, and the expression inside the parentheses becomes the function's body.
That particular function can also be written <code>(· + 1)</code>.
Type the centered dot using <code>\cdot</code>.</p>
<p>The centered dot always creates a function out of the <em>closest</em> surrounding set of parentheses.
For instance, <code>(· + 5, 3)</code> is a function that returns a pair of numbers, while <code>((· + 5), 3)</code> is a pair of a function and a number.
If multiple dots are used, then they become arguments from left to right:</p>
<pre><code class="language-lean">(· , ·) 1 2
===&gt;
(1, ·) 2
===&gt;
(1, 2)
</code></pre>
<p>Anonymous functions can be applied in precisely the same way as functions defined using <code>def</code> or <code>let</code>.
The command <code>#eval (fun x =&gt; x + x) 5</code> results in:</p>
<pre><code class="language-output info">10
</code></pre>
<p>while <code>#eval (· * 2) 5</code> results in:</p>
<pre><code class="language-output info">10
</code></pre>
<h2 id="namespaces"><a class="header" href="#namespaces">Namespaces</a></h2>
<p>Each name in Lean occurs in a <em>namespace</em>, which is a collection of names.
Names are placed in namespaces using <code>.</code>, so <code>List.map</code> is the name <code>map</code> in the <code>List</code> namespace.
Names in different namespaces do not conflict with each other, even if they are otherwise identical.
This means that <code>List.map</code> and <code>Array.map</code> are different names.
Namespaces may be nested, so <code>Project.Frontend.User.loginTime</code> is the name <code>loginTime</code> in the nested namespace <code>Project.Frontend.User</code>.</p>
<p>Names can be directly defined within a namespace.
For instance, the name <code>double</code> can be defined in the <code>Nat</code> namespace:</p>
<pre><code class="language-lean">def Nat.double (x : Nat) : Nat := x + x
</code></pre>
<p>Because <code>Nat</code> is also the name of a type, dot notation is available to call <code>Nat.double</code> on expressions with type <code>Nat</code>:</p>
<pre><code class="language-lean">#eval (4 : Nat).double
</code></pre>
<pre><code class="language-output info">8
</code></pre>
<p>In addition to defining names directly in a namespace, a sequence of declarations can be placed in a namespace using the <code>namespace</code> and <code>end</code> commands.
For instance, this defines <code>triple</code> and <code>quadruple</code> in the namespace <code>NewNamespace</code>:</p>
<pre><code class="language-lean">namespace NewNamespace
def triple (x : Nat) : Nat := 3 * x
def quadruple (x : Nat) : Nat := 2 * x + 2 * x
end NewNamespace
</code></pre>
<p>To refer to them, prefix their names with <code>NewNamespace.</code>:</p>
<pre><code class="language-lean">#check NewNamespace.triple
</code></pre>
<pre><code class="language-output info">NewNamespace.triple : Nat → Nat
</code></pre>
<pre><code class="language-lean">#check NewNamespace.quadruple
</code></pre>
<pre><code class="language-output info">NewNamespace.quadruple : Nat → Nat
</code></pre>
<p>Namespaces may be <em>opened</em>, which allows the names in them to be used without explicit qualification.
Writing <code>open MyNamespace in</code> before an expression causes the contents of <code>MyNamespace</code> to be available in the expression.
For example, <code>timesTwelve</code> uses both <code>quadruple</code> and <code>triple</code> after opening <code>NewNamespace</code>:</p>
<pre><code class="language-lean">def timesTwelve (x : Nat) :=
  open NewNamespace in
  quadruple (triple x)
</code></pre>
<p>Namespaces can also be opened prior to a command.
This allows all parts of the command to refer to the contents of the namespace, rather than just a single expression.
To do this, place the <code>open ... in</code> prior to the command.</p>
<pre><code class="language-lean">open NewNamespace in
#check quadruple
</code></pre>
<pre><code class="language-output info">quadruple : Nat → Nat
</code></pre>
<p>Finally, namespaces may be opened for <em>all</em> following commands for the rest of the file.
To do this, simply omit the <code>in</code> from a top-level usage of <code>open</code>.</p>
<h2 id="if-let"><a class="header" href="#if-let">if let</a></h2>
<p>When consuming values that have a sum type, it is often the case that only a single constructor is of interest.
For instance, given this type that represents a subset of Markdown inline elements:</p>
<pre><code class="language-lean">inductive Inline : Type where
  | lineBreak
  | string : String → Inline
  | emph : Inline → Inline
  | strong : Inline → Inline
</code></pre>
<p>a function that recognizes string elements and extracts their contents can be written:</p>
<pre><code class="language-lean">def Inline.string? (inline : Inline) : Option String :=
  match inline with
  | Inline.string s =&gt; some s
  | _ =&gt; none
</code></pre>
<p>An alternative way of writing this function's body uses <code>if</code> together with <code>let</code>:</p>
<pre><code class="language-lean">def Inline.string? (inline : Inline) : Option String :=
  if let Inline.string s := inline then
    some s
  else none
</code></pre>
<p>This is very much like the pattern-matching <code>let</code> syntax.
The difference is that it can be used with sum types, because a fallback is provided in the <code>else</code> case.
In some contexts, using <code>if let</code> instead of <code>match</code> can make code easier to read.</p>
<h2 id="positional-structure-arguments"><a class="header" href="#positional-structure-arguments">Positional Structure Arguments</a></h2>
<p>The <a href="getting-to-know/structures.html">section on structures</a> presents two ways of constructing structures:</p>
<ol>
<li>The constructor can be called directly, as in <code>Point.mk 1 2</code>.</li>
<li>Brace notation can be used, as in <code>{ x := 1, y := 2 }</code>.</li>
</ol>
<p>In some contexts, it can be convenient to pass arguments positionally, rather than by name, but without naming the constructor directly.
For instance, defining a variety of similar structure types can help keep domain concepts separate, but the natural way to read the code may treat each of them as being essentially a tuple.
In these contexts, the arguments can be enclosed in angle brackets <code>⟨</code> and <code>⟩</code>.
A <code>Point</code> can be written <code>⟨1, 2⟩</code>.
Be careful!
Even though they look like the less-than sign <code>&lt;</code> and greater-than sign <code>&gt;</code>, these brackets are different.
They can be input using <code>\&lt;</code> and <code>\&gt;</code>, respectively.</p>
<p>Just as with the brace notation for named constructor arguments, this positional syntax can only be used in a context where Lean can determine the structure's type, either from a type annotation or from other type information in the program.
For instance, <code>#eval ⟨1, 2⟩</code> yields the following error:</p>
<pre><code class="language-output error">invalid constructor ⟨...⟩, expected type must be an inductive type 
  ?m.33784
</code></pre>
<p>The metavariable in the error is because there is no type information available.
Adding an annotation, such as in <code>#eval (⟨1, 2⟩ : Point)</code>, solves the problem:</p>
<pre><code class="language-output info">{ x := 1.000000, y := 2.000000 }
</code></pre>
<h2 id="string-interpolation"><a class="header" href="#string-interpolation">String Interpolation</a></h2>
<p>In Lean, prefixing a string with <code>s!</code> triggers <em>interpolation</em>, where expressions contained in curly braces inside the string are replaced with their values.
This is similar to <code>f</code>-strings in Python and <code>$</code>-prefixed strings in C#.
For instance,</p>
<pre><code class="language-lean">#eval s!&quot;three fives is {NewNamespace.triple 5}&quot;
</code></pre>
<p>yields the output</p>
<pre><code class="language-output info">&quot;three fives is 15&quot;
</code></pre>
<p>Not all expressions can be interpolated into a string.
For instance, attempting to interpolate a function results in an error.</p>
<pre><code class="language-lean">#check s!&quot;three fives is {NewNamespace.triple}&quot;
</code></pre>
<p>yields the output</p>
<pre><code class="language-output info">failed to synthesize instance
  ToString (Nat → Nat)
</code></pre>
<p>This is because there is no standard way to convert functions into strings.
The Lean compiler maintains a table that describes how to convert values of various types into strings, and the message <code>failed to synthesize instance</code> means that the Lean compiler didn't find an entry in this table for the given type.
This uses the same language feature as the <code>deriving Repr</code> syntax that was described in the <a href="getting-to-know/structures.html">section on structures</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<h2 id="evaluating-expressions-1"><a class="header" href="#evaluating-expressions-1">Evaluating Expressions</a></h2>
<p>In Lean, computation occurs when expressions are evaluated.
This follows the usual rules of mathematical expressions: sub-expressions are replaced by their values following the usual order of operations, until the entire expression has become a value.
When evaluating an <code>if</code> or a <code>match</code>, the expressions in the branches are not evaluated until the value of the condition or the match subject has been found.</p>
<p>Once they have been given a value, variables never change.
Similarly to mathematics but unlike most programming languages, Lean variables are simply placeholders for values, rather than addresses to which new values can be written.
Variables' values may come from global definitions with <code>def</code>, local definitions with <code>let</code>, as named arguments to functions, or from pattern matching.</p>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>Functions in Lean are first-class values, meaning that they can be passed as arguments to other functions, saved in variables, and used like any other value.
Every Lean function takes exactly one argument.
To encode a function that takes more than one argument, Lean uses a technique called currying, where providing the first argument returns a function that expects the remaining arguments.
To encode a function that takes no arguments, Lean uses the <code>Unit</code> type, which is the least informative possible argument.</p>
<p>There are three primary ways of creating functions:</p>
<ol>
<li>Anonymous functions are written using <code>fun</code>.
For instance, a function that swaps the fields of a <code>Point</code> can be written <code>fun (point : Point) =&gt; { x := point.y, y := point.x : Point}</code></li>
<li>Very simple anonymous functions are written by placing one or more centered dots <code>·</code> inside of parentheses.
Each centered dot becomes an argument to the function, and the parentheses delimit its body.
For instance, a function that subtracts one from its argument can be written as <code>(· - 1)</code> instead of as <code>fun x =&gt; x - 1</code>.</li>
<li>Functions can be defined using <code>def</code> or <code>let</code> by adding an argument list or by using pattern-matching notation.</li>
</ol>
<h2 id="types-1"><a class="header" href="#types-1">Types</a></h2>
<p>Lean checks that every expression has a type.
Types, such as <code>Int</code>, <code>Point</code>, <code>{α : Type} → Nat → α → List α</code>, and <code>Option (String ⊕ (Nat × String))</code>, describe the values that may eventually be found for an expression.
Like other languages, types in Lean can express lightweight specifications for programs that are checked by the Lean compiler, obviating the need for certain classes of unit test.
Unlike most languages, Lean's types can also express arbitrary mathematics, unifying the worlds of programming and theorem proving.
While using Lean for proving theorems is mostly out of scope for this book, <em><a href="https://leanprover.github.io/theorem_proving_in_lean4/">Theorem Proving in Lean 4</a></em> contains more information on this topic.</p>
<p>Some expressions can be given multiple types.
For instance, <code>3</code> can be an <code>Int</code> or a <code>Nat</code>.
In Lean, this should be understood as two separate expressions, one with type <code>Nat</code> and one with type <code>Int</code>, that happen to be written in the same way, rather than as two different types for the same thing.</p>
<p>Lean is sometimes able to determine types automatically, but types must often be provided by the user.
This is because Lean's type system is so expressive.
Even when Lean can find a type, it may not find the desired type—<code>3</code> could be intended to be used as an <code>Int</code>, but Lean will give it the type <code>Nat</code> if there are no further constraints.
In general, it is a good idea to write most types explicitly, only letting Lean fill out the very obvious types.
This improves Lean's error messages and helps make programmer intent more clear.</p>
<p>Some functions or datatypes take types as arguments.
They are called <em>polymorphic</em>.
Polymorphism allows programs such as one that calculates the length of a list without caring what type the entries in the list have.
Because types are first class in Lean, polymorphism does not require any special syntax, so types are passed just like other arguments.
Giving an argument a name in a function type allows later types to mention that argument, and the type of applying that function to an argument is found by replacing the argument's name with the argument's value.</p>
<h2 id="structures-and-inductive-types"><a class="header" href="#structures-and-inductive-types">Structures and Inductive Types</a></h2>
<p>Brand new datatypes can be introduced to Lean using the <code>structure</code> or <code>inductive</code> features.
These new types are not considered to be equivalent to any other type, even if their definitions are otherwise identical.
Datatypes have <em>constructors</em> that explain the ways in which their values can be constructed, and each constructor takes some number of arguments.
Constructors in Lean are not the same as constructors in object-oriented languages: Lean's constructors are inert holders of data, rather than active code that initializes an allocated object.</p>
<p>Typically, <code>structure</code> is used to introduce a product type (that is, a type with just one constructor that takes any number of arguments), while <code>inductive</code> is used to introduce a sum type (that is, a type with many distinct constructors).
Datatypes defined with <code>structure</code> are provided with one accessor function for each of the constructor's arguments.
Both structures and inductive datatypes may be consumed with pattern matching, which exposes the values stored inside of constructors using a subset of the syntax used to call said constructors.
Pattern matching means that knowing how to create a value implies knowing how to consume it.</p>
<h2 id="recursion"><a class="header" href="#recursion">Recursion</a></h2>
<p>A definition is recursive when the name being defined is used in the definition itself.
Because Lean is an interactive theorem prover in addition to being a programming language, there are certain restrictions placed on recursive definitions.
In Lean's logical side, circular definitions could lead to logical inconsistency.</p>
<p>In order to ensure that recursive definitions do not undermine the logical side of Lean, Lean must be able to prove that all recursive functions terminate, no matter what arguments they are called with.
In practice, this means either that recursive calls are all performed on a structurally-smaller piece of the input, which ensures that there is always progress towards a base case, or that users must provide some other evidence that the function always terminates.
Similarly, recursive inductive types are not allowed to have a constructor that takes a function <em>from</em> the type as an argument, because this would make it possible to encode non-terminating functions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h1>
<p>While Lean has been designed to have a rich interactive environment in which programmers can get quite a lot of feedback from the language without leaving the confines of their favorite text editor, it is also a language in which real programs can be written.
This means that it also has a batch-mode compiler, a build system, a package manager, and all the other tools that are necessary for writing programs.</p>
<p>While the <a href="./getting-to-know.html">previous chapter</a> presented the basics of functional programming in Lean, this chapter explains how to start a programming project, compile it, and run the result.
Programs that run and interact with their environment (e.g. by reading input from standard input or creating files) are difficult to reconcile with the understanding of computation as the evaluation of mathematical expressions.
In addition to a description of the Lean build tools, this chapter also provides a way to think about functional programs that interact with the world.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-a-program"><a class="header" href="#running-a-program">Running a Program</a></h1>
<p>The simplest way to run a Lean program is to use the <code>--run</code> option to the Lean executable.
Create a file called <code>Hello.lean</code> and enter the following contents:</p>
<pre><code class="language-lean">def main : IO Unit := IO.println &quot;Hello, world!&quot;
</code></pre>
<p>Then, from the command line, run:</p>
<pre><code>lean --run Hello.lean
</code></pre>
<p>The program displays <code>Hello, world!</code> and exits.</p>
<h2 id="anatomy-of-a-greeting"><a class="header" href="#anatomy-of-a-greeting">Anatomy of a Greeting</a></h2>
<p>When Lean is invoked with the <code>--run</code> option, it invokes the program's <code>main</code> definition.
In programs that do not take command-line arguments, <code>main</code> should have type <code>IO Unit</code>.
This means that <code>main</code> is not a function, because there are no arrows (<code>→</code>) in its type.
Instead of a being a function that has side effects, <code>main</code> consists of a description of effects to be carried out.</p>
<p>As discussed in <a href="hello-world/../getting-to-know/polymorphism.html">the preceding chapter</a>, <code>Unit</code> is the simplest inductive type.
It has a single constructor called <code>unit</code> that takes no arguments.
Languages in the C tradition have a notion of a <code>void</code> function that does not return any value at all.
In Lean, all functions take an argument and return a value, and the lack of interesting arguments or return values can be signaled by using the <code>Unit</code> type instead.
If <code>Bool</code> represents a single bit of information, <code>Unit</code> represents zero bits of information.</p>
<p><code>IO α</code> is the type of a program that, when executed, will either throw an exception or return a value of type <code>α</code>.
During execution, this program may have side effects.
These programs are referred to as <code>IO</code> <em>actions</em>.
Lean distinguishes between <em>evaluation</em> of expressions, which strictly adheres to the mathematical model of substitution of values for variables and reduction of sub-expressions without side effects, and <em>execution</em> of <code>IO</code> actions, which rely on an external system to interact with the world.
<code>IO.println</code> is a function from strings to <code>IO</code> actions that, when executed, write the given string to standard output.
Because this action doesn't read any interesting information from the environment in the process of emitting the string, <code>IO.println</code> has type <code>String → IO Unit</code>.
If it did return something interesting, then that would be indicated by the <code>IO</code> action having a type other than <code>Unit</code>.</p>
<h2 id="functional-programming-vs-effects"><a class="header" href="#functional-programming-vs-effects">Functional Programming vs Effects</a></h2>
<p>Lean's model of computation is based on the evaluation of mathematical expressions, in which variables are given exactly one value that does not change over time.
The result of evaluating an expression does not change, and evaluating the same expression again will always yield the same result.</p>
<p>On the other hand, useful programs must interact with the world.
A program that performs neither input nor output can't ask a user for data, create files on disk, or open network connections.
Lean is written in itself, and the Lean compiler certainly reads files, creates files, and interacts with text editors.
How can a language in which the same expression always yields the same result support programs that read files from disk, when the contents of these files might change over time?</p>
<p>This apparent contradiction can be resolved by thinking a bit differently about side effects.
Imagine a café that sells coffee and sandwiches.
This café has two employees: a cook who fulfills orders, and a worker at the counter who interacts with customers and places order slips.
The cook is a surly person, who really prefers not to have any contact with the world outside, but who is very good at consistently delivering the food and drinks that the café is known for.
In order to do this, however, the cook needs peace and quiet, and can't be disturbed with conversation.
The counter worker is friendly, but completely incompetent in the kitchen.
Customers interact with the counter worker, who delegates all actual cooking to the cook.
If the cook has a question for a customer, such as clarifying an allergy, they send a little note to the counter worker, who interacts with the customer and passes a note back to the cook with the result.</p>
<p>In this analogy, the cook is the Lean language.
When provided with an order, the cook faithfully and consistently delivers what is requested.
The counter worker is the surrounding run-time system that interacts with the world and can accept payments, dispense food, and have conversations with customers.
Working together, the two employees serve all the functions of the restaurant, but their responsibilities are divided, with each performing the tasks that they're best at.
Just as keeping customers away allows the cook to focus on making truly excellent coffee and sandwiches, Lean's lack of side effects allows programs to be used as part of formal mathematical proofs.
It also helps programmers understand the parts of the program in isolation from each other, because there are no hidden state changes that create subtle coupling between components.
The cook's notes represent <code>IO</code> actions that are produced by evaluating Lean expressions, and the counter worker's replies are the values that are passed back from effects.</p>
<p>This model of side effects is quite similar to how the overall aggregate of the Lean language, its compiler, and its run-time system (RTS) work.
Primitives in the run-time system, written in C, implement all the basic effects.
When running a program, the RTS invokes the <code>main</code> action, which returns new <code>IO</code> actions to the RTS for execution.
The RTS executes these actions, delegating to the user's Lean code to carry out computations.
From the internal perspective of Lean, programs are free of side effects, and <code>IO</code> actions are just descriptions of tasks to be carried out.
From the external perspective of the program's user, there is a layer of side effects that create an interface to the program's core logic.</p>
<h2 id="real-world-functional-programming"><a class="header" href="#real-world-functional-programming">Real-World Functional Programming</a></h2>
<p>The other useful way to think about side effects in Lean is by considering <code>IO</code> actions to be functions that take the entire world as an argument and return a value paired with a new world.
In this case, reading a line of text from standard input <em>is</em> a pure function, because a different world is provided as an argument each time.
Writing a line of text to standard output is a pure function, because the world that the function returns is different from the one that it began with.
Programs do need to be careful to never re-use the world, nor to fail to return a new world—this would amount to time travel or the end of the world, after all.
Careful abstraction boundaries can make this style of programming safe.
If every primitive <code>IO</code> action accepts one world and returns a new one, and they can only be combined with tools that preserve this invariant, then the problem cannot occur.</p>
<p>This model cannot be implemented.
After all, the entire universe cannot be turned in to a Lean value and placed into memory.
However, it is possible to implement a variation of this model with an abstract token that stands for the world.
When the program is started, it is provided with a world token.
This token is then passed on to the IO primitives, and their returned tokens are similarly passed to the next step.
At the end of the program, the token is returned to the operating system.</p>
<p>This model of side effects is a good description of how <code>IO</code> actions as descriptions of tasks to be carried out by the RTS are represented internally in Lean.
The actual functions that transform the real world are behind an abstraction barrier.
But real programs typically consist of a sequence of effects, rather than just one.
To enable programs to use multiple effects, there is a sub-language of Lean called <code>do</code> notation that allows these primitive <code>IO</code> actions to be safely composed into a larger, useful program.</p>
<h2 id="combining-io-actions"><a class="header" href="#combining-io-actions">Combining <code>IO</code> Actions</a></h2>
<p>Most useful programs accept input in addition to producing output.
Furthermore, they may take decisions based on input, using the input data as part of a computation.
The following program, called <code>HelloName.lean</code>, asks the user for their name and then greets them:</p>
<pre><code class="language-lean">def main : IO Unit := do
  let stdin ← IO.getStdin
  let stdout ← IO.getStdout

  stdout.putStrLn &quot;How would you like to be addressed?&quot;
  let input ← stdin.getLine
  let name := input.dropRightWhile Char.isWhitespace

  stdout.putStrLn s!&quot;Hello, {name}!&quot;
</code></pre>
<p>In this program, the <code>main</code> action consists of a <code>do</code> block.
This block contains a sequence of <em>statements</em>, which can be both local variables (introduced using <code>let</code>) and actions that are to be executed.
Just as SQL can be thought of as a special-purpose language for interacting with databases, the <code>do</code> syntax can be thought of as a special-purpose sub-language within Lean that is dedicated to modeling imperative programs.
<code>IO</code> actions that are built with a <code>do</code> block are executed by executing the statements in order.</p>
<p>This program can be run in the same manner as the prior program:</p>
<pre><code>lean --run HelloName.lean
</code></pre>
<p>If the user responds with <code>David</code>, a session of interaction with the program reads:</p>
<pre><code>How would you like to be addressed?
David
Hello, David!
</code></pre>
<p>The type signature line is just like the one for <code>Hello.lean</code>:</p>
<pre><code class="language-lean">def main : IO Unit := do
</code></pre>
<p>The only difference is that it ends with the keyword <code>do</code>, which initiates a sequence of commands.
Each indented line following the keyword <code>do</code> is part of the same sequence of commands.</p>
<p>The first two lines, which read:</p>
<pre><code class="language-lean">  let stdin ← IO.getStdin
  let stdout ← IO.getStdout
</code></pre>
<p>retrieve the <code>stdin</code> and <code>stdout</code> handles by executing the library actions <code>IO.getStdin</code> and <code>IO.getStdout</code>, respectively.
In a <code>do</code> block, <code>let</code> has a slightly different meaning than in an ordinary expression.
Ordinarily, the local definition in a <code>let</code> can be used in just one expression, which immediately follows the local definition.
In a <code>do</code> block, local bindings introduced by <code>let</code> are available in all statements in the remainder of the <code>do</code> block, rather than just the next one.
Additionally, <code>let</code> typically connects the name being defined to its definition using <code>:=</code>, while some <code>let</code> bindings in <code>do</code> use a left arrow (<code>←</code> or <code>&lt;-</code>) instead.
Using an arrow means that the value of the expression is an <code>IO</code> action that should be executed, with the result of the action saved in the local variable.
In other words, if the expression to the right of the arrow has type <code>IO α</code>, then the variable has type <code>α</code> in the remainder of the <code>do</code> block.
<code>IO.getStdin</code> and <code>IO.getStdout</code> are <code>IO</code> actions in order to allow <code>stdin</code> and <code>stdout</code> to be locally overridden in a program, which can be convenient.
If they were global variables as in C, then there would be no meaningful way to override them, but <code>IO</code> actions can return different values each time they are executed.</p>
<p>The next part of the <code>do</code> block is responsible for asking the user for their name:</p>
<pre><code class="language-lean">  stdout.putStrLn &quot;How would you like to be addressed?&quot;
  let input ← stdin.getLine
  let name := input.dropRightWhile Char.isWhitespace
</code></pre>
<p>The first line writes the question to <code>stdout</code>, the second line requests input from <code>stdin</code>, and the third line removes the trailing newline (plus any other trailing whitespace) from the input line.
The definition of <code>name</code> uses <code>:=</code>, rather than <code>←</code>, because <code>String.dropRightWhile</code> is an ordinary function on strings, rather than an <code>IO</code> action.</p>
<p>Finally, the last line in the program is:</p>
<pre><code>  stdout.putStrLn s!&quot;Hello, {name}!&quot;
</code></pre>
<p>It uses <a href="hello-world/../getting-to-know/conveniences.html#string-interpolation">string interpolation</a> to insert the provided name into a greeting string, writing the result to <code>stdout</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="step-by-step"><a class="header" href="#step-by-step">Step By Step</a></h1>
<p>A <code>do</code> block can be executed one line at a time.
Start with the program from the prior section:</p>
<pre><code class="language-lean">  let stdin ← IO.getStdin
  let stdout ← IO.getStdout
  stdout.putStrLn &quot;How would you like to be addressed?&quot;
  let input ← stdin.getLine
  let name := input.dropRightWhile Char.isWhitespace
  stdout.putStrLn s!&quot;Hello, {name}!&quot;
</code></pre>
<h2 id="standard-io"><a class="header" href="#standard-io">Standard IO</a></h2>
<p>The first line is <code>  let stdin ← IO.getStdin</code>, while the remainder is:</p>
<pre><code class="language-lean">  let stdout ← IO.getStdout
  stdout.putStrLn &quot;How would you like to be addressed?&quot;
  let input ← stdin.getLine
  let name := input.dropRightWhile Char.isWhitespace
  stdout.putStrLn s!&quot;Hello, {name}!&quot;
</code></pre>
<p>To execute a <code>let</code> statement that uses a <code>←</code>, start by evaluating the expression to the right of the arrow (in this case, <code>IO.getStdIn</code>).
Because this expression is just a variable, its value is looked up.
The resulting value is a built-in primitive <code>IO</code> action.
The next step is to execute this <code>IO</code> action, resulting in a value that represents the standard input stream, which has type <code>IO.FS.Stream</code>.
Standard input is then associated with the name to the left of the arrow (here <code>stdin</code>) for the remainder of the <code>do</code> block.</p>
<p>Executing the second line, <code>  let stdout ← IO.getStdout</code>, proceeds similarly.
First, the expression <code>IO.getStdout</code> is evaluated, yielding an <code>IO</code> action that will return the standard output.
Next, this action is executed, actually returning the standard output.
Finally, this value is associated with the name <code>stdout</code> for the remainder of the <code>do</code> block.</p>
<h2 id="asking-a-question"><a class="header" href="#asking-a-question">Asking a Question</a></h2>
<p>Now that <code>stdin</code> and <code>stdout</code> have been found, the remainder of the block consists of a question and an answer:</p>
<pre><code class="language-lean">  stdout.putStrLn &quot;How would you like to be addressed?&quot;
  let input ← stdin.getLine
  let name := input.dropRightWhile Char.isWhitespace
  stdout.putStrLn s!&quot;Hello, {name}!&quot;
</code></pre>
<p>The first statement in the block, <code>  stdout.putStrLn &quot;How would you like to be addressed?&quot;</code>, consists of an expression.
To execute an expression, it is first evaluated.
In this case, <code>IO.FS.Stream.putStrLn</code> has type <code>IO.FS.Stream → String → IO Unit</code>.
This means that it is a function that accepts a stream and a string, returning an <code>IO</code> action.
The expression uses <a href="hello-world/../getting-to-know/structures.html#behind-the-scenes">accessor notation</a> for a function call.
This function is applied to two arguments: the standard output stream and a string.
The value of the expression is an <code>IO</code> action that will write the string and a newline character to the output stream.
Having found this value, the next step is to execute it, which causes the string and newline to actually be written to <code>stdout</code>.
Statements that consist only of expressions do not introduce any new variables.</p>
<p>The next statement in the block is <code>  let input ← stdin.getLine</code>.
<code>IO.FS.Stream.getLine</code> has type <code>IO.FS.Stream → IO String</code>, which means that it is a function from a stream to an <code>IO</code> action that will return a string.
Once again, this is an example of accessor notation.
This <code>IO</code> action is executed, and the program waits until the user has typed a complete line of input.
Assume the user writes &quot;<code>David</code>&quot;.
The resulting line (<code>&quot;David\n&quot;</code>) is associated with <code>input</code>, where the escape sequence <code>\n</code> denotes the newline character.</p>
<pre><code class="language-lean">  let name := input.dropRightWhile Char.isWhitespace
  stdout.putStrLn s!&quot;Hello, {name}!&quot;
</code></pre>
<p>The next line, <code>  let name := input.dropRightWhile Char.isWhitespace</code>, is a <code>let</code> statement.
Unlike the other <code>let</code> statements in this program, it uses <code>:=</code> instead of <code>←</code>.
This means that the expression will be evaluated, but the resulting value need not be an <code>IO</code> action and will not be executed.
In this case, <code>String.dropRightWhile</code> takes a string and a predicate over characters and returns a new string from which all the characters at the end of the string that satisfy the predicate have been removed.
For example,</p>
<pre><code class="language-lean">#eval &quot;Hello!!!&quot;.dropRightWhile (· == '!')
</code></pre>
<p>yields</p>
<pre><code class="language-output info">&quot;Hello&quot;
</code></pre>
<p>and</p>
<pre><code class="language-lean">#eval &quot;Hello...   &quot;.dropRightWhile (fun c =&gt; not (c.isAlphanum))
</code></pre>
<p>yields</p>
<pre><code class="language-output info">&quot;Hello&quot;
</code></pre>
<p>in which all non-alphanumeric characters have been removed from the right side of the string.
In the current line of the program, whitespace characters (including the newline) are removed from the right side of the input string, resulting in <code>&quot;David&quot;</code>, which is associated with <code>name</code> for the remainder of the block.</p>
<h2 id="greeting-the-user"><a class="header" href="#greeting-the-user">Greeting the User</a></h2>
<p>All that remains to be executed in the <code>do</code> block is a single statement:</p>
<pre><code class="language-lean">  stdout.putStrLn s!&quot;Hello, {name}!&quot;
</code></pre>
<p>The string argument to <code>putStrLn</code> is constructed via string interpolation, yielding the string <code>&quot;Hello, David!&quot;</code>.
Because this statement is an expression, it is evaluated to yield an <code>IO</code> action that will print this string with a newline to standard output.
Once the expression has been evaluated, the resulting <code>IO</code> action is executed, resulting in the greeting.</p>
<h2 id="io-actions-as-values"><a class="header" href="#io-actions-as-values"><code>IO</code> Actions as Values</a></h2>
<p>In the above description, it can be difficult to see why the distinction between evaluating expressions and executing <code>IO</code> actions is necessary.
After all, each action is executed immediately after it is produced.
Why not simply carry out the effects during evaluation, as is done in other languages?</p>
<p>The answer is twofold.
First off, separating evaluation from execution means that programs must be explicit about which functions can have side effects.
Because the parts of the program that do not have effects are much more amenable to mathematical reasoning, whether in the heads of programmers or using Lean's facilities for formal proof, this separation can make it easier to avoid bugs.
Secondly, not all <code>IO</code> actions need be executed at the time that they come into existence.
The ability to mention an action without carrying it out allows ordinary functions to be used as control structures.</p>
<p>For instance, the function <code>twice</code> takes an <code>IO</code> action as its argument, returning a new action that will execute the first one twice.</p>
<pre><code class="language-lean">def twice (action : IO Unit) : IO Unit := do
  action
  action
</code></pre>
<p>For instance, executing</p>
<pre><code class="language-lean">twice (IO.println &quot;shy&quot;)
</code></pre>
<p>results in</p>
<pre><code class="language-output info">shy
shy
</code></pre>
<p>being printed.
This can be generalized to a version that runs the underlying action any number of times:</p>
<pre><code class="language-lean">def nTimes (action : IO Unit) : Nat → IO Unit
  | 0 =&gt; pure ()
  | n + 1 =&gt; do
    action
    nTimes action n
</code></pre>
<p>In the base case for <code>Nat.zero</code>, the result is <code>pure ()</code>.
The function <code>pure</code> creates an <code>IO</code> action that has no side effects, but returns <code>pure</code>'s argument, which in this case is the constructor for <code>Unit</code>.
As an action that does nothing and returns nothing interesting, <code>pure ()</code> is at the same time utterly boring and very useful.
In the recursive step, a <code>do</code> block is used to create an action that first executes <code>action</code> and then executes the result of the recursive call.
Executing <code>nTimes (IO.println &quot;Hello&quot;) 3</code> causes the following output:</p>
<pre><code class="language-output info">Hello
Hello
Hello
</code></pre>
<p>In addition to using functions as control structures, the fact that <code>IO</code> actions are first-class values means that they can be saved in data structures for later execution.
For instance, the function <code>countdown</code> takes a <code>Nat</code> and returns a list of unexecuted <code>IO</code> actions, one for each <code>Nat</code>:</p>
<pre><code class="language-lean">def countdown : Nat → List (IO Unit)
  | 0 =&gt; [IO.println &quot;Blast off!&quot;]
  | n + 1 =&gt; IO.println s!&quot;{n + 1}&quot; :: countdown n
</code></pre>
<p>This function has no side effects, and does not print anything.
For example, it can be applied to an argument, and the length of the resulting list of actions can be checked:</p>
<pre><code class="language-lean">def from5 : List (IO Unit) := countdown 5
</code></pre>
<p>This list contains six elements (one for each number, plus a <code>&quot;Blast off!&quot;</code> action for zero):</p>
<pre><code class="language-lean">#eval from5.length
</code></pre>
<pre><code class="language-output info">6
</code></pre>
<p>The function <code>runActions</code> takes a list of actions and constructs a single action that runs them all in order:</p>
<pre><code class="language-lean">def runActions : List (IO Unit) → IO Unit
  | [] =&gt; pure ()
  | act :: actions =&gt; do
    act
    runActions actions
</code></pre>
<p>Its structure is essentially the same as that of <code>nTimes</code>, except instead of having one action that is executed for each <code>Nat.succ</code>, the action under each <code>List.cons</code> is to be executed.
Similarly, <code>runActions</code> does not itself run the actions.
It creates a new action that will run them, and that action must be placed in a position where it will be executed as a part of <code>main</code>:</p>
<pre><code class="language-lean">def main : IO Unit := runActions from5
</code></pre>
<p>Running this program results in the following output:</p>
<pre><code class="language-output info">5
4
3
2
1
Blast off!
</code></pre>
<p>What happens when this program is run?
The first step is to evaluate <code>main</code>. That occurs as follows:</p>
<pre><code class="language-lean">main
===&gt;
runActions from5
===&gt;
runActions (countdown 5)
===&gt;
runActions
  [IO.println &quot;5&quot;,
   IO.println &quot;4&quot;,
   IO.println &quot;3&quot;,
   IO.println &quot;2&quot;,
   IO.println &quot;1&quot;,
   IO.println &quot;Blast off!&quot;]
===&gt;
do IO.println &quot;5&quot;
   IO.println &quot;4&quot;
   IO.println &quot;3&quot;
   IO.println &quot;2&quot;
   IO.println &quot;1&quot;
   IO.println &quot;Blast off!&quot;
   pure ()
</code></pre>
<p>The resulting <code>IO</code> action is a <code>do</code> block.
Each step of the <code>do</code> block is then executed, one at a time, yielding the expected output.
The final step, <code>pure ()</code>, does not have any effects, and it is only present because the definition of <code>runActions</code> needs a base case.</p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>Step through the execution of the following program on a piece of paper:</p>
<pre><code class="language-lean">def main : IO Unit := do
  let englishGreeting := IO.println &quot;Hello!&quot;
  IO.println &quot;Bonjour!&quot;
  englishGreeting
</code></pre>
<p>While stepping through the program's execution, identify when an expression is being evaluated and when an <code>IO</code> action is being executed.
When executing an <code>IO</code> action results in a side effect, write it down.
After doing this, run the program with Lean and double-check that your predictions about the side effects were correct.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starting-a-project"><a class="header" href="#starting-a-project">Starting a Project</a></h1>
<p>As a program written in Lean becomes more serious, an ahead-of-time compiler-based workflow that results in an executable becomes more attractive.
Like other languages, Lean has tools for building multiple-file packages and managing dependencies.
The standard Lean build tool is called Lake (short for &quot;Lean Make&quot;), and it is configured in Lean.
Just as Lean contains a special-purpose language for writing programs with effects (the <code>do</code> language), Lake contains a special-purpose language for configuring builds.
These languages are referred to as <em>embedded domain-specific languages</em> (or sometimes <em>domain-specific embedded languages</em>, abbreviated EDSL or DSEL).
They are <em>domain-specific</em> in the sense that they are used for a particular purpose, with concepts from some sub-domain, and they are typically not suitable for general-purpose programming.
They are <em>embedded</em> because they occur inside another language's syntax.
While Lean contains rich facilities for creating EDSLs, they are beyond the scope of this book.</p>
<h2 id="first-steps"><a class="header" href="#first-steps">First steps</a></h2>
<p>To get started with a project that uses Lake, the command <code>lake new greeting</code> in a directory that does not already contain a file or directory called <code>greeting</code>.
This creates a directory called <code>greeting</code> that contains the following files:</p>
<ul>
<li><code>Main.lean</code> is the file in which the Lean compiler will look for the <code>main</code> action.</li>
<li><code>Greeting.lean</code> is the scaffolding of a support library for the program.</li>
<li><code>lakefile.lean</code> contains the configuration that <code>lake</code> needs to build the application.</li>
<li><code>lean-toolchain</code> contains an identifier for the specific version of Lean that is used for the project.</li>
</ul>
<p>Additionally, <code>lake new</code> initializes the project as a Git repository and configures its <code>.gitignore</code> file to ignore intermediate build products.
Typically, the majority of the application logic will be in a collection of libraries for the program, while <code>Main.lean</code> will contain a small wrapper around these pieces that does things like parsing command lines and executing the central application logic.
To create a project in an already-existing directory, run <code>lake init</code> instead of <code>lake new</code>.</p>
<p>By default, the library file <code>Greeting.lean</code> contains a single definition:</p>
<pre><code class="language-lean">def hello := &quot;world&quot;
</code></pre>
<p>while the executable source <code>Main.lean</code> contains:</p>
<pre><code class="language-lean">import Greeting

def main : IO Unit :=
  IO.println s!&quot;Hello, {hello}!&quot;
</code></pre>
<p>The <code>import</code> line makes the contents of <code>Greeting.lean</code> available in <code>Main.lean</code>.</p>
<p>To build the package, run the command <code>lake build</code>.
After a number of build commands scroll by, the resulting binary has been placed in <code>build/bin</code>.
Running <code>./build/bin/greeting</code> results in <code>Hello, world!</code>.</p>
<h2 id="lakefiles"><a class="header" href="#lakefiles">Lakefiles</a></h2>
<p>A <code>lakefile.lean</code> describes a <em>package</em>, which is a coherent collection of Lean code for distribution, analogous to an <code>npm</code> or <code>nuget</code> package or a Rust crate.
A package may contain any number of libraries or executables.
While the <a href="https://github.com/leanprover/lake#readme">documentation for Lake</a> describes the available options in a lakefile, it makes use of a number of Lean features that have not yet been described here.
The generated <code>lakefile.lean</code> contains the following:</p>
<pre><code class="language-lean">import Lake
open Lake DSL

package greeting {
  -- add package configuration options here
}

lean_lib Greeting {
  -- add library configuration options here
}

@[default_target]
lean_exe greeting {
  root := `Main
}
</code></pre>
<p>This initial Lakefile consists of three items:</p>
<ul>
<li>a <em>package</em> declaration, named <code>greeting</code>,</li>
<li>a <em>library</em> declaration, named <code>Greeting</code>, and</li>
<li>an <em>executable</em>, also named <code>greeting</code>.</li>
</ul>
<p>Each Lakefile will contain exactly one package, but any number of libraries or executables.
Additionally, Lakefiles may contain <em>external libraries</em>, which are libraries not written in Lean to be statically linked with the resulting executable, <em>custom targets</em>, which are build targets that don't fit naturally into the library/executable taxonomy, <em>dependencies</em>, which are declarations of other Lean packages (either locally or from remote Git repositories), and <em>scripts</em>, which are essentially <code>IO</code> actions (similar to <code>main</code>), but that additionally have access to metadata about the package configuration.
The items in the Lakefile allow things like source file locations, module hierarchies, and compiler flags to be configured.
Generally speaking, however, the defaults are reasonable.</p>
<p>Libraries, executables, and custom targets are all called <em>targets</em>.
By default, <code>lake build</code> builds those targets that are annotated with <code>@[default_target]</code>.
This annotation is an <em>attribute</em>, which is metadata that can be associated with a Lean declaration.
Attributes are similar to Java annotations or C# and Rust attributes.
They are used pervasively throughout Lean.
To build a target that is not annotated with <code>@[default_target]</code>, specify the target's name as an argument after <code>lake build</code>.</p>
<h2 id="libraries-and-imports"><a class="header" href="#libraries-and-imports">Libraries and Imports</a></h2>
<p>A Lean library consists of a hierarchically organized collection of source files from which names can be imported, called <em>modules</em>.
By default, a library has a single root file that matches its name.
In this case, the root file for the library <code>Greeting</code> is <code>Greeting.lean</code>.
The first line of <code>Main.lean</code>, which is <code>import Greeting</code>, makes the contents of <code>Greeting.lean</code> available in <code>Main.lean</code>.</p>
<p>Additional module files may be added to the library by creating a directory called <code>Greeting</code> and placing them inside.
These names can be imported by replacing the directory separator with a dot.
For instance, creating the file <code>Greeting/Smile.lean</code> with the contents:</p>
<pre><code class="language-lean">def expression : String := &quot;a big smile&quot;
</code></pre>
<p>means that <code>Main.lean</code> can use the definition as follows:</p>
<pre><code class="language-lean">import Greeting
import Greeting.Smile

def main : IO Unit :=
  IO.println s!&quot;Hello, {hello}, with {expression}!&quot;
</code></pre>
<p>The module name hierarchy is decoupled from the namespace hierarchy.
In Lean, modules are units of code distribution, while namespaces are units of code organization.
That is, names defined in the module <code>Greeting.Smile</code> are not automatically in a corresponding namespace <code>Greeting.Smile</code>.
Modules may place names into any namespace they like, and the code that imports them may <code>open</code> the namespace or not.
<code>import</code> is used to make the contents of a source file available, while <code>open</code> makes names from a namespace available in the current context.
In the Lakefile, the line <code>import Lake</code> makes the contents of the <code>Lake</code> module available, while the line <code>open Lake DSL</code> makes the contents of the <code>Lake</code> and <code>DSL</code> namespaces available without any prefixes.
The <code>Lake</code> module places names into both the <code>Lake</code> and <code>DSL</code> namespaces.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="worked-example-cat"><a class="header" href="#worked-example-cat">Worked Example: <code>cat</code></a></h1>
<p>The standard Unix utility <code>cat</code> takes a number of command-line options, followed by a zero or more input files.
If no files are provided, or if one of them is a dash (<code>-</code>), then it takes the standard input as the corresponding input instead of reading a file.
The contents of the inputs are written, one after the other, to the standard output.
If a specified input file does not exist, this is noted on standard error, but <code>cat</code> continues concatenating the remaining inputs.
A non-zero exit code is returned if any of the input files do not exist.</p>
<p>This section describes a simplified version of <code>cat</code>, called <code>feline</code>.
Unlike commonly-used versions of <code>cat</code>, <code>feline</code> has no command-line options for features such as numbering lines, indicating non-printing characters, or displaying help text.
Furthermore, it cannot read more than once from a standard input that's associated with a terminal device.</p>
<p>To get the most benefit from this section, follow along yourself.
It's OK to copy-paste the code examples, but it's even better to type them in by hand.
This makes it easier to learn the mechanical process of typing in code, recovering from mistakes, and interpreting feedback from the compiler.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h2>
<p>The first step in implementing <code>feline</code> is to create a package and decide how to organize the code.
In this case, because the program is so simple, all the code will be placed in <code>Main.lean</code>.
The first step is to run <code>lake new feline</code>.
Edit the Lakefile to remove the library, and delete the generated library code and the reference to it from <code>Main.lean</code>.
Once this has been done, <code>lakefile.lean</code> should contain:</p>
<pre><code>import Lake
open Lake DSL

package feline {
  -- add package configuration options here
}

@[default_target]
lean_exe feline {
  root := `Main
}
</code></pre>
<p>and <code>Main.lean</code> should contain something like:</p>
<pre><code>def main : IO Unit :=
  IO.println s!&quot;Hello, cats!&quot;
</code></pre>
<p>Ensure that the code can be built by running <code>lake build</code>.</p>
<h2 id="concatenating-streams"><a class="header" href="#concatenating-streams">Concatenating Streams</a></h2>
<p>Now that the basic skeleton of the program has been built, it's time to actually enter the code.
A proper implementation of <code>cat</code> can be used with infinite IO streams, such as <code>/dev/random</code>, which means that it can't read its input into memory before outputting it.
Furthermore, it should not work one character at a time, as this leads to frustratingly slow performance.
Instead, it's better to read contiguous blocks of data all at once, directing the data to the standard output one block at a time.</p>
<p>The first step is to decide how big of a block to read.
For the sake of simplicity, this implementation uses a conservative 20 kilobyte block.
<code>USize</code> is analogous to <code>size_t</code> in C—it's an unsigned integer type that is big enough to represent all valid array sizes.</p>
<pre><code class="language-lean">def bufsize : USize := 20 * 1024
</code></pre>
<h3 id="streams"><a class="header" href="#streams">Streams</a></h3>
<p>The main work of <code>feline</code> is done by <code>dump</code>, which reads input one block at a time, dumping the result to standard output, until the end of the input has been reached:</p>
<pre><code class="language-lean">partial def dump (stream : IO.FS.Stream) : IO Unit := do
  let buf ← stream.read bufsize
  if buf.isEmpty then
    pure ()
  else
    let stdout ← IO.getStdout
    stdout.write buf
    dump stream
</code></pre>
<p>The <code>dump</code> function is declared <code>partial</code>, because it calls itself recursively on input that is not immediately smaller than an argument.
When a function is declared to be partial, Lean does not require a proof that it terminates.
On the other hand, partial functions are also much less amenable to proofs of correctness, because allowing infinite loops in Lean's logic would make it unsound.
However, there is no way to prove that <code>dump</code> terminates, because infinite input (such as from <code>/dev/random</code>) would mean that it does not, in fact, terminate.
In cases like this, there is no alternative to declaring the function <code>partial</code>.</p>
<p>The type <code>IO.FS.Stream</code> represents a POSIX stream.
Behind the scenes, it is represented as a structure that has one field for each POSIX stream operation.
Each operation is represented as an IO action that provides the corresponding operation:</p>
<pre><code class="language-lean">structure Stream where
  flush   : IO Unit
  read    : USize → IO ByteArray
  write   : ByteArray → IO Unit
  getLine : IO String
  putStr  : String → IO Unit
</code></pre>
<p>The Lean compiler contains <code>IO</code> actions (such as <code>IO.getStdout</code>, which is called in <code>dump</code>) to get streams that represent standard input, standard output, and standard error.
These are <code>IO</code> actions rather than ordinary definitions because Lean allows these standard POSIX streams to be replaced in a process, which makes it easier to do things like capturing the output from a program into a string by writing a custom <code>IO.FS.Stream</code>.</p>
<p>The control flow in <code>dump</code> is essentially a <code>while</code> loop.
When <code>dump</code> is called, if the stream has reached the end of the file, <code>pure ()</code> terminates the function by returning the constructor for <code>Unit</code>.
If the stream has not yet reached the end of the file, one block is read, and its contents are written to <code>stdout</code>, after which <code>dump</code> calls itself directly.
The recursive calls continue until <code>stream.read</code> returns an empty byte array, which indicates that the end of the file has been reached.</p>
<p>When an <code>if</code> expression occurs as a statement in a <code>do</code>, as in <code>dump</code>, each branch of the <code>if</code> is implicitly provided with a <code>do</code>.
In other words, the sequence of steps following the <code>else</code> are treated as a sequence of <code>IO</code> actions to be executed, just as if they had a <code>do</code> at the beginning.
Names introduced with <code>let</code> in the branches of the <code>if</code> are visible only in their own branches, and are not in scope outside of the <code>if</code>.</p>
<p>There is no danger of running out of stack space while calling <code>dump</code> because the recursive call happens as the very last step in the function, and its result is returned directly rather than being manipulated or computed with.
This kind of recursion is called <em>tail recursion</em>, and will be described in more detail later in this book.
Because the compiled code does not need to retain any state, the Lean compiler can compile the recursive call to a jump.</p>
<p>If <code>feline</code> only redirected standard input to standard output, then <code>dump</code> would be sufficient.
However, it also needs to be able to open files that are provided as command-line arguments and emit their contents.
When its argument is the name of a file that exists, <code>fileStream</code> returns a stream that reads the file's contents.
When the argument is not a file, <code>fileStream</code> emits an error and returns <code>none</code>.</p>
<pre><code class="language-lean">def fileStream (filename : System.FilePath) : IO (Option IO.FS.Stream) := do
  let fileExists ← filename.pathExists
  if not fileExists then
    let stderr ← IO.getStderr
    stderr.putStrLn s!&quot;File not found: {filename}&quot;
    pure none
  else
    let handle ← IO.FS.Handle.mk filename IO.FS.Mode.read
    pure (some (IO.FS.Stream.ofHandle handle))
</code></pre>
<p>Opening a file as a stream takes two steps.
First, a file handle is created by opening the file in read mode.
A Lean file handle tracks an underlying file descriptor.
When there are no references to the file handle value, a finalizer closes the file descriptor.
Second, the file handle is given the same interface as a POSIX stream using <code>IO.FS.Stream.ofHandle</code>, which fills each field of the <code>Stream</code> structure with the corresponding <code>IO</code> action that works on file handles.</p>
<h3 id="handling-input"><a class="header" href="#handling-input">Handling Input</a></h3>
<p>The main loop of <code>feline</code> is another tail-recursive function, called <code>process</code>.
In order to return a non-zero exit code if any of the inputs could not be read, <code>process</code> takes an argument <code>exitCode</code> that represents the current exit code for the whole program.
Additionally, it takes a list of input files to be processed.</p>
<pre><code class="language-lean">def process (exitCode : UInt32) (args : List String) : IO UInt32 := do
  match args with
  | [] =&gt; pure exitCode
  | &quot;-&quot; :: args =&gt;
    let stdin ← IO.getStdin
    dump stdin
    process exitCode args
  | filename :: args =&gt;
    let stream ← fileStream ⟨filename⟩
    match stream with
    | none =&gt;
      process 1 args
    | some stream =&gt;
      dump stream
      process exitCode args
</code></pre>
<p>Just as with <code>if</code>, each branch of a <code>match</code> that is used as a statement in a <code>do</code> is implicitly provided with its own <code>do</code>.</p>
<p>There are three possibilities.
One is that no more files remain to be processed, in which case <code>process</code> returns the error code unchanged.
Another is that the specified filename is <code>&quot;-&quot;</code>, in which case <code>process</code> dumps the contents of the standard input and then processes the remaining filenames.
The final possibility is that an actual filename was specified.
In this case, <code>fileStream</code> is used to attempt to open the file as a POSIX stream.
Its argument is encased in <code>⟨ ... ⟩</code> because a <code>FilePath</code> is a single-field structure that contains a string.
If the file could not be opened, it is skipped, and the recursive call to <code>process</code> sets the exit code to <code>1</code>.
If it could, then it is dumped, and the recursive call to <code>process</code> leaves the exit code unchanged.</p>
<p><code>process</code> does not need to be marked <code>partial</code> because it is structurally recursive.
Each recursive call is provided with the tail of the input list, and all Lean lists are finite.
Thus, <code>process</code> does not introduce any non-termination itself.</p>
<h3 id="main"><a class="header" href="#main">Main</a></h3>
<p>The final step is to write the <code>main</code> action.
Unlike prior examples, <code>main</code> in <code>feline</code> is a function.
In Lean, <code>main</code> can have one of three types:</p>
<ul>
<li><code>main : IO Unit</code> corresponds to programs that cannot read their command-line arguments and always indicate success with an exit code of <code>0</code>,</li>
<li><code>main : IO UInt32</code> corresponds to <code>int main(void)</code> in C, for programs without arguments that return exit codes, and</li>
<li><code>main : List String → IO UInt32</code> corresponds to <code>int main(int argc, char **argv)</code> in C, for programs that take arguments and signal success or failure.</li>
</ul>
<p>If no arguments were provided, <code>feline</code> should read from standard input as if it were called with a single <code>&quot;-&quot;</code> argument.
Otherwise, the arguments should be processed one after the other.</p>
<pre><code class="language-lean">def main (args : List String) : IO UInt32 :=
  match args with
  | [] =&gt; process 0 [&quot;-&quot;]
  | _ =&gt;  process 0 args
</code></pre>
<h2 id="meow"><a class="header" href="#meow">Meow!</a></h2>
<p>To check whether <code>feline</code> works, the first step is to build it with <code>lake build</code>.
First off, when called without arguments, it should emit what it receives from standard input.
Check that</p>
<pre><code>echo &quot;It works!&quot; | ./build/bin/feline
</code></pre>
<p>emits <code>It works!</code>.</p>
<p>Secondly, when called with files as arguments, it should print them.
If the file <code>test1.txt</code> contains</p>
<pre><code>It's time to find a warm spot
</code></pre>
<p>and <code>test2.txt</code> contains</p>
<pre><code>and curl up!
</code></pre>
<p>then the command</p>
<pre><code>./build/bin/feline test1.txt test2.txt
</code></pre>
<p>should emit</p>
<pre><code>It's time to find a warm spot
and curl up!
</code></pre>
<p>Finally, the <code>-</code> argument should be handled appropriately.</p>
<pre><code>echo &quot;and purr&quot; | ./build/bin/feline test1.txt - test2.txt
</code></pre>
<p>should yield</p>
<pre><code>It's time to find a warm spot
and purr
and curl up!
</code></pre>
<h2 id="exercise-1"><a class="header" href="#exercise-1">Exercise</a></h2>
<p>Extend <code>feline</code> with support for usage information.
The extended version should accept a command-line argument <code>--help</code> that causes documentation about the available command-line options to be written to standard output.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="additional-conveniences-1"><a class="header" href="#additional-conveniences-1">Additional Conveniences</a></h1>
<h2 id="nested-actions"><a class="header" href="#nested-actions">Nested Actions</a></h2>
<p>Many of the functions in <code>feline</code> exhibit a repetitive pattern in which an <code>IO</code> action's result is given a name, and then used immediately and only once.
For instance, in <code>dump</code>:</p>
<pre><code class="language-lean">partial def dump (stream : IO.FS.Stream) : IO Unit := do
  let buf ← stream.read bufsize
  if buf.isEmpty then
    pure ()
  else
    let stdout ← IO.getStdout
    stdout.write buf
    dump stream
</code></pre>
<p>the pattern occurs for <code>stdout</code>:</p>
<pre><code class="language-lean">    let stdout ← IO.getStdout
    stdout.write buf
</code></pre>
<p>Similarly, <code>fileStream</code> contains the following snippet:</p>
<pre><code class="language-lean">  let fileExists ← filename.pathExists
  if not fileExists then
</code></pre>
<p>When Lean is compiling a <code>do</code> block, expressions that consist of a left arrow immediately under parentheses are lifted to the nearest enclosing <code>do</code>, and their results are bound to a unique name.
This unique name replaces the origin of the expression.
This means that <code>dump</code> can also be written as follows:</p>
<pre><code class="language-lean">partial def dump (stream : IO.FS.Stream) : IO Unit := do
  let buf ← stream.read bufsize
  if buf.isEmpty then
    pure ()
  else
    (← IO.getStdout).write buf
    dump stream
</code></pre>
<p>This version of <code>dump</code> avoids introducing names that are used only once, which can greatly simplify a program.
<code>IO</code> actions that Lean lifts from a nested expression context are called <em>nested actions</em>.</p>
<p><code>fileStream</code> can be simplified using the same technique:</p>
<pre><code class="language-lean">def fileStream (filename : System.FilePath) : IO (Option IO.FS.Stream) := do
  if not (← filename.pathExists) then
    (← IO.getStderr).putStrLn s!&quot;File not found: {filename}&quot;
    pure none
  else
    let handle ← IO.FS.Handle.mk filename IO.FS.Mode.read
    pure (some (IO.FS.Stream.ofHandle handle))
</code></pre>
<p>In this case, the local name of <code>handle</code> could also have been eliminated using nested actions, but the resulting expression would have been long and complicated.
Even though it's often good style to use nested actions, it can still sometimes be helpful to name intermediate results.</p>
<p>It is important to remember, however, that nested actions are only a shorter notation for <code>IO</code> actions that occur in a surrounding <code>do</code> block.
The side effects that are involved in executing them still occur in the same order, and execution of side effects is not interspersed with the evaluation of expressions.
For an example of where this might be confusing, consider the following helper definitions that return data after announcing to the world that they have been executed:</p>
<pre><code class="language-lean">def getNumA : IO Nat := do
  (← IO.getStdout).putStrLn &quot;A&quot;
  pure 5

def getNumB : IO Nat := do
  (← IO.getStdout).putStrLn &quot;B&quot;
  pure 7
</code></pre>
<p>These definitions are intended to stand in for more complicated <code>IO</code> code that might validate user input, read a database, or open a file.</p>
<p>A program that prints <code>0</code> when number A is five, or number <code>B</code> otherwise, can be written as follows:</p>
<pre><code class="language-lean">def test : IO Unit := do
  let a : Nat := if (← getNumA) == 5 then 0 else (← getNumB)
  (← IO.getStdout).putStrLn s!&quot;The answer is {a}&quot;
</code></pre>
<p>However, this program probably has more side effects (such as prompting for user input or reading a database) than was intended.
The definition of <code>getNumA</code> makes it clear that it will always return <code>5</code>, and thus the program should not read number B.
However, running the program results in the following output:</p>
<pre><code class="language-output info">A
B
The answer is 0
</code></pre>
<p><code>getNumB</code> was executed because <code>test</code> is equivalent to this definition:</p>
<pre><code class="language-lean">def test : IO Unit := do
  let x ← getNumA
  let y ← getNumB
  let a : Nat := if x == 5 then 0 else y
  (← IO.getStdout).putStrLn s!&quot;The answer is {a}&quot;
</code></pre>
<p>This is due to the rule that nested actions are lifted to the <em>closest enclosing</em> <code>do</code> block.
The branches of the <code>if</code> were not implicitly wrapped in <code>do</code> blocks because the <code>if</code> is not itself a statement in the <code>do</code> block—the statement is the <code>let</code> that defines <code>a</code>.
Indeed, they could not be wrapped this way, because the type of the conditional expression is <code>Nat</code>, not <code>IO Nat</code>.</p>
<h2 id="flexible-layouts-for-do"><a class="header" href="#flexible-layouts-for-do">Flexible Layouts for <code>do</code></a></h2>
<p>In Lean, <code>do</code> expressions are whitespace-sensitive.
Each <code>IO</code> action or local binding in the <code>do</code> is expected to start on its own line, and they should all have the same indentation.
Almost all uses of <code>do</code> should be written this way.
In some rare contexts, however, manual control over whitespace and indentation may be necessary, or it may be convenient to have multiple small actions on a single line.
In these cases, newlines can be replaced with a semicolon and indentation can be replaced with curly braces.</p>
<p>For instance, all of the following programs are equivalent:</p>
<pre><code class="language-lean">-- This version uses only whitespace-sensitive layout
def main : IO Unit := do
  let stdin ← IO.getStdin
  let stdout ← IO.getStdout

  stdout.putStrLn &quot;How would you like to be addressed?&quot;
  let name := (← stdin.getLine).dropRightWhile Char.isWhitespace
  stdout.putStrLn s!&quot;Hello, {name}!&quot;

-- This version is as explicit as possible
def main : IO Unit := do {
  let stdin ← IO.getStdin;
  let stdout ← IO.getStdout;

  stdout.putStrLn &quot;How would you like to be addressed?&quot;;
  let name := (← stdin.getLine).dropRightWhile Char.isWhitespace;
  stdout.putStrLn s!&quot;Hello, {name}!&quot;
}

-- This version uses a semicolon to put two actions on the same line
def main : IO Unit := do
  let stdin ← IO.getStdin; let stdout ← IO.getStdout

  stdout.putStrLn &quot;How would you like to be addressed?&quot;
  let name := (← stdin.getLine).dropRightWhile Char.isWhitespace
  stdout.putStrLn s!&quot;Hello, {name}!&quot;
</code></pre>
<p>Idiomatic Lean code uses curly braces with <code>do</code> very rarely.</p>
<h2 id="running-io-actions-with-eval"><a class="header" href="#running-io-actions-with-eval">Running <code>IO</code> Actions With <code>#eval</code></a></h2>
<p>Lean's <code>#eval</code> command can be used to execute <code>IO</code> actions, rather than just evaluating them.
Normally, adding a <code>#eval</code> command to a Lean file causes Lean to evaluate the provided expression, convert the resulting value to a string, and provide that string as a tooltip and in the info window.
Rather than failing because <code>IO</code> actions can't be converted to strings, <code>#eval</code> executes them, carrying out their side effects.
If the result of execution is the <code>Unit</code> value <code>()</code>, then no result string is shown, but if it is a type that can be converted to a string, then Lean displays the resulting value.</p>
<p>This means that, given the prior definitions of <code>countdown</code> and <code>runActions</code>,</p>
<pre><code class="language-lean">#eval runActions (countdown 3)
</code></pre>
<p>displays</p>
<pre><code class="language-output info">3
2
1
Blast off!
</code></pre>
<p>This is the output produced by running the <code>IO</code> action, rather than some opaque representation of the action itself.
In other words, for <code>IO</code> actions, <code>#eval</code> both <em>evaluates</em> the provided expression and <em>executes</em> the resulting action value.</p>
<p>Quickly testing <code>IO</code> actions with <code>#eval</code> can be much more convenient that compiling and running whole programs.
However, there are some limitations.
For instance, reading from standard input simply returns empty input.
Additionally, the <code>IO</code> action is re-executed whenever Lean needs to update the diagnostic information that it provides to users, and this can happen at unpredictable times.
An action that reads and writes files, for instance, may do so at inconvenient times.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summary-1"><a class="header" href="#summary-1">Summary</a></h1>
<h2 id="evaluation-vs-execution"><a class="header" href="#evaluation-vs-execution">Evaluation vs Execution</a></h2>
<p>Side effects are aspects of program execution that go beyond the evaluation of mathematical expressions, such as reading files, throwing exceptions, or triggering industrial machinery.
While most language allow side effects to occur during evaluation, Lean does not.
Instead, Lean has a type called <code>IO</code> that represents <em>descriptions</em> of programs that use side effects.
These descriptions are then executed by the language's run-time system, which invokes the Lean expression evaluator to carry out specific computations.
Values of type <code>IO α</code> are called <em><code>IO</code> actions</em>.
The simplest is <code>pure</code>, which returns its argument and has no actual side effects.</p>
<p><code>IO</code> actions can also be understood as functions that take the whole world as an argument and return a new world in which the side effect has occurred.
Behind the scenes, the <code>IO</code> library ensures that the world is never duplicated, created, or destroyed.
While this model of side effects cannot actually be implemented, as the whole universe is too big to fit in memory, the real world can be represented by a token that is passed around through the program.</p>
<p>An <code>IO</code> action <code>main</code> is executed when the program starts.
<code>main</code> can have one of three types:</p>
<ul>
<li><code>main : IO Unit</code> is used for simple programs that cannot read their command-line arguments and always return exit code <code>0</code>,</li>
<li><code>main : IO UInt32</code> is used for programs without arguments that may signal success or failure, and</li>
<li><code>main : List String → IO UInt32</code> is used for programs that take command-line arguments and signal success or failure.</li>
</ul>
<h2 id="do-notation"><a class="header" href="#do-notation"><code>do</code> Notation</a></h2>
<p>The Lean standard library provides a number of basic <code>IO</code> actions that represent effects such as reading from and writing to files and interacting with standard input and standard output.
These base <code>IO</code> actions are composed into larger <code>IO</code> actions using <code>do</code> notation, which is a built-in domain-specific language for writing descriptions of programs with side effects.
A <code>do</code> expression contains a sequence of <em>statements</em>, which may be:</p>
<ul>
<li>expressions that represent <code>IO</code> actions,</li>
<li>ordinary local definitions with <code>let</code> and <code>:=</code>, where the defined name refers to the value of the provided expression, or</li>
<li>local definitions with <code>let</code> and <code>←</code>, where the defined name refers to the result of executing the value of the provided expression.</li>
</ul>
<p><code>IO</code> actions that are written with <code>do</code> are executed one statement at a time.</p>
<p>Furthermore, <code>if</code> and <code>match</code> expressions that occur immediately under a <code>do</code> are implicitly considered to have their own <code>do</code> in each branch.
Inside of a <code>do</code> expression, <em>nested actions</em> are expressions with a left arrow immediately under parentheses.
The Lean compiler implicitly lifts them to the nearest enclosing <code>do</code>, which may be implicitly part of a branch of a <code>match</code> or <code>if</code> expression, and given a unique name.
This unique name then replaces the origin site of the nested action.</p>
<h2 id="compiling-and-running-programs"><a class="header" href="#compiling-and-running-programs">Compiling and Running Programs</a></h2>
<p>A Lean program that consists of a single file with a <code>main</code> definition can be run using <code>lean --run FILE</code>.
While this can be a nice way to get started with a simple program, most programs will eventually graduate to a multiple-file project that should be compiled before running.</p>
<p>Lean projects are organized into <em>packages</em>, which are collections of libraries and executables together with information about dependencies and a build configuration.
Packages are described using Lake, a Lean build tool.
Use <code>lake new</code> to create a Lake package in a new directory, or <code>lake init</code> to create one in the current directory.
Lake package configuration is another domain-specific language.
Use <code>lake build</code> to build a project.</p>
<h2 id="partiality"><a class="header" href="#partiality">Partiality</a></h2>
<p>One consequence of following the mathematical model of expression evaluation is that every expression must have a value.
This rules out both incomplete pattern matches that fail to cover all constructors of a datatype and programs that can fall into an infinite loop.
Lean ensures that all <code>match</code> expressions cover all cases, and that all recursive functions are either structurally recursive or have an explicit proof of termination.</p>
<p>However, some real programs require the possibility of looping infinitely, because they handle potentially-infinite data, such as POSIX streams.
Lean provides an escape hatch: functions whose definition is marked <code>partial</code> are not required to terminate.
This comes at a cost.
Because types are a first-class part of the Lean language, functions can return types.
Partial functions, however, are not evaluated during type checking, because an infinite loop in a function could cause the type checker to enter an infinite loop.
Furthermore, mathematical proofs are unable to inspect the definitions of partial functions, which means that programs that use them are much less amenable to formal proof.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interlude-propositions-proofs-and-indexing"><a class="header" href="#interlude-propositions-proofs-and-indexing">Interlude: Propositions, Proofs, and Indexing</a></h1>
<p>Like many languages, Lean uses square brackets for indexing into arrays and lists.
For instance, if <code>woodlandCritters</code> is defined as follows:</p>
<pre><code class="language-lean">def woodlandCritters : List String :=
  [&quot;hedgehog&quot;, &quot;deer&quot;, &quot;snail&quot;]
</code></pre>
<p>then the individual components can be extracted:</p>
<pre><code class="language-lean">def hedgehog := woodlandCritters[0]
def deer := woodlandCritters[1]
def snail := woodlandCritters[2]
</code></pre>
<p>However, attempting to extract the fourth element results in a compile-time error, rather than a run-time error:</p>
<pre><code class="language-lean">def oops := woodlandCritters[3]
</code></pre>
<pre><code class="language-output error">failed to prove index is valid, possible solutions:
  - Use `have`-expressions to prove the index is valid
  - Use `a[i]!` notation instead, runtime check is perfomed, and 'Panic' error message is produced if index is not valid
  - Use `a[i]?` notation instead, result is an `Option` type
  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid
⊢ 3 &lt; List.length woodlandCritters
</code></pre>
<p>This error message is saying Lean tried to automatically mathematically prove that <code>3 &lt; List.length woodlandCritters</code>, which would mean that the lookup was safe, but that it could not do so.
Out-of-bounds errors are a common class of bugs, and Lean uses its dual nature as a programming language and a theorem prover to rule out as many as possible.</p>
<p>Understanding how this works requires an understanding of three key ideas: propositions, proofs, and tactics.</p>
<h2 id="propositions-and-proofs"><a class="header" href="#propositions-and-proofs">Propositions and Proofs</a></h2>
<p>A <em>proposition</em> is a statement that can be true or false.
All of the following are propositions:</p>
<ul>
<li>1 + 1 = 2</li>
<li>Addition is commutative</li>
<li>There are infinitely many prime numbers</li>
<li>1 + 1 = 15</li>
<li>Paris is the capital of France</li>
<li>Buenos Aires is the capital of South Korea</li>
<li>All birds can fly</li>
</ul>
<p>On the other hand, nonsense statements are not propositions.
None of the following are propositions:</p>
<ul>
<li>1 + green = ice cream</li>
<li>All capital cities are prime numbers</li>
<li>At least one gorg is a fleep</li>
</ul>
<p>Propositions come in two varieties: those that are purely mathematical, relying only on our definitions of concepts, and those that are facts about the world.
Theorem provers like Lean are concerned with the former category, and have nothing to say about the flight capabilities of penguins or the legal status of cities.</p>
<p>A <em>proof</em> is a convincing argument that a proposition is true.
For mathematical propositions, these arguments make use of the definitions of the concepts that are involved as well as the rules of logical argumentation.
Most proofs are written for people to understand, and leave out many tedious details.
Computer-aided theorem provers like Lean are designed to allow mathematicians to write proofs while omitting many details, while the software fills in the missing explicit steps, decreasing the likelihood of oversights or mistakes.</p>
<p>In Lean, a program's type describes the ways it can be interacted with.
For instance, a program of type <code>Nat → List String</code> is a function that takes a <code>Nat</code> argument and produces a list of strings.
In other words, each type specifies what counts as a program with that type.</p>
<p>In Lean, propositions are a kind of type that describes what counts as evidence that it is true.
The proposition is proved by providing this evidence.
On the other hand, if the proposition is false, then it will be impossible to construct this evidence.</p>
<p>For example, the proposition &quot;1 + 1 = 2&quot; can be written directly in Lean.
The evidence for this proposition is the constructor <code>rfl</code>, which is short for <em>reflexivity</em>:</p>
<pre><code class="language-lean">def onePlusOneIsTwo : 1 + 1 = 2 := rfl
</code></pre>
<p>On the other hand, <code>rfl</code> does not prove the false proposition &quot;1 + 1 = 15&quot;:</p>
<pre><code class="language-lean">def onePlusOneIsFifteen : 1 + 1 = 15 := rfl
</code></pre>
<pre><code class="language-output error">type mismatch
  rfl
has type
  1 + 1 = 1 + 1 : Prop
but is expected to have type
  1 + 1 = 15 : Prop
</code></pre>
<p>This error message indicates that <code>rfl</code> can prove that two expressions are equal when both sides of the equality statement are already the same number.
Because <code>1 + 1</code> evaluates directly to <code>2</code>, they are considered to be the same, which allows <code>onePlusOneIsTwo</code> to be accepted.
Just as <code>Type</code> describes types such as <code>Nat</code>, <code>String</code>, and <code>List (Nat × String × (Int → Float))</code> that represent data structures and functions, <code>Prop</code> describes propositions.</p>
<p>When a proposition has been proven, it is called a <em>theorem</em>.
In Lean, it is conventional to declare theorems with the <code>theorem</code> keyword instead of <code>def</code>.
This helps readers see which declarations are intended to be read as mathematical proofs, and which are definitions.
Generally speaking, with a proof, what matters is that there is evidence that a proposition is true, but it's not particularly important <em>which</em> evidence was provided.
With definitions, on the other hand, it matters very much which particular value is selected—after all, a definition of addition that always returns <code>0</code> is clearly wrong.</p>
<p>The prior example could be rewritten as follows:</p>
<pre><code class="language-lean">def OnePlusOneIsTwo : Prop := 1 + 1 = 2

theorem onePlusOneIsTwo : OnePlusOneIsTwo := rfl
</code></pre>
<h2 id="tactics"><a class="header" href="#tactics">Tactics</a></h2>
<p>Proofs are normally written using <em>tactics</em>, rather than by providing evidence directly.
Tactics are small programs that construct evidence for a proposition.
These programs run in a <em>proof state</em> that tracks the statement that is to be proved (called the <em>goal</em>) along with the assumptions that are available to prove it.
Running a tactic on a goal results in a new proof state that contains new goals.
The proof is complete when all goals have been proven.</p>
<p>To write a proof with tactics, begin the definition with <code>by</code>.
Writing <code>by</code> puts Lean into tactic mode until the end of the next indented block.
While in tactic mode, Lean provides ongoing feedback about the current proof state.
Written with tactics, <code>onePlusOneIsTwo</code> is still quite short:</p>
<pre><code class="language-lean">theorem onePlusOneIsTwo : 1 + 1 = 2 := by
  simp
</code></pre>
<p>The <code>simp</code> tactic, short for &quot;simplify&quot;, is the workhorse of Lean proofs.
It rewrites the goal to as simple a form as possible, taking care of parts of the proof that are small enough.
In particular, it proves simple equality statements.
Behind the scenes, a detailed formal proof is constructed, but using <code>simp</code> hides this complexity.</p>
<p>Tactics are useful for a number of reasons:</p>
<ol>
<li>Many proofs are complicated and tedious when written out down to the smallest detail, and tactics can automate these uninteresting parts.</li>
<li>Proofs written with tactics are easier to maintain over time, because flexible automation can paper over small changes to definitions.</li>
<li>Because a single tactic can prove many different theorems, Lean can use tactics behind the scenes to free users from writing proofs by hand. For instance, an array lookup requires a proof that the index is in bounds, and a tactic can typically construct that proof without the user needing to worry about it.</li>
</ol>
<p>Behind the scenes, indexing notation uses a tactic to prove that the user's lookup operation is safe.
This tactic is <code>simp</code>, configured to take certain arithmetic identities into account.</p>
<h2 id="connectives"><a class="header" href="#connectives">Connectives</a></h2>
<p>The basic building blocks of logic, such as &quot;and&quot;, &quot;or&quot;, &quot;true&quot;, &quot;false&quot;, and &quot;not&quot;, are called <em>logical connectives</em>.
Each connective defines what counts as evidence of its truth.
For example, to prove a statement &quot;<em>A</em> and <em>B</em>&quot;, one must prove both <em>A</em> and <em>B</em>.
This means that evidence for &quot;<em>A</em> and <em>B</em>&quot; is a pair that contains both evidence for <em>A</em> and evidence for <em>B</em>.
Similarly, evidence for &quot;<em>A</em> or <em>B</em>&quot; consists of either evidence for <em>A</em> or evidence for <em>B</em>.</p>
<p>In particular, most of these connectives are defined like datatypes, and they have constructors.
If <code>A</code> and <code>B</code> are propositions, then &quot;<code>A</code> and <code>B</code>&quot; (written <code>A ∧ B</code>) is a proposition.
Evidence for <code>A ∧ B</code> consists of the constructor <code>And.intro</code>, which has the type <code>A → B → A ∧ B</code>.
Replacing <code>A</code> and <code>B</code> with concrete propositions, it is possible to prove <code>1 + 1 = 2 ∧ &quot;Str&quot;.append &quot;ing&quot; = &quot;String&quot;</code> with <code>And.intro rfl rfl</code>.
Of course, <code>simp</code> is also powerful enough to find this proof:</p>
<pre><code class="language-lean">theorem addAndAppend : 1 + 1 = 2 ∧ &quot;Str&quot;.append &quot;ing&quot; = &quot;String&quot; := by simp
</code></pre>
<p>Similarly, &quot;<code>A</code> or <code>B</code>&quot; (written <code>A ∨ B</code>) has two constructors, because a proof of &quot;<code>A</code> or <code>B</code>&quot; requires only that one of the two underlying propositions be true.
There are two constructors: <code>Or.inl</code>, with type <code>A → A ∨ B</code>, and <code>Or.inr</code>, with type <code>B → A ∨ B</code>.</p>
<p>Implication (if <em>A</em> then <em>B</em>) is represented using functions.
In particular, a function that transforms evidence for <em>A</em> into evidence for <em>B</em> is itself evidence that <em>A</em> implies <em>B</em>.
This is different from the usual description of implication, in which <code>A → B</code> is shorthand for <code>¬A ∨ B</code>, but the two formulations are equivalent.</p>
<p>Because evidence for an &quot;and&quot; is a constructor, it can be used with pattern matching.
For instance, a proof that <em>A</em> and <em>B</em> implies <em>A</em> or <em>B</em> is a function that pulls the evidence of <em>A</em> (or of <em>B</em>) out of the evidence for <em>A</em> and <em>B</em>, and then uses this evidence to produce evidence of <em>A</em> or <em>B</em>:</p>
<pre><code class="language-lean">theorem andImpliesOr : A ∧ B → A ∨ B :=
  fun andEvidence =&gt;
    match andEvidence with
    | And.intro a b =&gt; Or.inl a
</code></pre>
<table><thead><tr><th>Connective</th><th>Lean Syntax</th><th>Evidence</th></tr></thead><tbody>
<tr><td>True</td><td><code>True</code></td><td><code>True.intro : True</code></td></tr>
<tr><td>False</td><td><code>False</code></td><td>No evidence</td></tr>
<tr><td><em>A</em> and <em>B</em></td><td><code>A ∧ B</code></td><td><code>And.intro : A → B → A ∧ B</code></td></tr>
<tr><td><em>A</em> or <em>B</em></td><td><code>A ∨ B</code></td><td>Either <code>Or.inl : A → A ∨ B</code> or <code>Or.inr : B → A ∨ B</code></td></tr>
<tr><td><em>A</em> implies <em>B</em></td><td><code>A → B</code></td><td>A function that transforms evidence of <em>A</em> into evidence of <em>B</em></td></tr>
<tr><td>not <em>A</em></td><td><code>¬A</code></td><td>A function that would transform evidence of <em>A</em> into evidence of <code>False</code></td></tr>
</tbody></table>
<p>The <code>simp</code> tactic can prove theorems that use these connectives.
For example:</p>
<pre><code class="language-lean">theorem onePlusOneAndLessThan : 1 + 1 = 2 ∨ 3 &lt; 5 := by simp
theorem notTwoEqualFive : ¬(1 + 1 = 5) := by simp
theorem trueIsTrue : True := True.intro
theorem trueOrFalse : True ∨ False := by simp
theorem falseImpliesTrue : False → True := by simp
</code></pre>
<h2 id="evidence-as-arguments"><a class="header" href="#evidence-as-arguments">Evidence as Arguments</a></h2>
<p>While <code>simp</code> does a great job proving propositions that involve equalities and inequalities of specific numbers, it is not very good at proving statements that involve variables.
For instance, <code>simp</code> can prove that <code>4 &lt; 15</code>, but it can't easily tell that because <code>x &lt; 4</code>, it's also true that <code>x &lt; 15</code>.
Because index notation uses <code>simp</code> behind the scenes to prove that array access is safe, it can require a bit of hand-holding.</p>
<p>One of the easiest ways to make indexing notation work well is to have the function that performs a lookup into a data structure take the required evidence of safety as an argument.
For instance, a function that returns the third entry in a list is not generally safe because lists might contain zero, one, or two entries:</p>
<pre><code class="language-lean">def third (xs : List α) : α := xs[2]
</code></pre>
<pre><code class="language-output error">failed to prove index is valid, possible solutions:
  - Use `have`-expressions to prove the index is valid
  - Use `a[i]!` notation instead, runtime check is perfomed, and 'Panic' error message is produced if index is not valid
  - Use `a[i]?` notation instead, result is an `Option` type
  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid
α : Type ?u.3872
xs : List α
⊢ 2 &lt; List.length xs
</code></pre>
<p>However, the obligation to show that the list has at least three entries can be imposed on the caller by adding an argument that consists of evidence that the indexing operation is safe:</p>
<pre><code class="language-lean">def third (xs : List α) (ok : xs.length &gt; 2) : α := xs[2]
</code></pre>
<p>When the function is called on a concrete list, its length is known.
In these cases, <code>by simp</code> can construct the evidence automatically:</p>
<pre><code class="language-lean">#eval third woodlandCritters (by simp)
</code></pre>
<pre><code class="language-output info">&quot;snail&quot;
</code></pre>
<h2 id="indexing-without-evidence"><a class="header" href="#indexing-without-evidence">Indexing Without Evidence</a></h2>
<p>In cases where it's not practical to prove that an indexing operation is in bounds, there are other alternatives.
Adding an question mark results in an <code>Option</code>, where the result is <code>some</code> if the index is in bounds, and <code>none</code> otherwise.
For example:</p>
<pre><code class="language-lean">def thirdOption (xs : List α) : Option α := xs[2]?

#eval thirdOption woodlandCritters
</code></pre>
<pre><code class="language-output info">some &quot;snail&quot;
</code></pre>
<pre><code class="language-lean">#eval thirdOption [&quot;only&quot;, &quot;two&quot;]
</code></pre>
<pre><code class="language-output info">none
</code></pre>
<p>There is also a version that crashes the program when the index is out of bounds:</p>
<pre><code class="language-lean">#eval woodlandCritters[1]!
</code></pre>
<pre><code class="language-output info">&quot;deer&quot;
</code></pre>
<p>Be careful!
Because code that is run with <code>#eval</code> runs in the context of the Lean compiler, selecting the wrong index can crash your IDE.</p>
<h2 id="messages-you-may-meet-3"><a class="header" href="#messages-you-may-meet-3">Messages You May Meet</a></h2>
<p>In addition to the error that occurs when Lean is unable to find compile-time evidence that an indexing operation is safe, polymorphic functions that use unsafe indexing may produce the following message:</p>
<pre><code class="language-lean">def unsafeThird (xs : List α) : α := xs[2]!
</code></pre>
<pre><code class="language-output error">failed to synthesize instance
  Inhabited α
</code></pre>
<p>This is due to a technical restriction that is part of keeping Lean usable as both a logic for proving theorems and a programming language.
In particular, only programs whose types contain at least one value are allowed to crash.
This is because a proposition in Lean is a kind of type that classifies evidence of its truth.
False propositions have no such evidence.
If a program with an empty type could crash, then that crashing program could be used as a kind of fake evidence for a false proposition.</p>
<p>Internally, Lean contains a table of types that are known to have at least one value.
This error is saying that some arbitrary type <code>α</code> is not necessarily in that table.
The next chapter describes how to add to this table, and how to successfully write functions like <code>unsafeThird</code>.</p>
<p>Adding whitespace between a list and the brackets used for lookup can cause another message:</p>
<pre><code class="language-lean">#eval woodlandCritters [1]
</code></pre>
<pre><code class="language-output error">function expected at
  woodlandCritters
term has type
  List String
</code></pre>
<p>Adding a space causes Lean to treat the expression as a function application, and the index as a list that contains a single number.
This error message results from having Lean attempt to treat <code>woodlandCritters</code> as a function.</p>
<h2 id="exercises-4"><a class="header" href="#exercises-4">Exercises</a></h2>
<ul>
<li>Prove the following theorems using <code>rfl</code>: <code>2 + 3 = 5</code>, <code>15 - 8 = 7</code>, <code>&quot;Hello, &quot;.append &quot;world&quot; = &quot;Hello, world&quot;</code>, <code>5 &lt; 18</code>.</li>
<li>Prove the following theorems using <code>by simp</code>: <code>2 + 3 = 5</code>, <code>15 - 8 = 7</code>, <code>&quot;Hello, &quot;.append &quot;world&quot; = &quot;Hello, world&quot;</code>, <code>5 &lt; 18</code>.</li>
<li>Write a function that looks up the fifth entry in a list. Pass the evidence that this lookup is safe as an argument to the function.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overloading-and-type-classes"><a class="header" href="#overloading-and-type-classes">Overloading and Type Classes</a></h1>
<p>In many languages, the built-in datatypes get special treatment.
For example, in C and Java, <code>+</code> can be used to add <code>float</code>s and <code>int</code>s, but not arbitrary-precision numbers from a third-party library.
Similarly, numeric literals can be used directly for the built-in types, but not for user-defined number types.
Other languages provide an <em>overloading</em> mechanism for operators, where the same operator can be given a meaning for a new type.
In these languages, such as C++ and C#, a wide variety of built-in operators can be overloaded, and the compiler uses the type checker to select a particular implementation.</p>
<p>In addition to numeric literals and operators, many languages allow overloading of functions or methods.
In C++, Java, C# and Kotlin, multiple implementations of a method are allowed, with differing numbers and types of arguments.
The compiler uses the number of arguments and their types to determine which overload was intended.</p>
<p>Function and operator overloading has a key limitation: polymorphic functions can't restrict their type arguments to types for which a given overload exists.
That is, there is no way to write a function that works for any type that has addition defined.
Instead, this function must itself be overloaded for each type that has addition, resulting in many boilerplate definitions instead of a single polymorphic definition.
Another consequence of this restriction is that some operators (such as equality in Java) end up being defined for <em>every</em> combination of arguments, even when it is not necessarily sensible to do so.
If programmers are not very careful, this can lead to programs that crash at runtime or silently compute an incorrect result.</p>
<p>Lean implements overloading using a mechanism called <em>type classes</em>, pioneered in Haskell, that allows overloading of operators, functions, and literals in a manner that works well with polymorphism.
A type class describes a collection of overloadable operations.
To overload these operations for a new type, an <em>instance</em> is created that contains an implementation of each operation for the new type.
For example, a type class named <code>Add</code> describes types that allow addition, and an instance of <code>Add</code> for <code>Nat</code> provides an implementation of addition for <code>Nat</code>.</p>
<p>The terms <em>class</em> and <em>instance</em> can be confusing for those who are used to object-oriented languages, because they are not closely related to classes and instances in object-oriented languages.
However, they do share common roots: in everyday language, the term &quot;class&quot; refers to a group that shares some common attributes.
While classes in object-oriented programming certainly describe groups of objects with common attributes, the term additionally refers to a specific mechanism in a programming language for describing such a group.
Type classes are also a means of describing types that share common attributes (namely, implementations of certain operations), but they don't really have anything else in common with classes as found in object-oriented programming.
A Lean type class is much more analogous to a Java or C# <em>interface</em>.
Similarly, instances of type classes describe how to implement a given interface for a type, while the term &quot;instance&quot; is used to describe values with a given type in object-oriented programming.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="positive-numbers"><a class="header" href="#positive-numbers">Positive Numbers</a></h1>
<p>In some applications, only positive numbers make sense.
For example, compilers and interpreters typically use one-indexed line and column numbers for source positions, and a datatype that represents only non-empty lists will never report a length of zero.
Rather than relying on natural numbers, and littering the code with assertions that the number is not zero, it can be useful to design a datatype that represents only positive numbers.</p>
<p>One way to represent positive numbers is very similar to <code>Nat</code>, except with <code>one</code> as the base case instead of <code>zero</code>:</p>
<pre><code class="language-lean">inductive Pos : Type where
  | one : Pos
  | succ : Pos → Pos
</code></pre>
<p>This datatype represents exactly the intended set of values, but it is not very convenient to use.
For example, numeric literals are rejected:</p>
<pre><code class="language-lean">def seven : Pos := 7
</code></pre>
<pre><code class="language-output error">failed to synthesize instance
  OfNat Pos 7
</code></pre>
<p>Instead, the constructors must be used directly:</p>
<pre><code class="language-lean">def seven : Pos :=
  Pos.succ (Pos.succ (Pos.succ (Pos.succ (Pos.succ (Pos.succ Pos.one)))))
</code></pre>
<p>Similarly, addition and multiplication are not easy to use:</p>
<pre><code class="language-lean">def fourteen : Pos := seven + seven
</code></pre>
<pre><code class="language-output error">failed to synthesize instance
  HAdd Pos Pos ?m.299
</code></pre>
<pre><code class="language-lean">def fortyNine : Pos := seven * seven
</code></pre>
<pre><code class="language-output error">failed to synthesize instance
  HMul Pos Pos ?m.299
</code></pre>
<p>Each of these error messages begins with <code>failed to synthesize instance</code>.
This indicates that the error is due to an overloaded operation that has not been implemented, and it describes the type class that must be implemented.</p>
<h2 id="classes-and-instances"><a class="header" href="#classes-and-instances">Classes and Instances</a></h2>
<p>A type class consists of a name, some parameters, and a collection of <em>methods</em>.
The parameters describe the types for which overloadable operations are being defined, and the methods are the names and type signatures of the overloadable operations.
Once again, there is a terminology clash with object-oriented languages.
In object-oriented programming, a method is essentially a function that is connected to a particular object in memory, with special access to the object's private state.
Objects are interacted with via their methods.
In Lean, the term &quot;method&quot; refers to an operation that has been declared to be overloadable, with no special connection to objects or values or private fields.</p>
<p>One way to overload addition is to define a type class named <code>Plus</code>, with an addition method named <code>plus</code>.
Once an instance of <code>Plus</code> for <code>Nat</code> has been defined, it becomes possible to add two <code>Nat</code>s using <code>Plus.plus</code>:</p>
<pre><code class="language-lean">#eval Plus.plus 5 3
</code></pre>
<pre><code class="language-output info">8
</code></pre>
<p>Adding more instances allows <code>Plus.plus</code> to take more types of arguments.</p>
<p>In the following type class declaration, <code>Plus</code> is the name of the class, <code>α : Type</code> is the only argument, and <code>plus : α → α → α</code> is the only method:</p>
<pre><code class="language-lean">class Plus (α : Type) where
  plus : α → α → α
</code></pre>
<p>This declaration says that there is a type class <code>Plus</code> that overloads operations with respect to a type <code>α</code>.
In particular, there is one overloaded operation called <code>plus</code> that takes two <code>α</code>s and returns an <code>α</code>.</p>
<p>Type classes are first class, just as types are first class.
In particular, a type class is another kind of type.
The type of <code>Plus</code> is <code>Type → Type</code>, because it takes a type as an argument (<code>α</code>) and results in a new type that describes the overloading of <code>Plus</code>'s operation for <code>α</code>.</p>
<p>To overload <code>plus</code> for a particular type, write an instance:</p>
<pre><code class="language-lean">instance : Plus Nat where
  plus := Nat.add
</code></pre>
<p>The colon after <code>instance</code> indicates that <code>Plus Nat</code> is indeed a type.
Each method of class <code>Plus</code> should be assigned a value using <code>:=</code>.
In this case, there is only one method: <code>plus</code>.</p>
<p>By default, type class methods are defined in a namespace with the same name as the type class.
It can be convenient to <code>open</code> the namespace so that users don't need to type the name of the class first.
Parentheses in an <code>open</code> command indicate that only the indicated names from the namespace are to be made accessible:</p>
<pre><code class="language-lean">open Plus (plus)

#eval plus 5 3
</code></pre>
<pre><code class="language-output info">8
</code></pre>
<p>Defining an addition function for <code>Pos</code> and an instance of <code>Plus Pos</code> allows <code>plus</code> to be used to add both <code>Pos</code> and <code>Nat</code> values:</p>
<pre><code class="language-lean">def Pos.plus : Pos → Pos → Pos
  | Pos.one, k =&gt; Pos.succ k
  | Pos.succ n, k =&gt; Pos.succ (n.plus k)

instance : Plus Pos where
  plus := Pos.plus

def fourteen : Pos := plus seven seven
</code></pre>
<p>Because there is not yet an instance of <code>Plus Float</code>, attempting to add two floating-point numbers with <code>plus</code> fails with a familiar message:</p>
<pre><code class="language-lean">#eval plus 5.2 917.25861
</code></pre>
<pre><code class="language-output error">failed to synthesize instance
  Plus Float
</code></pre>
<p>These errors mean that Lean was unable to find an instance for a given type class.</p>
<h2 id="overloaded-addition"><a class="header" href="#overloaded-addition">Overloaded Addition</a></h2>
<p>Lean's built-in addition operator is syntactic sugar for a type class called <code>HAdd</code>, which flexibly allows the arguments to addition to have different types.
<code>HAdd</code> is short for <em>heterogeneous addition</em>.
For example, an <code>HAdd</code> instance can be written to allow a <code>Nat</code> to be added to a <code>Float</code>, resulting in a new <code>Float</code>.
When a programmer writes <code>x + y</code>, it is interpreted as meaning <code>HAdd.hAdd x y</code>.</p>
<p>While an understanding of the full generality of <code>HAdd</code> relies on features that are discussed in <a href="type-classes/out-params.html">another section in this chapter</a>, there is a simpler type class called <code>Add</code> that does not allow the types of the arguments to be mixed.
The Lean libraries are set up so that an instance of <code>Add</code> will be found when searching for an instance of <code>HAdd</code> in which both arguments have the same type.</p>
<p>Defining an instance of <code>Add Pos</code> allows <code>Pos</code> values to use ordinary addition syntax:</p>
<pre><code class="language-lean">instance : Add Pos where
  add := Pos.plus

def fourteen : Pos := seven + seven
</code></pre>
<h2 id="conversion-to-strings"><a class="header" href="#conversion-to-strings">Conversion to Strings</a></h2>
<p>Another useful built-in class is called <code>ToString</code>.
Instances of <code>ToString</code> provide a standard way of converting values from a given type into strings.
For example, a <code>ToString</code> instance is used when a value occurs in an interpolated string, and it determines how the <code>IO.println</code> function used at the <a href="type-classes/../hello-world/running-a-program.html#running-a-program">beginning of the description of <code>IO</code></a> will display a value.</p>
<p>For example, one way to convert a <code>Pos</code> into a <code>String</code> is to reveal its inner structure.
The function <code>posToString</code> takes a <code>Bool</code> that determines whether to parenthesize uses of <code>Pos.succ</code>, which should be <code>true</code> in the initial call to the function and <code>false</code> in all recursive calls.</p>
<pre><code class="language-lean">def posToString (atTop : Bool) (p : Pos) : String :=
  let paren s := if atTop then s else &quot;(&quot; ++ s ++ &quot;)&quot;
  match p with
  | Pos.one =&gt; &quot;Pos.one&quot;
  | Pos.succ n =&gt; paren s!&quot;Pos.succ {posToString false n}&quot;
</code></pre>
<p>Using this function for a <code>ToString</code> instance:</p>
<pre><code class="language-lean">instance : ToString Pos where
  toString := posToString true
</code></pre>
<p>results in informative, yet overwhelming, output:</p>
<pre><code class="language-lean">#eval s!&quot;There are {seven}&quot;
</code></pre>
<pre><code class="language-output info">&quot;There are Pos.succ (Pos.succ (Pos.succ (Pos.succ (Pos.succ (Pos.succ Pos.one)))))&quot;
</code></pre>
<p>On the other hand, every positive number has a corresponding <code>Nat</code>.
Converting it to a <code>Nat</code> and then using the <code>ToString Nat</code> instance (that is, the overloading of <code>toString</code> for <code>Nat</code>) is a quick way to generate much shorter output:</p>
<pre><code class="language-lean">def Pos.toNat : Pos → Nat
  | Pos.one =&gt; 1
  | Pos.succ n =&gt; n.toNat + 1

instance : ToString Pos where
  toString x := toString (x.toNat)

#eval s!&quot;There are {seven}&quot;
</code></pre>
<pre><code class="language-output info">&quot;There are 7&quot;
</code></pre>
<p>When more than one instance is defined, the most recent takes precedence.
Additionally, if a type has a <code>ToString</code> instance, then it can be used to display the result of <code>#eval</code> even if the type in question was not defined with <code>deriving Repr</code>, so <code>#eval seven</code> outputs <code>7</code>.</p>
<h2 id="overloaded-multiplication"><a class="header" href="#overloaded-multiplication">Overloaded Multiplication</a></h2>
<p>For multiplication, there is a type class called <code>HMul</code> that allows mixed argument types, just like <code>HAdd</code>.
Just as <code>x + y</code> is interpreted as <code>HAdd.hAdd x y</code>, <code>x * y</code> is interpreted as <code>HMul.hMul x y</code>.
For the common case of multiplication of two arguments with the same type, a <code>Mul</code> instance suffices.</p>
<p>An instance of <code>Mul</code> allows ordinary multiplication syntax to be used with <code>Pos</code>:</p>
<pre><code class="language-lean">def Pos.mul : Pos → Pos → Pos
  | Pos.one, k =&gt; k
  | Pos.succ n, k =&gt; n.mul k + k

instance : Mul Pos where
  mul := Pos.mul
</code></pre>
<p>With this instance, multiplication works as expected:</p>
<pre><code class="language-lean">#eval [seven * Pos.one,
       seven * seven,
       Pos.succ Pos.one * seven]
</code></pre>
<pre><code class="language-output info">[7, 49, 14]
</code></pre>
<h2 id="literal-numbers"><a class="header" href="#literal-numbers">Literal Numbers</a></h2>
<p>It is quite inconvenient to write out a sequence of constructors for positive numbers.
One way to work around the problem would be to provide a function to convert a <code>Nat</code> into a <code>Pos</code>.
However, this approach has downsides.
First off, because <code>Pos</code> cannot represent <code>0</code>, the resulting function would either convert a <code>Nat</code> to a bigger number, or it would return <code>Option Nat</code>.
Neither is particularly convenient for users.
Secondly, the need to call the function explicitly would make programs that use positive numbers much less convenient to write than programs that use <code>Nat</code>.
Having a trade-off between precise types and convenient APIs means that the precise types become less useful.</p>
<p>In Lean, natural number literals are interpreted using a type class called <code>OfNat</code>:</p>
<pre><code class="language-lean">class OfNat (α : Type) (_ : Nat) where
  ofNat : α
</code></pre>
<p>This type class takes two arguments: <code>α</code> is the type for which a natural number is overloaded, and the unnamed <code>Nat</code> argument is the actual literal number that was encountered in the program.
The method <code>ofNat</code> is then used as the value of the numeric literal.
Because the class contains the <code>Nat</code> argument, it becomes possible to define only instances for those values where the number makes sense.</p>
<p><code>OfNat</code> demonstrates that the arguments to type classes do not need to be types.
Because types in Lean are first-class participants in the language that can be passed as arguments to functions and given definitions with <code>def</code> and <code>abbrev</code>, there is no barrier that prevents non-type arguments in positions where a less-flexible language could not permit them.
This flexibility allows overloaded operations to be provided for particular values as well as particular types.</p>
<p>For example, a sum type that represents natural numbers less than four can be defined as follows:</p>
<pre><code class="language-lean">inductive LT4 where
  | zero
  | one
  | two
  | three
deriving Repr
</code></pre>
<p>While it would not make sense to allow <em>any</em> literal number to be used for this type, numbers less than four clearly make sense:</p>
<pre><code class="language-lean">instance : OfNat LT4 0 where
  ofNat := LT4.zero

instance : OfNat LT4 1 where
  ofNat := LT4.one

instance : OfNat LT4 2 where
  ofNat := LT4.two

instance : OfNat LT4 3 where
  ofNat := LT4.three
</code></pre>
<p>With these instances, the following examples work:</p>
<pre><code class="language-lean">#eval (3 : LT4)
</code></pre>
<pre><code class="language-output info">LT4.three
</code></pre>
<pre><code class="language-lean">#eval (0 : LT4)
</code></pre>
<pre><code class="language-output info">LT4.zero
</code></pre>
<p>On the other hand, out-of-bounds literals are still not allowed:</p>
<pre><code class="language-lean">#eval (4 : LT4)
</code></pre>
<pre><code class="language-output error">failed to synthesize instance
OfNat LT4 4
</code></pre>
<p>For <code>Pos</code>, the <code>OfNat</code> instance should work for <em>any</em> <code>Nat</code> other than <code>Nat.zero</code>.
Another way to phrase this is to say that for all natural numbers <code>n</code>, the instance should work for <code>n + 1</code>.
Just as names like <code>α</code> automatically become implicit arguments to functions that Lean fills out on its own, instances can take automatic implicit arguments.
In this instance, the argument <code>n</code> stands for any <code>Nat</code>, and the instance is defined for a <code>Nat</code> that's one greater:</p>
<pre><code class="language-lean">instance : OfNat Pos (n + 1) where
  ofNat :=
    let rec natPlusOne : Nat → Pos
      | 0 =&gt; Pos.one
      | k + 1 =&gt; Pos.succ (natPlusOne k)
    natPlusOne n
</code></pre>
<p>Because <code>n</code> stands for a <code>Nat</code> that's one less than what the user wrote, the helper function <code>natPlusOne</code> returns a <code>Pos</code> that's one greater than its argument.
This makes it possible to use natural number literals for positive numbers, but not for zero:</p>
<pre><code class="language-lean">def eight : Pos := 8

def zero : Pos := 0
</code></pre>
<pre><code class="language-output error">failed to synthesize instance
  OfNat Pos 0
</code></pre>
<h2 id="exercises-5"><a class="header" href="#exercises-5">Exercises</a></h2>
<h3 id="another-representation"><a class="header" href="#another-representation">Another Representation</a></h3>
<p>An alternative way to represent a positive number is as the successor of some <code>Nat</code>.
Replace the definition of <code>Pos</code> with the following structure:</p>
<pre><code class="language-lean">structure Pos where
  succ ::
  pred : Nat
</code></pre>
<p>Define instances of <code>Add</code>, <code>Mul</code>, <code>ToString</code>, and <code>OfNat</code> that allow this version of <code>Pos</code> to be used conveniently.</p>
<h3 id="even-numbers"><a class="header" href="#even-numbers">Even Numbers</a></h3>
<p>Define a datatype that represents only even numbers. Define instances of <code>Add</code>, <code>Mul</code>, and <code>ToString</code> that allow it to be used conveniently. <code>OfNat</code> requires a feature that is introduced in <a href="type-classes/polymorphism.html">the next section</a>.</p>
<h3 id="http-requests"><a class="header" href="#http-requests">HTTP Requests</a></h3>
<p>An HTTP request begins with an identification of a HTTP method, such as <code>GET</code> or <code>POST</code>, along with a URI and an HTTP version.
Define an inductive type that represents an interesting subset of the HTTP methods, and a structure that represents HTTP responses.
Responses should have a <code>ToString</code> instance that makes it possible to debug them.
Use a type class to associate different <code>IO</code> actions with each HTTP method, and write a test harness as an <code>IO</code> action that calls each method and prints the result.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-classes-and-polymorphism"><a class="header" href="#type-classes-and-polymorphism">Type Classes and Polymorphism</a></h1>
<p>It can be useful to write functions that work for <em>any</em> overloading of a given function.
For instance, <code>IO.println</code> works for any type that has an instance of <code>ToString</code>.
This is indicated using square brackets around the required instance: the type of <code>IO.println</code> is <code>{α : Type} → [ToString α] → α → IO Unit</code>.
This type says that <code>IO.println</code> accepts an argument of type <code>α</code>, which Lean should determine automatically, and that there must be a <code>ToString</code> instance available for <code>α</code>.
It returns an <code>IO</code> action.</p>
<h2 id="checking-polymorphic-functions-types"><a class="header" href="#checking-polymorphic-functions-types">Checking Polymorphic Functions' Types</a></h2>
<p>Checking the type of a function that takes implicit arguments or uses type classes requires the use of some additional syntax.
Simply writing</p>
<pre><code class="language-lean">#check IO.println
</code></pre>
<p>yields a type with metavariables:</p>
<pre><code class="language-output info">IO.println : ?m.3615 → IO Unit
</code></pre>
<p>This is because Lean does its best to discover implicit arguments, and the presence of metavariables indicates that it did not yet discover enough type information to do so.
To understand the signature of a function, this feature can be suppressed with an at-sign (<code>@</code>) before the function's name:</p>
<pre><code class="language-lean">#check @IO.println
</code></pre>
<pre><code class="language-output info">@IO.println : {α : Type u_1} → [inst : ToString α] → α → IO Unit
</code></pre>
<p>In this output, the instance itself has been given the name <code>inst</code>.
Additionally, there is a <code>u_1</code> after <code>Type</code>, which uses a feature of Lean that has not yet been introduced.
For now, ignore these parameters to <code>Type</code>.</p>
<h2 id="defining-polymorphic-functions-with-instance-implicits"><a class="header" href="#defining-polymorphic-functions-with-instance-implicits">Defining Polymorphic Functions with Instance Implicits</a></h2>
<p>A function that sums all entries in a list needs two instances: <code>Add</code> allows the entries to be added, and an <code>OfNat</code> instance for <code>0</code> provides a sensible value to return for the empty list:</p>
<pre><code class="language-lean">def List.sum [Add α] [OfNat α 0] : List α → α
  | [] =&gt; 0
  | x :: xs =&gt; x + xs.sum
</code></pre>
<p>This function can be used for a list of <code>Nat</code>s:</p>
<pre><code class="language-lean">def fourNats : List Nat := [1, 2, 3, 4]

#eval fourNats.sum
</code></pre>
<pre><code class="language-output info">10
</code></pre>
<p>but not for a list of <code>Pos</code> numbers:</p>
<pre><code class="language-lean">def fourPos : List Pos := [1, 2, 3, 4]

#eval fourPos.sum
</code></pre>
<pre><code class="language-output error">failed to synthesize instance
  OfNat Pos 0
</code></pre>
<p>Specifications of required instances in square brackets are called <em>instance implicits</em>.
Behind the scenes, every type class defines a structure that has a field for each overloaded operation.
Instances are values of that structure type, with each field containing an implementation.
At a call site, Lean is responsible for finding an instance value to pass for each instance implicit argument.
The most important difference between ordinary implicit arguments and instance implicits is the strategy that Lean uses to find an argument value.
In the case of ordinary implicit arguments, Lean uses a technique called <em>unification</em> to find a single unique argument value that would allow the program to pass the type checker.
This process relies only on the specific types involved in the function's definition and the call site.
For instance implicits, Lean instead consults a built-in table of instance values.</p>
<p>Just as the <code>OfNat</code> instance for <code>Pos</code> took a natural number <code>n</code> as an automatic implicit argument, instances may also take instance implicit arguments themselves.
The <a href="type-classes/../getting-to-know/polymorphism.html">section on polymorphism</a> presented a polymorphic point type:</p>
<pre><code class="language-lean">structure PPoint (α : Type) where
  x : α
  y : α
deriving Repr
</code></pre>
<p>Addition of points should add the underlying <code>x</code> and <code>y</code> fields.
Thus, an <code>Add</code> instance for <code>PPoint</code> requires an <code>Add</code> instance for whatever type these fields have.
In other words, the <code>Add</code> instance for <code>PPoint</code> requires a further <code>Add</code> instance for <code>α</code>:</p>
<pre><code class="language-lean">instance [Add α] : Add (PPoint α) where
  add p1 p2 := { x := p1.x + p2.x, y := p1.y + p2.y }
</code></pre>
<p>When Lean encounters an addition of two points, it searches for and finds this instance.
It then performs a further search for the <code>Add α</code> instance.</p>
<p>The instance values that are constructed in this way are values of the type class's structure type.
A successful recursive instance search results in a structure value that has a reference to another structure value.
An instance of <code>Add (PPoint Nat)</code> contains a reference to the instance of <code>Add Nat</code> that was found.</p>
<p>This recursive search process means that type classes offer significantly more power than plain overloaded functions.
A library of polymorphic instances is a set of code building blocks that the compiler will assemble on its own, given nothing but the desired type.
Polymorphic functions that take instance arguments are latent requests to the type class mechanism to assemble helper functions behind the scenes.
The API's clients are freed from the burden of plumbing together all of the necessary parts by hand.</p>
<h2 id="methods-and-implicit-arguments"><a class="header" href="#methods-and-implicit-arguments">Methods and Implicit Arguments</a></h2>
<p>The type of <code>@OfNat.ofNat</code> may be surprising.
It is <code>{α : Type} → (n : Nat) → [OfNat α n] → α</code>, in which the <code>Nat</code> argument <code>n</code> occurs as an explicit function argument.
In the declaration of the method, however, <code>ofNat</code> simply has type <code>α</code>.
This seeming discrepancy is because declaring a type class really results in the following:</p>
<ul>
<li>A structure type to contain the implementation of each overloaded operation</li>
<li>A namespace with the same name as the class</li>
<li>For each method, a function in the class's namespace that retrieves its implementation from an instance</li>
</ul>
<p>This is analogous to the way that declaring a new structure also declares accessor functions.
The primary difference is that a structure's accessors take the structure value as an explicit argument, while the type class methods take the instance value as an instance implicit to be found automatically by Lean.</p>
<p>In order for Lean to find an instance, its arguments must be available.
This means that each argument to the type class must be an argument to the method that occurs before the instance.
It is most convenient when these arguments are implicit, because Lean does the work of discovering their values.
For example, <code>@Add.add</code> has the type <code>{α : Type} → [Add α] → α → α → α</code>.
In this case, the type argument <code>α</code> can be implicit because the arguments to <code>Add.add</code> provide information about which type the user intended.
This type can then be used to search for the <code>Add</code> instance.</p>
<p>In the case of <code>ofNat</code>, however, the particular <code>Nat</code> literal to be decoded does not appear as part of any other argument.
This means that Lean would have no information to use when attempting to figure out the implicit argument <code>n</code>.
The result would be a very inconvenient API.
Thus, in these cases, Lean uses an explicit argument for the class's method.</p>
<h2 id="exercises-6"><a class="header" href="#exercises-6">Exercises</a></h2>
<h3 id="even-number-literals"><a class="header" href="#even-number-literals">Even Number Literals</a></h3>
<p>Write an instance of <code>OfNat</code> for the even number datatype from the <a href="type-classes/pos.html#even-numbers">previous section's exercises</a> that uses recursive instance search.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="controlling-instance-search"><a class="header" href="#controlling-instance-search">Controlling Instance Search</a></h1>
<p>An instance of the <code>Add</code> class is sufficient to allow two expressions with type <code>Pos</code> to be conveniently added, producing another <code>Pos</code>.
However, in many cases, it can be useful to be more flexible and allow <em>heterogeneous</em> operator overloading, where the arguments may have different types.
For example, adding a <code>Nat</code> to a <code>Pos</code> or a <code>Pos</code> to a <code>Nat</code> will always yield a <code>Pos</code>:</p>
<pre><code class="language-lean">def addNatPos : Nat → Pos → Pos
  | 0, p =&gt; p
  | n + 1, p =&gt; Pos.succ (addNatPos n p)

def addPosNat : Pos → Nat → Pos
  | p, 0 =&gt; p
  | p, n + 1 =&gt; Pos.succ (addPosNat p n)
</code></pre>
<p>These functions allow natural numbers to be added to positive numbers, but they cannot be used with the <code>Add</code> type class, which expects both arguments to <code>add</code> to have the same type.</p>
<h2 id="heterogeneous-overloadings"><a class="header" href="#heterogeneous-overloadings">Heterogeneous Overloadings</a></h2>
<p>As mentioned in the section on <a href="type-classes/pos.html#overloaded-addition">overloaded addition</a>, Lean provides a type class called <code>HAdd</code> for overloading addition heterogeneously.
The <code>HAdd</code> class takes three type parameters: the two argument types and the return type.
Instances of <code>HAdd Nat Pos Pos</code> and <code>HAdd Pos Nat Pos</code> allow ordinary addition notation to be used to mix the types:</p>
<pre><code class="language-lean">instance : HAdd Nat Pos Pos where
  hAdd := addNatPos

instance : HAdd Pos Nat Pos where
  hAdd := addPosNat
</code></pre>
<p>Given the above two instances, the following examples work:</p>
<pre><code class="language-lean">#eval (3 : Pos) + (5 : Nat)
</code></pre>
<pre><code class="language-output info">8
</code></pre>
<pre><code class="language-lean">#eval (3 : Nat) + (5 : Pos)
</code></pre>
<pre><code class="language-output info">8
</code></pre>
<p>The definition of the <code>HAdd</code> type class is very much like the following definition of <code>HPlus</code> with the corresponding instances:</p>
<pre><code class="language-lean">class HPlus (α : Type) (β : Type) (γ : Type) where
  hPlus : α → β → γ

instance : HPlus Nat Pos Pos where
  hPlus := addNatPos

instance : HPlus Pos Nat Pos where
  hPlus := addPosNat
</code></pre>
<p>However, instances of <code>HPlus</code> are significantly less useful than instances of <code>HAdd</code>.
When attempting to use these instances with <code>#eval</code>, an error occurs:</p>
<pre><code class="language-lean">#eval HPlus.hPlus (3 : Pos) (5 : Nat)
</code></pre>
<pre><code class="language-output error">typeclass instance problem is stuck, it is often due to metavariables
  HPlus Pos Nat ?m.7158
</code></pre>
<p>This happens because there is a metavariable in the type, and Lean has no way to solve it.</p>
<p>As discussed in <a href="type-classes/../getting-to-know/polymorphism.html">the initial description of polymorphism</a>, metavariables represent unknown parts of a program that could not be inferred.
When an expression is written following <code>#eval</code>, Lean attempts to determine its type automatically.
In this case, it could not.
Because the third type parameter for <code>HPlus</code> was unknown, Lean couldn't carry out type class instance search, but instance search is the only way that Lean could determine the expression's type.
That is, the <code>HPlus Pos Nat Pos</code> instance can only apply if the expression should have type <code>Pos</code>, but there's nothing in the program other than the instance itself to indicate that it should have this type.</p>
<p>One solution to the problem is to ensure that all three types are available by adding a type annotation to the whole expression:</p>
<pre><code class="language-lean">#eval (HPlus.hPlus (3 : Pos) (5 : Nat) : Pos)
</code></pre>
<pre><code class="language-output info">8
</code></pre>
<p>However, this solution is not very convenient for users of the positive number library.</p>
<h2 id="output-parameters"><a class="header" href="#output-parameters">Output Parameters</a></h2>
<p>This problem can also be solved by declaring <code>γ</code> to be an <em>output parameter</em>.
Most type class parameters are inputs to the search algorithm: they are used to select an instance.
For example, in an <code>OfNat</code> instance, both the type and the natural number are used to select a particular interpretation of a natural number literal.
However, in some cases, it can be convenient to start the search process even when some of the type parameters are not yet known, and use the instances that are discovered in the search to determine values for metavariables.
The parameters that aren't needed to start instance search are outputs of the process, which is declared with the <code>outParam</code> modifier:</p>
<pre><code class="language-lean">class HPlus (α : Type) (β : Type) (γ : outParam Type) where
  hPlus : α → β → γ
</code></pre>
<p>With this output parameter, type class instance search is able to select an instance without knowing <code>γ</code> in advance.
For instance:</p>
<pre><code class="language-lean">#eval HPlus.hPlus (3 : Pos) (5 : Nat)
</code></pre>
<pre><code class="language-output info">8
</code></pre>
<p>It might be helpful to think of output parameters as defining a kind of function.
Any given instance of a type class that has one or more output parameters provides Lean with instructions for determining the outputs from the inputs.
The process of searching for an instance, possibly recursively, ends up being more powerful than mere overloading.
Output parameters can determine other types in the program, and instance search can assemble a collection of underlying instances into a program that has this type.</p>
<h2 id="default-instances"><a class="header" href="#default-instances">Default Instances</a></h2>
<p>Deciding whether a parameter is an input or an output controls the circumstances under which Lean will initiate type class search.
In particular, type class search does not occur until all inputs are known.
However, in some cases, output parameters are not enough, and instance search should also occur when some inputs are unknown.
This is a bit like default values for optional function arguments in Python or Kotlin, except default <em>types</em> are being selected.</p>
<p><em>Default instances</em> are instances that are available for instance search <em>even when not all their inputs are known</em>.
When one of these instances can be used, it will be used.
This can cause programs to successfully type check, rather than failing with errors related to unknown types and metavariables.
On the other hand, default instances can make instance selection less predictable.
In particular, if an undesired default instance is selected, then an expression may have a different type than expected, which can cause confusing type errors to occur elsewhere in the program.
Be selective about where default instances are used!</p>
<p>One example of where default instances can be useful is an instance of <code>HPlus</code> that can be derived from an <code>Add</code> instance.
In other words, ordinary addition is a special case of heterogeneous addition in which all three types happen to be the same.
This can be implemented using the following instance:</p>
<pre><code class="language-lean">instance [Add α] : HPlus α α α where
  hPlus := Add.add
</code></pre>
<p>With this instance, <code>hPlus</code> can be used for any addable type, like <code>Nat</code>:</p>
<pre><code class="language-lean">#eval HPlus.hPlus (3 : Pos) (5 : Nat)
</code></pre>
<pre><code class="language-output info">8
</code></pre>
<p>However, this instance will only be used in situations where the types of both arguments are known.
For example,</p>
<pre><code class="language-lean">#check HPlus.hPlus (5 : Nat) (3 : Nat)
</code></pre>
<p>yields the type</p>
<pre><code class="language-output info">HPlus.hPlus 5 3 : Nat
</code></pre>
<p>as expected, but</p>
<pre><code class="language-lean">#check HPlus.hPlus (5 : Nat)
</code></pre>
<p>yields a type that contains two metavariables, one for the remaining argument and one for the return type:</p>
<pre><code class="language-output info">HPlus.hPlus 5 : ?m.7323 → ?m.7325
</code></pre>
<p>In the vast majority of cases, when someone supplies one argument to addition, the other argument will have the same type.
To make this instance into a default instance, apply the <code>default_instance</code> attribute:</p>
<pre><code class="language-lean">@[default_instance]
instance [Add α] : HPlus α α α where
  hPlus := Add.add
</code></pre>
<p>With this default instance, the example has a more useful type:</p>
<pre><code class="language-lean">#check HPlus.hPlus (5 : Nat)
</code></pre>
<p>yields</p>
<pre><code class="language-output info">HPlus.hPlus 5 : Nat → Nat
</code></pre>
<p>Each operator that exists in overloadable heterogeneous and homogeneous versions follows the pattern of a default instance that allows the homogeneous version to be used in contexts where the heterogeneous is expected.
The infix operator is replaced with a call to the heterogeneous version, and the homogeneous default instance is selected when possible.</p>
<p>Similarly, simply writing <code>5</code> gives a <code>Nat</code> rather than a type with a metavariable that is waiting for more information in order to select an <code>OfNat</code> instance.
This is because the <code>OfNat</code> instance for <code>Nat</code> is a default instance.</p>
<p>Default instances can also be assigned <em>priorities</em> that affect which will be chosen in situations where more than one might apply.
For more information on default instance priorities, please consult the Lean manual.</p>
<h2 id="exercises-7"><a class="header" href="#exercises-7">Exercises</a></h2>
<p>Define an instance of <code>HMul (PPoint α) α (PPoint α)</code> that multiplies both projections by the scalar.
It should work for any type <code>α</code> for which there is a <code>Mul α</code> instance.
For example,</p>
<pre><code class="language-lean">#eval {x := 2.5, y := 3.7 : PPoint Float} * 2.0
</code></pre>
<p>should yield</p>
<pre><code class="language-output info">{ x := 5.000000, y := 7.400000 }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrays-and-indexing"><a class="header" href="#arrays-and-indexing">Arrays and Indexing</a></h1>
<p>The <a href="type-classes/../props-proofs-indexing.html">Interlude</a> describes how to use indexing notation in order to look up entries in a list by their position.
This syntax is also governed by a type class, and it can be used for a variety of different types.</p>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<p>For instance, Lean arrays are much more efficient than linked lists for most purposes.
In Lean, the type <code>Array α</code> is a dynamically-sized array holding values of type <code>α</code>, much like a Java <code>ArrayList</code>, a C++ <code>std::vector</code>, or a Rust <code>std::vec</code>.
Unlike <code>List</code>, arrays occupy a contiguous region of memory, which is much better for processor caches.
Also, looking up a value in an array takes constant time, while lookup in a linked list takes time proportional to the index being accessed.</p>
<p>In pure functional languages like Lean, it is not possible to mutate a given position in a data structure.
Instead, a copy is made that has the desired modifications.
When using an array, the Lean compiler and runtime contain an optimizations that can allow modifications to be implemented as mutations behind the scenes when there is only a single unique reference to an array, while a list would require copies of all prior nodes to be made.</p>
<p>Arrays are written similarly to lists, but with a leading <code>#</code>:</p>
<pre><code class="language-lean">def northernTrees : Array String :=
  #[&quot;beech&quot;, &quot;birch&quot;, &quot;elm&quot;, &quot;oak&quot;]
</code></pre>
<p>The number of values in an array can be found using <code>Array.size</code>.
For instance, <code>northernTrees.size</code> evaluates to <code>4</code>.
For indices that are smaller than an array's size, indexing notation can be used to find the corresponding value, just as with lists.
That is, <code>northernTrees[2]</code> evaluates to <code>&quot;elm&quot;</code>.
Similarly, the compiler requires a proof that an index is in bounds, and attempting to look up a value outside the bounds of the array results in a compile-time error, just as with lists.
For instance, <code>northernTrees[8]</code> results in:</p>
<pre><code class="language-output error">failed to prove index is valid, possible solutions:
  - Use `have`-expressions to prove the index is valid
  - Use `a[i]!` notation instead, runtime check is perfomed, and 'Panic' error message is produced if index is not valid
  - Use `a[i]?` notation instead, result is an `Option` type
  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid
⊢ 8 &lt; Array.size northernTrees
</code></pre>
<h2 id="non-empty-lists"><a class="header" href="#non-empty-lists">Non-Empty Lists</a></h2>
<p>A datatype that represents non-empty lists can be defined as a structure with a field for the head of the list and a field for the tail, which is an ordinary, potentially empty list:</p>
<pre><code class="language-lean">structure NonEmptyList (α : Type) : Type where
  head : α
  tail : List α
</code></pre>
<p>For example, the non-empty list <code>idahoSpiders</code> (which contains some spider species native to the US state of Idaho) consists of <code>&quot;Banded Garden Spider&quot;</code> followed by four other spiders, for a total of five spiders.</p>
<p>Looking up the value at a specific index in this list with a recursive function should consider three possibilities:</p>
<ol>
<li>The index is <code>0</code>, in which case the head of the list should be returned.</li>
<li>The index is <code>n + 1</code> and the tail is empty, in which case the index is out of bounds.</li>
<li>The index is <code>n + 1</code> and the tail is non-empty, in which case the function can be called recursively on the tail and <code>n</code>.</li>
</ol>
<p>For example, a lookup function that returns an <code>Option</code> can be written as follows:</p>
<pre><code class="language-lean">def NonEmptyList.get? : NonEmptyList α → Nat → Option α
  | xs, 0 =&gt; some xs.head
  | {head := _, tail := []}, _ + 1 =&gt; none
  | {head := _, tail := h :: t}, n + 1 =&gt; get? {head := h, tail := t} n
</code></pre>
<p>Each case in the pattern match corresponds to one of the possibilities above.
The recursive call to <code>get?</code> does not require a <code>NonEmptyList</code> namespace qualifier because the body of the definition is implicitly in the definition's namespace.
Another way to write this function uses <code>get?</code> for lists when the index is greater than zero:</p>
<pre><code class="language-lean">def NonEmptyList.get? : NonEmptyList α → Nat → Option α
  | xs, 0 =&gt; some xs.head
  | xs, n + 1 =&gt; xs.tail.get? n
</code></pre>
<p>If the list contains one entry, then only <code>0</code> is a valid index.
If it contains two entries, then both <code>0</code> and <code>1</code> are valid indices.
If it contains three entries, then <code>0</code>, <code>1</code>, and <code>2</code> are valid indices.
In other words, the valid indices into a non-empty list are natural numbers that are strictly less than the length of the list, which are less than or equal to the length of the tail.</p>
<p>The definition of what it means for an index to be in bounds should be written as an <code>abbrev</code> because the tactics used to find evidence that indices are acceptable are able to solve inequalities of numbers, but they don't know anything about the name <code>NonEmptyList.inBounds</code>:</p>
<pre><code class="language-lean">abbrev NonEmptyList.inBounds (xs : NonEmptyList α) (i : Nat) : Prop :=
  i ≤ xs.tail.length
</code></pre>
<p>This function returns a proposition that might be true or false.
For instance, <code>2</code> is in bounds for <code>idahoSpiders</code>, while <code>5</code> is not:</p>
<pre><code class="language-lean">theorem atLeastThreeSpiders : idahoSpiders.inBounds 2 := by simp

theorem notSixSpiders : ¬idahoSpiders.inBounds 5 := by simp
</code></pre>
<p>The logical negation operator has a very low precedence, which means that <code>¬idahoSpiders.inBounds 5</code> is equivalent to <code>¬(idahoSpiders.inBounds 5)</code>.</p>
<p>This fact can be used to write a lookup function that requires evidence that the index is valid, and thus need not return <code>Option</code>, by delegating to the version for lists that checks the evidence at compile time:</p>
<pre><code class="language-lean">def NonEmptyList.get (xs : NonEmptyList α) (i : Nat) (ok : xs.inBounds i) : α :=
  match i with
  | 0 =&gt; xs.head
  | n + 1 =&gt; xs.tail[n]
</code></pre>
<p>It is, of course, possible to write this function to use the evidence directly, rather than delegating to a standard library function that happens to be able to use the same evidence.
This requires techniques for working with proofs and propositions that are described later in this book.</p>
<h2 id="overloading-indexing"><a class="header" href="#overloading-indexing">Overloading Indexing</a></h2>
<p>Indexing notation for a collection type can be overloaded by defining an instance of the <code>GetElem</code> type class.
For the sake of flexiblity, <code>GetElem</code> has four parameters:</p>
<ul>
<li>The type of the collection</li>
<li>The type of the index</li>
<li>The type of elements that are extracted from the collection</li>
<li>A function that determines what counts as evidence that the index is in bounds</li>
</ul>
<p>The element type and the evidence function are both output parameters.
<code>GetElem</code> has a single method, <code>getElem</code>, which takes a collection value, an index value, and evidence that the index is in bounds as arguments, and returns an element:</p>
<pre><code class="language-lean">class GetElem (coll : Type) (idx : Type) (item : outParam Type) (inBounds : outParam (coll → idx → Prop)) where
  getElem : (c : coll) → (i : idx) → inBounds c i → item
</code></pre>
<p>In the case of <code>NonEmptyList α</code>, these parameters are:</p>
<ul>
<li>The collection is <code>NonEmptyList α</code></li>
<li>Indices have type <code>Nat</code></li>
<li>The type of elements is <code>α</code></li>
<li>An index is in bounds if it is less than or equal to the length of the tail</li>
</ul>
<p>In fact, the <code>GetElem</code> instance can delegate directly to <code>NonEmptyList.get</code>:</p>
<pre><code class="language-lean">instance : GetElem (NonEmptyList α) Nat α NonEmptyList.inBounds where
  getElem := NonEmptyList.get
</code></pre>
<p>With this instance, <code>NonEmptyList</code> becomes just as convenient to use as <code>List</code>.
Evaluating <code>idahoSpiders[0]</code> yields <code>&quot;Banded Garden Spider&quot;</code>, while <code>idahoSpiders[9]</code> leads to the compile-time error:</p>
<pre><code class="language-output error">failed to prove index is valid, possible solutions:
  - Use `have`-expressions to prove the index is valid
  - Use `a[i]!` notation instead, runtime check is perfomed, and 'Panic' error message is produced if index is not valid
  - Use `a[i]?` notation instead, result is an `Option` type
  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid
⊢ NonEmptyList.inBounds idahoSpiders 9
</code></pre>
<p>Because both the collection type and the index type are input parameters to the <code>GetElem</code> type class, new types can be used to index into existing collections.
The positive number type <code>Pos</code> is a perfectly reasonable index into a <code>List</code>, with the caveat that it cannot point at the first entry.
The follow instance of <code>GetElem</code> allows <code>Pos</code> to be used just as conveniently as <code>Nat</code> to find a list entry:</p>
<pre><code class="language-lean">instance : GetElem (List α) Pos α (fun list n =&gt; list.length &gt; n.toNat) where
  getElem (xs : List α) (i : Pos) ok := xs[i.toNat]
</code></pre>
<p>Indexing can also make sense for non-numeric indices.
For example, <code>Bool</code> can be used to select between the fields in a point, with <code>false</code> corresponding to <code>x</code> and <code>true</code> corresponding to <code>y</code>:</p>
<pre><code class="language-lean">instance : GetElem (PPoint α) Bool α (fun _ _ =&gt; True) where
  getElem (p : PPoint α) (i : Bool) _ :=
    if not i then p.x else p.y
</code></pre>
<p>In this case, both Booleans are valid indices.
Because every possible <code>Bool</code> is in bounds, the evidence is simply the true proposition <code>True</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-classes"><a class="header" href="#standard-classes">Standard Classes</a></h1>
<p>This section presents a variety of operators and functions that can be overloaded using type classes in Lean.
Each operator or function corresponds to a method of a type class.
Unlike C++, infix operators in Lean are defined as abbreviations for named functions; this means that overloading them for new types is not done using the operator itself, but rather refers to a name such as <code>HAdd.hAdd</code>.</p>
<h2 id="arithmetic"><a class="header" href="#arithmetic">Arithmetic</a></h2>
<p>Most arithmetic operators are available in a heterogeneous form, where the arguments may have different type and an output parameter decides the type of the resulting expression.
For each heterogeneous operator, there is a corresponding homogeneous version that can found by removing the letter <code>h</code>, so that <code>HAdd.hAdd</code> becomes <code>Add.add</code>.
The following arithmetic operators are overloaded:</p>
<table><thead><tr><th>Expression</th><th>Desugaring</th><th>Class Name</th></tr></thead><tbody>
<tr><td><code>x + y</code></td><td><code>HAdd.hAdd x y</code></td><td><code>HAdd</code></td></tr>
<tr><td><code>x - y</code></td><td><code>HSub.hSub x y</code></td><td><code>HSub</code></td></tr>
<tr><td><code>x * y</code></td><td><code>HMul.hMul x y</code></td><td><code>HMul</code></td></tr>
<tr><td><code>x / y</code></td><td><code>HDiv.hDiv x y</code></td><td><code>HDiv</code></td></tr>
<tr><td><code>x % y</code></td><td><code>HMod.hMod x y</code></td><td><code>HMod</code></td></tr>
<tr><td><code>x ^ y</code></td><td><code>HPow.hPow x y</code></td><td><code>HPow</code></td></tr>
<tr><td><code>(- x)</code></td><td><code>Neg.neg x</code></td><td><code>Neg</code></td></tr>
</tbody></table>
<h2 id="bitwise-operators"><a class="header" href="#bitwise-operators">Bitwise Operators</a></h2>
<p>Lean contains a number of standard bitwise operators that are overloaded using type classes.
There are instances for fixed-width types such as <code>UInt8</code>, <code>UInt16</code>, <code>UInt32</code>, <code>UInt64</code>, and <code>USize</code>.
The latter is the size of words on the current platform, typically 32 or 64 bits.
The following bitwise operators are overloaded:</p>
<table><thead><tr><th>Expression</th><th>Desugaring</th><th>Class Name</th></tr></thead><tbody>
<tr><td><code>x &amp;&amp;&amp; y</code></td><td><code>HAnd.hAnd x y</code></td><td><code>HAnd</code></td></tr>
<tr><td><code class="hljs">x ||| y </code></td><td><code>HOr.hOr x y</code></td><td><code>HOr</code></td></tr>
<tr><td><code>x ^^^ y</code></td><td><code>HXor.hXor x y</code></td><td><code>HXor</code></td></tr>
<tr><td><code>~~~ x</code></td><td><code>Complement.complement x</code></td><td><code>Complement</code></td></tr>
<tr><td><code>x &gt;&gt;&gt; y</code></td><td><code>HShiftRight.hShiftRight x y</code></td><td><code>HShiftRight</code></td></tr>
<tr><td><code>x &lt;&lt;&lt; y</code></td><td><code>HShiftLeft.hShiftLeft x y</code></td><td><code>HShiftLeft</code></td></tr>
</tbody></table>
<p>Because the names <code>And</code> and <code>Or</code> are already taken as the names of logical connectives, the homogeneous versions of <code>HAnd</code> and <code>HOr</code> are called <code>AndOp</code> and <code>OrOp</code> rather than <code>And</code> and <code>Or</code>.</p>
<h2 id="equality-and-ordering"><a class="header" href="#equality-and-ordering">Equality and Ordering</a></h2>
<p>Testing equality of two values typically uses the <code>BEq</code> class, which is short for &quot;Boolean equality&quot;.
Due to Lean's use as a theorem prover, there are really two kinds of equality operators in Lean:</p>
<ul>
<li><em>Boolean equality</em> is the same kind of equality that is found in other programming languages. It is a function that takes two values and returns a <code>Bool</code>. Boolean equality is written with two equals signs, just as in Python and C#. Because Lean is a pure functional language, there's no separate notions of reference vs value equality—pointers cannot be observed directly.</li>
<li><em>Propositional equality</em> is the mathematical statement that two things are equal. Propositional equality is not a function; rather, it is a mathematical statement that admits proof. It is written with a single equals sign. A statement of propositional equality is like a type that classifies evidence of this equality.</li>
</ul>
<p>Both notions of equality are important, and used for different purposes.
Boolean equality is useful in programs, when a decision needs to be made about whether two values are equal.
For example, <code>&quot;Octopus&quot; ==  &quot;Cuttlefish&quot;</code> evaluates to <code>false</code>, and <code>&quot;Octopodes&quot; ==  &quot;Octo&quot;.append &quot;podes&quot;</code> evaluates to <code>true</code>.
Some values, such as functions, cannot be checked for equality.
For example, <code>(fun (x : Nat) =&gt; 1 + x) == (Nat.succ ·)</code> yields the error:</p>
<pre><code class="language-output error">failed to synthesize instance
  BEq (Nat → Nat)
</code></pre>
<p>As this message indicates, <code>==</code> is overloaded using a type class.
The expression <code>x == y</code> is actually shorthand for <code>BEq.beq x y</code>.</p>
<p>Propositional equality is a mathematical statement rather than an invocation of a program.
Because propositions are like types that describe evidence for some statement, propositional equality has more in common with types like <code>String</code> and <code>Nat → List Int</code> than it does with Boolean equality.
This means that it can't automatically be checked.
However, the equality of any two expressions can be stated in Lean, so long as they have the same type.
The statement <code>(fun (x : Nat) =&gt; 1 + x) = (Nat.succ ·)</code> is a perfectly reasonable statement.
From the perspective of mathematics, two functions are equal if they map equal inputs to equal outputs, so this statement is even true, though it requires a two-line proof to convince Lean of this fact.</p>
<p>Generally speaking, when using Lean as a programming language, it's easiest to stick to Boolean functions rather than propositions.
However, as the names <code>true</code> and <code>false</code> for <code>Bool</code>'s constructors suggest, this difference is sometimes blurred.
Some propositions are <em>decidable</em>, which means that they can be checked just like a Boolean function.
The function that checks whether the proposition is true or false is called a <em>decision procedure</em>, and it returns <em>evidence</em> of the truth or falsity of the proposition.
Some examples of decidable propositions include equality and inequality of natural numbers, equality of strings, and &quot;ands&quot; and &quot;ors&quot; of propositions that are themselves decidable.</p>
<p>In Lean, <code>if</code> works with decidable propositions.
For example, <code>2 &lt; 4</code> is a proposition:</p>
<pre><code class="language-lean">#check 2 &lt; 4
</code></pre>
<pre><code class="language-output info">2 &lt; 4 : Prop
</code></pre>
<p>Nonetheless, it is perfectly acceptable to write it as the condition in an <code>if</code>.
For example, <code>if 2 &lt; 4 then 1 else 2</code> has type <code>Nat</code> and evaluates to <code>1</code>.</p>
<p>Not all propositions are decidable.
If they were, then computers would be able to prove any true proposition just by running the decision procedure, and mathematicians would be out of a job.
More specifically, decidable propositions have an instance of the <code>Decidable</code> type class which has a method that is the decision procedure.
Trying to use a proposition that isn't decidable as if it were a <code>Bool</code> results in a failure to find the <code>Decidable</code> instance.
For example, <code>if (fun (x : Nat) =&gt; 1 + x) = (Nat.succ ·) then &quot;yes&quot; else &quot;no&quot;</code> results in:</p>
<pre><code class="language-output error">failed to synthesize instance
  Decidable ((fun x =&gt; 1 + x) = fun x =&gt; Nat.succ x)
</code></pre>
<p>The following propositions, that are usually decidable, are overloaded with type classes:</p>
<table><thead><tr><th>Expression</th><th>Desugaring</th><th>Class Name</th></tr></thead><tbody>
<tr><td><code>x &lt; y</code></td><td><code>LT.lt x y</code></td><td><code>LT</code></td></tr>
<tr><td><code>x ≤ y</code></td><td><code>LE.le x y</code></td><td><code>LE</code></td></tr>
<tr><td><code>x &gt; y</code></td><td><code>LT.lt y x</code></td><td><code>LT</code></td></tr>
<tr><td><code>x ≥ y</code></td><td><code>LE.le y x</code></td><td><code>LE</code></td></tr>
</tbody></table>
<p>Because defining new propositions hasn't yet been demonstrated, it may be difficult to define new instances of <code>LT</code> and <code>LE</code>.</p>
<p>Additionally, comparing values using <code>&lt;</code>, <code>==</code>, and <code>&gt;</code> can be inefficient.
Checking first whether one value is less than another, and then whether they are equal, can require two traversals over large data structures.
To solve this problem, Java and C# have standard <code>compareTo</code> and <code>CompareTo</code> methods (respectively) that can be overridden by a class in order to implement all three operations at the same time.
These methods return a negative integer if the receiver is less than the argument, zero if they are equal, and a positive integer if the receiver is greater than the argument.
Rather than overload the meaning of integers, Lean has a built-in inductive type that describes these three possibilities:</p>
<pre><code class="language-lean">inductive Ordering where
| lt
| eq
| gt
</code></pre>
<p>The <code>Ord</code> type class can be overloaded to produce these comparisons.
For <code>Pos</code>, an implementation can be:</p>
<pre><code class="language-lean">def Pos.comp : Pos → Pos → Ordering
  | Pos.one, Pos.one =&gt; Ordering.eq
  | Pos.one, Pos.succ _ =&gt; Ordering.lt
  | Pos.succ _, Pos.one =&gt; Ordering.gt
  | Pos.succ n, Pos.succ k =&gt; comp n k

instance : Ord Pos where
  compare := Pos.comp
</code></pre>
<p>In situations where <code>compareTo</code> would be the right approach in Java, use <code>Ord.compare</code> in Lean.</p>
<h2 id="hashing"><a class="header" href="#hashing">Hashing</a></h2>
<p>Java and C# have <code>hashCode</code> and <code>GetHashCode</code> methods, respectively, that compute a hash of a value for use in data structures such as hash tables.
The Lean equivalent is a type class called <code>Hashable</code>:</p>
<pre><code class="language-lean">class Hashable (α : Type) where
  hash : α → UInt64
</code></pre>
<p>If two values are considered equal according to a <code>BEq</code> instance for their type, then they should have the same hashes.
In other words, if <code>x == y</code> then <code>hash x == hash y</code>.
If <code>x ≠ y</code>, then <code>hash x</code> won't necessarily differ from <code>hash y</code> (after all, there are infinitely more <code>Nat</code> values than there are <code>UInt64</code> values), but data structures built on hashing will have better performance if unequal values are likely to have unequal hashes.
This is the same expectation as in Java and C#.</p>
<p>The standard library contains a function <code>mixHash</code> with type <code>UInt64 → UInt64 → UInt64</code> that can be used to combine hashes for different fields for a constructor.
A reasonable hash function for an inductive datatype can be written by assigning a unique number to each constructor, and then mixing that number with the hashes of each field.
For example, a <code>Hashable</code> instance for <code>Pos</code> can be written:</p>
<pre><code class="language-lean">def hashPos : Pos → UInt64
  | Pos.one =&gt; 0
  | Pos.succ n =&gt; mixHash 1 (hashPos n)

instance : Hashable Pos where
  hash := hashPos
</code></pre>
<p><code>Hashable</code> instances for polymorphic types can use recursive instance search.
Hashing a <code>NonEmptyList α</code> is only possible when <code>α</code> can be hashed:</p>
<pre><code class="language-lean">instance [Hashable α] : Hashable (NonEmptyList α) where
  hash xs := mixHash (hash xs.head) (hash xs.tail)
</code></pre>
<p>Binary trees use both recursion and recursive instance search in the implementations of <code>BEq</code> and <code>Hashable</code>:</p>
<pre><code class="language-lean">inductive BinTree (α : Type) where
  | leaf : BinTree α
  | branch : BinTree α → α → BinTree α → BinTree α

def eqBinTree [BEq α] : BinTree α → BinTree α → Bool
  | BinTree.leaf, BinTree.leaf =&gt;
    true
  | BinTree.branch l x r, BinTree.branch l2 x2 r2 =&gt;
    x == x2 &amp;&amp; eqBinTree l l2 &amp;&amp; eqBinTree r r2
  | _, _ =&gt;
    false

instance [BEq α] : BEq (BinTree α) where
  beq := eqBinTree

def hashBinTree [Hashable α] : BinTree α → UInt64
  | BinTree.leaf =&gt;
    0
  | BinTree.branch left x right =&gt;
    mixHash 1 (mixHash (hashBinTree left) (mixHash (hash x) (hashBinTree right)))

instance [Hashable α] : Hashable (BinTree α) where
  hash := hashBinTree
</code></pre>
<h2 id="deriving-standard-classes"><a class="header" href="#deriving-standard-classes">Deriving Standard Classes</a></h2>
<p>Instance of classes like <code>BEq</code> and <code>Hashable</code> are often quite tedious to implement by hand.
Lean includes a feature called <em>instance deriving</em> that allows the compiler to automatically construct well-behaved instances of many type classes.
In fact, the <code>deriving Repr</code> phrase in the definition of <code>Point</code> in the <a href="type-classes/../getting-to-know/structures.html">section on structures</a> is an example of instance deriving.</p>
<p>Instances can be derived in two ways.
The first can be used when defining a structure or inductive type.
In this case, add <code>deriving</code> to the end of the type declaration followed by the names of the classes for which instances should be derived.
For a type that is already defined, a standalone <code>deriving</code> command can be used.
Write <code>deriving instance C1, C2, ... for T</code> to deriving instances of <code>C1, C2, ...</code> for the type <code>T</code> after the fact.</p>
<p><code>BEq</code> and <code>Hashable</code> instances can be derived for <code>Pos</code> and <code>NonEmptyList</code> using a very small amount of code:</p>
<pre><code class="language-lean">deriving instance BEq, Hashable for Pos
deriving instance BEq, Hashable, Repr for NonEmptyList
</code></pre>
<p>Instance can be derived for at least the following classes:</p>
<ul>
<li><code>Inhabited</code></li>
<li><code>BEq</code></li>
<li><code>Repr</code></li>
<li><code>Hashable</code></li>
<li><code>Ord</code></li>
</ul>
<p>In some cases, however, the derived <code>Ord</code> instance may not produce precisely the ordering desired in an application.
When this is the case, it's fine to write an <code>Ord</code> instance by hand.
The collection of classes for which instances can be derived can be extended by advanced users of Lean.</p>
<p>Aside from the clear advantages in programmer productivity and code readability, deriving instances also makes code easier to maintain, because the instances are updated as the definitions of types evolve.
Changesets involving updates to datatypes are easier to read without line after line of formulaic modifications to equality tests and hash computation.</p>
<h2 id="appending"><a class="header" href="#appending">Appending</a></h2>
<p>Many datatypes have some sort of append operator.
In Lean, appending two values is overloaded with the type class <code>HAppend</code>, which is a heterogeneous operation like that used for arithmetic operations:</p>
<pre><code class="language-lean">class HAppend (α : Type) (β : Type) (γ : outParam Type) where
  hAppend : α → β → γ
</code></pre>
<p>The syntax <code>xs ++ ys</code> desugars to <code>HAppend.hAppend xs ys</code>.
For homogeneous cases, it's enough to implement an instance of <code>Append</code>, which follows the usual pattern:</p>
<pre><code class="language-lean">instance : Append (NonEmptyList α) where
  append xs ys :=
    { head := xs.head, tail := xs.tail ++ ys.head :: ys.tail }
</code></pre>
<p>After defining the above instance,</p>
<pre><code class="language-lean">#eval idahoSpiders ++ idahoSpiders
</code></pre>
<p>has the following output:</p>
<pre><code class="language-output info">{ head := &quot;Banded Garden Spider&quot;,
tail := [&quot;Long-legged Sac Spider&quot;,
         &quot;Wolf Spider&quot;,
         &quot;Hobo Spider&quot;,
         &quot;Cat-faced Spider&quot;,
         &quot;Banded Garden Spider&quot;,
         &quot;Long-legged Sac Spider&quot;,
         &quot;Wolf Spider&quot;,
         &quot;Hobo Spider&quot;,
         &quot;Cat-faced Spider&quot;] }
</code></pre>
<p>Similarly, a definition of <code>HAppend</code> allows non-empty lists to be appended to ordinary lists:</p>
<pre><code class="language-lean">instance : HAppend (NonEmptyList α) (List α) (NonEmptyList α) where
  hAppend xs ys :=
    { head := xs.head, tail := xs.tail ++ ys }
</code></pre>
<p>With this instance available,</p>
<pre><code class="language-lean">#eval idahoSpiders ++ [&quot;Trapdoor Spider&quot;]
</code></pre>
<p>results in</p>
<pre><code class="language-output info">{ head := &quot;Banded Garden Spider&quot;,
  tail := [&quot;Long-legged Sac Spider&quot;, &quot;Wolf Spider&quot;, &quot;Hobo Spider&quot;, &quot;Cat-faced Spider&quot;, &quot;Trapdoor Spider&quot;] }
</code></pre>
<h2 id="functors"><a class="header" href="#functors">Functors</a></h2>
<p>A polymorphic type is a <em>functor</em> if it has an overload for a function named <code>map</code> that transforms every element contained in it by a function.
While most languages use this terminology, C#'s equivalent to <code>map</code> is called <code>System.Linq.Enumerable.Select</code>.
For example, mapping a function over a list constructs a new list in which each entry from the starting list has been replaced by the result of the function on that entry.
Mapping a function <code>f</code> over an <code>Option</code> leaves <code>none</code> untouched, and replaces <code>some x</code> with <code>some (f x)</code>.</p>
<p>Here are some examples of functors and how their <code>Functor</code> instances overload <code>map</code>:</p>
<ul>
<li><code>Functor.map (· + 5) [1, 2, 3]</code> evaluates to <code>[6, 7, 8]</code></li>
<li><code>Functor.map toString (some (List.cons 5 List.nil))</code> evaluates to <code>some &quot;[5]&quot;</code></li>
<li><code>Functor.map List.reverse [[1, 2, 3], [4, 5, 6]]</code> evaluates to <code>[[3, 2, 1], [6, 5, 4]]</code></li>
</ul>
<p>Because <code>Functor.map</code> is a bit of a long name for this common operation, Lean also provides an infix operator for mapping a function, namely <code>&lt;$&gt;</code>.
The prior examples can be rewritten as follows:</p>
<ul>
<li><code>(· + 5) &lt;$&gt; [1, 2, 3]</code> evaluates to <code>[6, 7, 8]</code></li>
<li><code>toString &lt;$&gt; (some (List.cons 5 List.nil))</code> evaluates to <code>some &quot;[5]&quot;</code></li>
<li><code>List.reverse &lt;$&gt; [[1, 2, 3], [4, 5, 6]]</code> evaluates to <code>[[3, 2, 1], [6, 5, 4]]</code></li>
</ul>
<p>An instance of <code>Functor</code> for <code>NonEmptyList</code> requires specifying the <code>map</code> function.</p>
<pre><code class="language-lean">instance : Functor NonEmptyList where
  map f xs := { head := f xs.head, tail := f &lt;$&gt; xs.tail }
</code></pre>
<p>Here, <code>map</code> uses the <code>Functor</code> instance for <code>List</code> to map the function over the tail.
This instance is defined for <code>NonEmptyList</code> rather than for <code>NonEmptyList α</code> because the argument type <code>α</code> plays no role in resolving the type class.
A <code>NonEmptyList</code> can have a function mapped over it <em>no matter what the type of entries is</em>.
If <code>α</code> were a parameter to the class, then it would be possible to make versions of <code>Functor</code> that only worked for <code>NonEmptyList Nat</code>, but part of being a functor is that <code>map</code> works for any entry type.</p>
<p>Here is an instance of <code>Functor</code> for <code>PPoint</code>:</p>
<pre><code class="language-lean">instance : Functor PPoint where
  map f p := { x := f p.x, y := f p.y }
</code></pre>
<p>In this case, <code>f</code> has been applied to both <code>x</code> and <code>y</code>.</p>
<p>Even when the type contained in a functor is itself a functor, mapping a function only goes down one layer.
That is, when using <code>map</code> on a <code>NonEmptyList (PPoint Nat)</code>, the function being mapped should take <code>PPoint Nat</code> as its argument rather than <code>Nat</code>.</p>
<p>The definition of the <code>Functor</code> class uses one more language feature that has not yet been discussed: default method definitions.
Normally, a class will specify some minimal set of overloadable operations that make sense together, and then use polymorphic functions with instance implicit arguments that build on the overloaded operations to provide a larger library of features.
For example, the function <code>concat</code> can concatenate any non-empty list whose entries are appendable:</p>
<pre><code class="language-lean">def concat [Append α] (xs : NonEmptyList α) : α :=
  let rec catList (start : α) : List α → α
    | [] =&gt; start
    | (z :: zs) =&gt; catList (start ++ z) zs
  catList xs.head xs.tail
</code></pre>
<p>However, for some classes, there are operations that can be more efficiently implemented with knowledge of the internals of a datatype.</p>
<p>In these cases, a default method definition can be provided.
A default method definition provides a default implementation of a method in terms of the other methods.
However, instance implementors may choose to override this default with something more efficient.
Default method definitions contain <code>:=</code> in a <code>class</code> definition.</p>
<p>In the case of <code>Functor</code>, some types have a more efficient way of implementing <code>map</code> when the function being mapped ignores its argument.
Functions that ignore their arguments are called <em>constant functions</em> because they always return the same value.
Here is the definition of <code>Functor</code>, in which <code>mapConst</code> has a default implementation:</p>
<pre><code class="language-lean">class Functor (f : Type → Type) where
  map : {α β : Type} → (α → β) → f α → f β

  mapConst {α β : Type} (x : α) (coll : f β) : f α :=
    map (fun _ =&gt; x) coll
</code></pre>
<p>Just as a <code>Hashable</code> instance that doesn't respect <code>BEq</code> is buggy, a <code>Functor</code> instance that moves around the data as it maps the function is also buggy.
For example, a buggy <code>Functor</code> instance for <code>List</code> might throw away its argument and always return the empty list, or it might reverse the list.
A bad instance for <code>PPoint</code> might place <code>f x</code> in both the <code>x</code> and the <code>y</code> fields.
Specifically, <code>Functor</code> instances should follow two rules:</p>
<ol>
<li>Mapping the identity function should result in the original argument.</li>
<li>Mapping two composed functions should have the same effect as composing their mapping.</li>
</ol>
<p>More formally, the first rule says that <code>id &lt;$&gt; x</code> equals <code>x</code>.
The second rule says that <code>map (fun y =&gt; f (g y)) x</code> equals <code>map f (map g x)</code>.
These rules prevent implementations of <code>map</code> that move the data around or delete some of it.</p>
<h2 id="exercises-8"><a class="header" href="#exercises-8">Exercises</a></h2>
<ul>
<li>Write an instance of <code>HAppend (List α) (NonEmptyList α) (NonEmptyList α)</code> and test it.</li>
<li>Implement a <code>Functor</code> instance for the binary tree datatype.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coercions"><a class="header" href="#coercions">Coercions</a></h1>
<p>In mathematics, it is common to use the same symbol to stand for different aspects of some object in different contexts.
For example, if a ring is referred to in a context where a set is expected, then it is understood that the ring's underlying set is what's intended.
In programming languages, it is common to have rules to automatically translate values of one type into values of another type.
For instance, Java allows a <code>byte</code> to be automatically promoted to an <code>int</code>, and Kotlin allows a non-nullable type to be used in a context that expects a nullable version of the type.</p>
<p>In Lean, both purposes are served by a mechanism called <em>coercions</em>.
When Lean encounters an expression of one type in a context that expects a different type, it will attempt to coerce the expression before reporting a type error.
Unlike Java, C, and Kotlin, the coercions are extensible by defining instances of type classes.</p>
<h2 id="positive-numbers-1"><a class="header" href="#positive-numbers-1">Positive Numbers</a></h2>
<p>For example, every positive number corresponds to a natural number.
The function <code>Pos.toNat</code> that was defined earlier converts a <code>Pos</code> to the corresponding <code>Nat</code>:</p>
<pre><code class="language-lean">def Pos.toNat : Pos → Nat
  | Pos.one =&gt; 1
  | Pos.succ n =&gt; n.toNat + 1
</code></pre>
<p>The function <code>List.drop</code>, with type <code>{α : Type} → Nat → List α → List α</code>, removes a prefix of a list.
Applying <code>List.drop</code> to a <code>Pos</code>, however, leads to a type error:</p>
<pre><code class="language-lean">[1, 2, 3, 4].drop (2 : Pos)
</code></pre>
<pre><code class="language-output error">application type mismatch
  List.drop 2
argument
  2
has type
  Pos : Type
but is expected to have type
  Nat : Type
</code></pre>
<p>Because the author of <code>List.drop</code> did not make it a method of a type class, it can't be overridden by defining a new instance.</p>
<p>The type class <code>Coe</code> describes overloaded ways of coercing from one type to another:</p>
<pre><code class="language-lean">class Coe (α : Type) (β : Type) where
  coe : α → β
</code></pre>
<p>An instance of <code>Coe Pos Nat</code> is enough to allow the prior code to work:</p>
<pre><code class="language-lean">instance : Coe Pos Nat where
  coe x := x.toNat

#eval [1, 2, 3, 4].drop (2 : Pos)
</code></pre>
<pre><code class="language-output info">[3, 4]
</code></pre>
<p>Using <code>#check</code> shows the result of the instance search that was used behind the scenes:</p>
<pre><code class="language-lean">#check [1, 2, 3, 4].drop (2 : Pos)
</code></pre>
<pre><code class="language-output info">List.drop (Pos.toNat 2) [1, 2, 3, 4] : List Nat
</code></pre>
<h2 id="chaining-coercions"><a class="header" href="#chaining-coercions">Chaining Coercions</a></h2>
<p>When searching for coercions, Lean will attempt to assemble a coercion out of a chain of smaller coercions.
For example, there is already a coercion from <code>Nat</code> to <code>Int</code>.
Because of that instance, combined with the <code>Coe Pos Nat</code> instance, the following code is accepted:</p>
<pre><code class="language-lean">def oneInt : Int := Pos.one
</code></pre>
<p>This definition uses two coercions: from <code>Pos</code> to <code>Nat</code>, and then from <code>Nat</code> to <code>Int</code>.</p>
<p>The Lean compiler does not get stuck in the presence of circular coercions.
For example, even if two types <code>A</code> and <code>B</code> can be coerced to one another, their mutual coercions can be used to find a path:</p>
<pre><code class="language-lean">inductive A where
  | a

inductive B where
  | b

instance : Coe A B where
  coe _ := B.b

instance : Coe B A where
  coe _ := A.a

instance : Coe Unit A where
  coe _ := A.a

def coercedToB : B := Unit.unit
</code></pre>
<p>Some coercions, however, should only be applied once.
The <code>Option</code> type can be used similarly to nullable types in C# and Kotlin: the <code>none</code> constructor represents the absence of a value.
The Lean standard library defines a coercion from any type <code>α</code> to <code>Option α</code> that wraps the value in in <code>some</code>.
This allows option types to be used in manner even more similar to nullable types, because <code>some</code> can be omitted.
For instance, the function <code>List.getLast?</code> that finds the last entry in a list can be written without a <code>some</code> around the return value <code>x</code>:</p>
<pre><code class="language-lean">def List.last? : List α → Option α
  | [] =&gt; none
  | [x] =&gt; x
  | _ :: x :: xs =&gt; last? (x :: xs)
</code></pre>
<p>Instance search finds the coercion, and inserts a call to <code>coe</code>, which wraps the argument in <code>some</code>.</p>
<p>However, rather than defining a <code>Coe α (Option α)</code> instance, the library defines an instance of a class called <code>CoeTail</code>.
Unlike <code>Coe</code>, <code>CoeTail</code> is consulted only as the last step in a sequence of coercions, and it is used at most once:</p>
<pre><code class="language-lean">instance : CoeTail α (Option α) where
  coe x := some x
</code></pre>
<p>This means that the following definition is rejected, as it would require multiple uses of the coercion:</p>
<pre><code class="language-lean">def perhapsPerhapsPerhaps : Option (Option (Option String)) :=
  &quot;Please don't tell me&quot;
</code></pre>
<pre><code class="language-output error">type mismatch
  &quot;Please don't tell me&quot;
has type
  String : Type
but is expected to have type
  Option (Option (Option String)) : Type
</code></pre>
<p>Similarly, there is a <code>CoeHead</code> class that is used at most once at the beginning of a chain of coercions.</p>
<h2 id="non-empty-lists-and-dependent-coercions"><a class="header" href="#non-empty-lists-and-dependent-coercions">Non-Empty Lists and Dependent Coercions</a></h2>
<p>An instance of <code>Coe α β</code> makes sense when the type <code>β</code> has a value that can represent each value from the type <code>α</code>.
Coercing from <code>Nat</code> to <code>Int</code> makes sense, because the type <code>Int</code> contains all the natural numbers.
Similarly, a coercion from non-empty lists to ordinary lists makes sense because the <code>List</code> type can represent every non-empty list:</p>
<pre><code class="language-lean">instance : Coe (NonEmptyList α) (List α) where
  coe
    | { head := x, tail := xs } =&gt; x :: xs
</code></pre>
<p>This allows non-empty lists to be used with the entire <code>List</code> API.</p>
<p>On the other hand, it is impossible to write an instance of <code>Coe (List α) (NonEmptyList α)</code>, because there's no non-empty list that can represent the empty list.
This limitation can be worked around by using another version of coercions, which are called <em>dependent coercions</em>.
Dependent coercions can be used when the ability to coerce from one type to another depends on which particular value is being coerced.
Just as the <code>OfNat</code> type class takes the particular <code>Nat</code> being overloaded as a parameter, dependent coercion takes the value being coerced as a parameter:</p>
<pre><code class="language-lean">class CoeDep (α : Type) (x : α) (β : Type) where
  coe : β
</code></pre>
<p>This is a chance to select only certain values, either by imposing further type class constraints on the value or by writing certain constructors directly.
For example, any <code>List</code> that is not actually empty can be coerced to a <code>NonEmptyList</code>:</p>
<pre><code class="language-lean">instance : CoeDep (List α) (x :: xs) (NonEmptyList α) where
  coe := { head := x, tail := xs }
</code></pre>
<h2 id="coercing-to-types"><a class="header" href="#coercing-to-types">Coercing to Types</a></h2>
<p>In mathematics, it is common to have a concept that consists of a set equipped with additional structure.
For example, a monoid is some set <em>S</em>, an element <em>s</em> of <em>S</em>, and an associative binary operator on <em>S</em>, such that <em>s</em> is neutral on the left and right of the operator.
<em>S</em> is referred to as the &quot;carrier set&quot; of the monoid.
The natural numbers with zero and addition form a monoid, because addition is associative and adding zero to any number is the identity.
Similarly, the natural numbers with one and multiplication also form a monoid.
Monoids are also widely used in functional programming: lists, the empty list, and the append operator form a monoid, as do strings, the empty string, and string append:</p>
<pre><code class="language-lean">structure Monoid where
  Carrier : Type
  neutral : Carrier
  op : Carrier → Carrier → Carrier

def natMulMonoid : Monoid :=
  { Carrier := Nat, neutral := 1, op := (· * ·) }

def natAddMonoid : Monoid :=
  { Carrier := Nat, neutral := 0, op := (· + ·) }

def stringMonoid : Monoid :=
  { Carrier := String, neutral := &quot;&quot;, op := String.append }

def listMonoid (α : Type) : Monoid :=
  { Carrier := List α, neutral := [], op := List.append }
</code></pre>
<p>Given a monoid, it is possible to write the <code>foldMap</code> function that, in a single pass, transforms the entries in a list into a monoid's carrier set and then combines them using the monoid's operator.
Because monoids have a neutral element, there is a natural result to return when the list is empty, and because the operator is associative, clients of the function don't have to care whether the recursive function combines elements from left to right or from right to left.</p>
<pre><code class="language-lean">def foldMap (M : Monoid) (f : α → M.Carrier) (xs : List α) : M.Carrier :=
  let rec go (soFar : M.Carrier) : List α → M.Carrier
    | [] =&gt; soFar
    | y :: ys =&gt; go (M.op soFar (f y)) ys
  go M.neutral xs
</code></pre>
<p>Even though a monoid consists of three separate pieces of information, it is common to just refer to the monoid's name in order to refer to its set.
Instead of saying &quot;Let A be a monoid and let <em>x</em> and <em>y</em> be elements of its carrier set&quot;, it is common to say &quot;Let <em>A</em> be a monoid and let <em>x</em> and <em>y</em> be elements of <em>A</em>&quot;.
This practice can be encoded in Lean by defining a new kind of coercion, from the monoid to its carrier set.</p>
<p>The <code>CoeSort</code> class is just like the <code>Coe</code> class, with the exception that the target of the coercion must be a <em>sort</em>, namely <code>Type</code> or <code>Prop</code>.
The term <em>sort</em> in Lean refers to these types that classify other types—<code>Type</code> classifies types that themselves classify data, and <code>Prop</code> classifies propositions that themselves classify evidence of their truth.
Just as <code>Coe</code> is checked when a type mismatch occurs, <code>CoeSort</code> is used when something other than a sort is provided in a context where a sort would be expected.</p>
<p>The coercion from a monoid into its carrier set extracts the carrier:</p>
<pre><code class="language-lean">instance : CoeSort Monoid Type where
  coe m := m.Carrier
</code></pre>
<p>With this coercion, the type signatures become less bureaucratic:</p>
<pre><code class="language-lean">def foldMap (M : Monoid) (f : α → M) (xs : List α) : M :=
  let rec go (soFar : M) : List α → M
    | [] =&gt; soFar
    | y :: ys =&gt; go (M.op soFar (f y)) ys
  go M.neutral xs
</code></pre>
<p>Another useful example of <code>CoeSort</code> is used to bridge the gap between <code>Bool</code> and <code>Prop</code>.
As discussed in <a href="type-classes/standard-classes.html#equality-and-ordering">the section on ordering and equality</a>, Lean's <code>if</code> expression expects the condition to be a decidable proposition rather than a <code>Bool</code>.
Programs typically need to be able to branch based on Boolean values, however.
Rather than have two kinds of <code>if</code> expression, the Lean standard library defines a coercion from <code>Bool</code> to the proposition that the <code>Bool</code> in question is equal to <code>true</code>:</p>
<pre><code class="language-lean">instance : CoeSort Bool Prop where
  coe b := b = true
</code></pre>
<p>In this case, the sort in question is <code>Prop</code> rather than <code>Type</code>.</p>
<h2 id="coercing-to-functions"><a class="header" href="#coercing-to-functions">Coercing to Functions</a></h2>
<p>Many datatypes that occur regularly in programming consist of a function along with some extra information about it.
For example, a function might be accompanied by a name to show in logs or by some configuration data.
Additionally, putting a type in a field of a structure, similarly to the <code>Monoid</code> example, can make sense in contexts where there are more than one way to implement an operation and more manual control is needed than type classes would allow.
For example, the specific details of values emitted by a JSON serializer may be important because another application expects a particular format.
Sometimes, the function itself may be derivable from just the configuration data.</p>
<p>A type class called <code>CoeFun</code> can transform values from non-function types to function types.
<code>CoeFun</code> has two parameters: the first is the type whose values should be transformed into functions, and the second is an output parameter that determines exactly which function type is being targeted.</p>
<pre><code class="language-lean">class CoeFun (α : Type) (makeFunctionType : outParam (α → Type)) where
  coe : (x : α) → makeFunctionType x
</code></pre>
<p>The second parameter is itself a function that computes a type.
In Lean, types are first-class and can be passed to functions or returned from them, just like anything else.</p>
<p>For example, a function that adds a constant amount to its argument can be represented as a wrapper around the amount to add, rather than by defining an actual function:</p>
<pre><code class="language-lean">structure Adder where
  howMuch : Nat
</code></pre>
<p>A function that adds five to its argument has a <code>5</code> in the <code>howMany</code> field:</p>
<pre><code class="language-lean">def add5 : Adder := ⟨5⟩
</code></pre>
<p>This <code>Adder</code> type is not a function, and applying it to an argument results in an error:</p>
<pre><code class="language-lean">#eval add5 3
</code></pre>
<pre><code class="language-output error">function expected at
  add5
term has type
  Adder
</code></pre>
<p>Defining a <code>CoeFun</code> instance causes Lean to transform the adder into a function with type <code>Nat → Nat</code>:</p>
<pre><code class="language-lean">instance : CoeFun Adder (fun _ =&gt; Nat → Nat) where
  coe a := (· + a.howMuch)

#eval add5 3
</code></pre>
<pre><code class="language-output info">8
</code></pre>
<p>Because all <code>Adder</code>s should be transformed into <code>Nat → Nat</code> functions, the argument to <code>CoeFun</code>'s second parameter was ignored.</p>
<p>When the value itself is needed to determine the right function type, then <code>CoeFun</code>'s second parameter is no longer ignored.
For example, given the following representation of JSON values:</p>
<pre><code class="language-lean">inductive JSON where
  | true : JSON
  | false : JSON
  | null : JSON
  | string : String → JSON
  | number : Float → JSON
  | object : List (String × JSON) → JSON
  | array : List JSON → JSON
</code></pre>
<p>a JSON serializer is a structure that tracks the type it knows how to serialize along with the serialization code itself:</p>
<pre><code class="language-lean">structure Serializer where
  Contents : Type
  serialize : Contents → JSON
</code></pre>
<p>A serializer for strings need only wrap the provided string in the <code>JSON.string</code> constructor:</p>
<pre><code class="language-lean">def Str : Serializer :=
  { Contents := String,
    serialize := JSON.string
  }
</code></pre>
<p>Viewing JSON serializers as functions that serialize their argument requires extracting the inner type of serializable data:</p>
<pre><code class="language-lean">instance : CoeFun Serializer (fun s =&gt; s.Contents → JSON) where
  coe s := s.serialize
</code></pre>
<p>Given this instance, a serializer can be applied directly to an argument:</p>
<pre><code class="language-lean">def buildResponse (title : String) (R : Serializer) (record : R.Contents) : JSON :=
  JSON.object [
    (&quot;title&quot;, JSON.string title),
    (&quot;status&quot;, JSON.number 200),
    (&quot;record&quot;, R record)
  ]
</code></pre>
<p>The serializer can be passed directly to <code>buildResponse</code>:</p>
<pre><code class="language-lean">#eval (buildResponse &quot;Functional Programming in Lean&quot; Str &quot;Programming is fun!&quot;).asString
</code></pre>
<pre><code class="language-output info">&quot;{\\&quot;title\\&quot;: \\&quot;Functional Programming in Lean\\&quot;, \\&quot;status\\&quot;: 200, \\&quot;record\\&quot;: \\&quot;Programming is fun!\\&quot;}&quot;
</code></pre>
<h2 id="messages-you-may-meet-4"><a class="header" href="#messages-you-may-meet-4">Messages You May Meet</a></h2>
<p>Natural number literals are overloaded with the <code>OfNat</code> type class.
Because coercions fire in cases where types don't match, rather than in cases of missing instances, a missing <code>OfNat</code> instance for a type does not cause a coercion from <code>Nat</code> to be applied:</p>
<pre><code class="language-lean">def perhapsPerhapsPerhapsNat : Option (Option (Option Nat)) :=
  392
</code></pre>
<pre><code class="language-output error">failed to synthesize instance
  OfNat (Option (Option (Option Nat))) 392
</code></pre>
<h2 id="design-considerations"><a class="header" href="#design-considerations">Design Considerations</a></h2>
<p>Coercions are a powerful tool that should be used responsibly.
On the one hand, they can allow an API to naturally follow the everyday rules of the domain being modeled.
This can be the difference between a bureaucratic mess of manual conversion functions and a clear program.
As Abelson and Sussman wrote in the preface to <em>Structure and Interpretation of Computer Programs</em> (MIT Press, 1996),</p>
<blockquote>
<p>Programs must be written for people to read, and only incidentally for machines to execute.</p>
</blockquote>
<p>Coercions, used wisely, are a valuable means of achieving readable code that can serve as the basis for communication with domain experts.
APIs that rely heavily on coercions have a number of important limitations, however.
Think carefully about these limitations before using coercions in your own libraries.</p>
<p>First off,coercions are only applied in contexts where enough type information is available for Lean to know all of the types involved, because there are no output parameters in the coercion type classes. This means that a return type annotation on a function can be the difference between a type error and a successfully applied coercion.
For example, the coercion from non-empty lists to lists makes the following program work:</p>
<pre><code class="language-lean">def lastSpider : Option String :=
  List.getLast? idahoSpiders
</code></pre>
<p>On the other hand, if the type annotation is omitted, then the result type is unknown, so Lean is unable to find the coercion:</p>
<pre><code class="language-lean">def lastSpider :=
  List.getLast? idahoSpiders
</code></pre>
<pre><code class="language-output error">application type mismatch
  List.getLast? idahoSpiders
argument
  idahoSpiders
has type
  NonEmptyList String : Type
but is expected to have type
  List ?m.32988 : Type ?u.32986
</code></pre>
<p>More generally, when a coercion is not applied for some reason, the user receives the original type error, which can make it difficult to debug chains of coercions.</p>
<p>Finally, coercions are not applied in the context of field accessor notation.
This means that there is still an important difference between expressions that need to be coerced and those that don't, and this difference is visible to users of your API.</p>
<h2 id="some-gory-details"><a class="header" href="#some-gory-details">Some Gory Details</a></h2>
<p>This chapter described a somewhat simplified picture of the coercion system.
In fact, <code>Coe</code> is one of three type classes that are used to coerce ordinary expressions from one type to another.
There are also <code>CoeHead</code>, instances of which are applied at most once at the beginning of a chain of coercions, and <code>CoeTail</code>, which is applied at most once following the other coercions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="additional-conveniences-2"><a class="header" href="#additional-conveniences-2">Additional Conveniences</a></h1>
<h2 id="constructor-syntax-for-instances"><a class="header" href="#constructor-syntax-for-instances">Constructor Syntax for Instances</a></h2>
<p>Behind the scenes, type classes are structure types and instances are values of these types.
The only differences are that Lean stores additional information about type classes, such as which parameters are output parameters, and that instances are registered for searching.
While values that have structure types are typically defined using either <code>⟨...⟩</code> syntax or with braces and fields, and instances are typically defined using <code>where</code>, both syntaxes work for both kinds of definition.</p>
<p>For example, a forestry application might represent trees as follows:</p>
<pre><code class="language-lean">structure Tree : Type where
  latinName : String
  commonNames : List String

def oak : Tree :=
  ⟨&quot;Quercus robur&quot;, [&quot;common oak&quot;, &quot;European oak&quot;]⟩

def birch : Tree :=
  { latinName := &quot;Betula pendula&quot;,
    commonNames := [&quot;silver birch&quot;, &quot;warty birch&quot;]
  }

def beech : Tree where
  latinName := &quot;Fagus sylvatica&quot;
  commonNames := [&quot;European beech&quot;, &quot;common beech&quot;]
</code></pre>
<p>All three syntaxes are equivalent.</p>
<p>Similarly, type class instances can be defined using all three syntaxes:</p>
<pre><code class="language-lean">class Display (α : Type) where
  displayName : α → String

instance : Display Tree :=
  ⟨Tree.latinName⟩

instance : Display Tree :=
  { displayName := Tree.latinName }

instance : Display Tree where
  displayName t := t.latinName
</code></pre>
<p>Generally speaking, the <code>where</code> syntax should be used for instances, and the curly-brace syntax should be used for structures.
The <code>⟨...⟩</code> syntax can be useful when emphasizing that a structure type is very much like a tuple in which the fields happen to be named, but the names are not important at the moment.
However, there are situations where it can make sense to use other alternatives.
In particular, a library might provide a function that constructs an instance value.
Placing a call to this function after <code>:=</code> in an instance declaration is the easiest way to use such a function.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>When experimenting with Lean code, definitions can be more convenient to use than <code>#eval</code> or <code>#check</code> commands.
First off, definitions don't produce any output, which can help keep the reader's focus on the most interesting output.
Secondly, it's easiest to write most Lean programs by starting with a type signature, allowing Lean to provide more assistance and better error messages while writing the program itself.
On the other hand, <code>#eval</code> and <code>#check</code> are easiest to use in contexts where Lean is able to determine the type from the provided expression.
Thirdly, <code>#eval</code> cannot be used with expressions whose types don't have <code>ToString</code> or <code>Repr</code> instances, such as functions.
Finally, multi-step <code>do</code> blocks, <code>let</code>-expressions, and other syntactic forms that take multiple lines are particularly difficult to write with a type annotation in <code>#eval</code> or <code>#check</code>, simply because the required parenthesization can be difficult to predict.</p>
<p>To work around these issues, Lean supports the explicit indication of examples in a source file.
An example is like a definition without a name.
For instance, a non-empty list of birds commonly found in Copenhagen's green spaces can be written:</p>
<pre><code class="language-lean">example : NonEmptyList String :=
  { head := &quot;Sparrow&quot;,
    tail := [&quot;Duck&quot;, &quot;Swan&quot;, &quot;Magpie&quot;, &quot;Eurasian coot&quot;, &quot;Crow&quot;]
  }
</code></pre>
<p>Examples may create define functions by accepting arguments:</p>
<pre><code class="language-lean">example (n : Nat) (k : Nat) : Bool :=
  n + k == k + n
</code></pre>
<p>While this creates a function behind the scenes, this function has no name and cannot be called.
Nonetheless, this is useful for demonstrating how a library can be used with arbitrary or unknown values of some given type.
In source files, <code>example</code> declarations are best paired with comments that explain how the example illustrates the concepts of the library.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summary-2"><a class="header" href="#summary-2">Summary</a></h1>
<h2 id="type-classes-and-overloading"><a class="header" href="#type-classes-and-overloading">Type Classes and Overloading</a></h2>
<p>Type classes are Lean's mechanism for overloading functions and operators.
A polymorphic function can be used with multiple types, but it behaves in the same manner no matter which type it is used with.
For example, a polymorphic function that appends two lists can be used no matter the type of the entries in the list, but it is unable to have different behavior depending on which particular type is found.
An operation that is overloaded with type classes, on the other hand, can also be used with multiple types.
However, each type requires its own implementation of the overloaded operation.
This means that the behavior can vary based on which type is provided.</p>
<p>A <em>type class</em> has a name, parameters, and a body that consists of a number of names with types.
The name is a way to refer to the overloaded operations, the parameters determine which aspects of the definitions can be overloaded, and the body provides the names and type signatures of the overloadable operations.
Each overloadable operation is called a <em>method</em> of the type class.
Type classes may provide default implementations of some methods in terms of the others, freeing implementors from defining each overload by hand when it is not needed.</p>
<p>An <em>instance</em> of a type class provides implementations of the methods for given parameters.
Instances may be polymorphic, in which case they can work for a variety of parameters, and they may optionally provide more specific implementations of default methods in cases where a more efficient version exists for some particular type.</p>
<p>Type class parameters are either <em>input parameters</em> (the default), or <em>output parameters</em> (indicated by an <code>outParam</code> modifier).
Lean will not begin searching for an instance until all input parameters are no longer metavariables, while output parameters may be solved while searching for instances.
Parameters to a type class need not be types—they may also be ordinary values.
The <code>OfNat</code> type class, used to overload natural number literals, takes the overloaded <code>Nat</code> itself as a parameter, which allows instances to restrict the allowed numbers.</p>
<p>Instances may be marked with a <code>@[default_instance]</code> attribute.
When an instance is a default instance, then it will be chosen as a fallback when Lean would otherwise fail to find an instance due to the presence of metavariables in the type.</p>
<h2 id="type-classes-for-common-syntax"><a class="header" href="#type-classes-for-common-syntax">Type Classes for Common Syntax</a></h2>
<p>Most infix operators in Lean are overridden with a type class.
For instance, the addition operator corresponds to a type class called <code>Add</code>.
Most of these operators have a corresponding heterogeneous version, in which the two arguments need not have the same type.
These heterogenous operators are overloaded using a version of the class whose name starts with <code>H</code>, such as <code>HAdd</code>.</p>
<p>Indexing syntax is overloaded using a type class called <code>GetElem</code>, which involves proofs.
<code>GetElem</code> has two output parameters, which are the type of elements to be extracted from the collection and a function that can be used to determine what counts as evidence that the index value is in bounds for the collection.
This evidence is described by a proposition, and Lean attempts to prove this proposition when array indexing is used.
When Lean is unable to check that list or array access operations are in bounds at compile time, the check can be deferred to run time by appending a <code>?</code> to the indexing operation.</p>
<h2 id="functors-1"><a class="header" href="#functors-1">Functors</a></h2>
<p>A functor is a polymorphic type that supports a mapping operation.
This mapping operation transforms all elements &quot;in place&quot;, changing no other structure.
For instance, lists are functors and the mapping operation may neither drop, duplicate, nor mix up entries in the list.</p>
<p>While functors are defined by having <code>map</code>, the <code>Functor</code> type class in Lean contains an additional default method that is responsible for mapping the constant function over a value, replacing all values whose type are given by polymorphic type variable with the same new value.
For some functors, this can be done more efficiently than traversing the entire structure.</p>
<h2 id="deriving-instances"><a class="header" href="#deriving-instances">Deriving Instances</a></h2>
<p>Many type classes have very standard implementations.
For instance, the Boolean equality class <code>BEq</code> is usually implemented by first checking whether both arguments are built with the same constructor, and then checking whether all their arguments are equal.
Instances for these classes can be created <em>automatically</em>.</p>
<p>When defining an inductive type or a structure, a <code>deriving</code> clause at the end of the declaration will cause instances to be created automatically.
Additionally, the <code>deriving instance ... for ...</code> command can be used outside of the definition of a datatype to cause an instance to be generated.
Because each class for which instances can be derived requires special handling, not all classes are derivable.</p>
<h2 id="coercions-1"><a class="header" href="#coercions-1">Coercions</a></h2>
<p>Coercions allow Lean to recover from what would normally be a compile-time error by inserting a call to a function that transforms data from one type to another.
For example, the coercion from any type <code>α</code> to the type <code>Option α</code> allows values to be written directly, rather than with the <code>some</code> constructor, making <code>Option</code> work more like nullable types from object-oriented languages.</p>
<p>There are multiple kinds of coercion.
They can recover from different kinds of errors, and they are represented by their own type classes.
The <code>Coe</code> class is used to recover from type errors.
When Lean has an expression of type <code>α</code> in a context that expects something with type <code>β</code>, Lean first attempts to string together a chain of coercions that can transform <code>α</code>s into <code>β</code>s, and only displays the error when this cannot be done.
The <code>CoeDep</code> class takes the specific value being coerced as an extra parameter, allowing either further type class search to be done on the value or allowing constructors to be used in the instance to limit the scope of the conversion.
The <code>CoeFun</code> class intercepts what would otherwise be a &quot;not a function&quot; error when compiling a function application, and allows the value in the function position to be transformed into an actual function if possible.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
