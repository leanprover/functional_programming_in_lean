<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Interlude: Propositions, Proofs, and Indexing - Functional Programming in Lean</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">
        <link rel="stylesheet" href="pygments.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title.html">Functional Programming in Lean</a></li><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="getting-to-know.html"><strong aria-hidden="true">1.</strong> Getting to Know Lean</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-to-know/evaluating.html"><strong aria-hidden="true">1.1.</strong> Evaluating Expressions</a></li><li class="chapter-item expanded "><a href="getting-to-know/types.html"><strong aria-hidden="true">1.2.</strong> Types</a></li><li class="chapter-item expanded "><a href="getting-to-know/functions-and-definitions.html"><strong aria-hidden="true">1.3.</strong> Functions and Definitions</a></li><li class="chapter-item expanded "><a href="getting-to-know/structures.html"><strong aria-hidden="true">1.4.</strong> Structures</a></li><li class="chapter-item expanded "><a href="getting-to-know/datatypes-and-patterns.html"><strong aria-hidden="true">1.5.</strong> Datatypes, Patterns and Recursion</a></li><li class="chapter-item expanded "><a href="getting-to-know/polymorphism.html"><strong aria-hidden="true">1.6.</strong> Polymorphism</a></li><li class="chapter-item expanded "><a href="getting-to-know/conveniences.html"><strong aria-hidden="true">1.7.</strong> Additional Conveniences</a></li><li class="chapter-item expanded "><a href="getting-to-know/summary.html"><strong aria-hidden="true">1.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="hello-world.html"><strong aria-hidden="true">2.</strong> Hello, World!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hello-world/running-a-program.html"><strong aria-hidden="true">2.1.</strong> Running a Program</a></li><li class="chapter-item expanded "><a href="hello-world/step-by-step.html"><strong aria-hidden="true">2.2.</strong> Step By Step</a></li><li class="chapter-item expanded "><a href="hello-world/starting-a-project.html"><strong aria-hidden="true">2.3.</strong> Starting a Project</a></li><li class="chapter-item expanded "><a href="hello-world/cat.html"><strong aria-hidden="true">2.4.</strong> Worked Example: cat</a></li><li class="chapter-item expanded "><a href="hello-world/conveniences.html"><strong aria-hidden="true">2.5.</strong> Additional Conveniences</a></li><li class="chapter-item expanded "><a href="hello-world/summary.html"><strong aria-hidden="true">2.6.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="props-proofs-indexing.html" class="active"><strong aria-hidden="true">3.</strong> Interlude: Propositions, Proofs, and Indexing</a></li><li class="chapter-item expanded "><a href="type-classes.html"><strong aria-hidden="true">4.</strong> Overloading and Type Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="type-classes/pos.html"><strong aria-hidden="true">4.1.</strong> Positive Numbers</a></li><li class="chapter-item expanded "><a href="type-classes/polymorphism.html"><strong aria-hidden="true">4.2.</strong> Type Classes and Polymorphism</a></li><li class="chapter-item expanded "><a href="type-classes/out-params.html"><strong aria-hidden="true">4.3.</strong> Controlling Instance Search</a></li><li class="chapter-item expanded "><a href="type-classes/indexing.html"><strong aria-hidden="true">4.4.</strong> Arrays and Indexing</a></li><li class="chapter-item expanded "><a href="type-classes/standard-classes.html"><strong aria-hidden="true">4.5.</strong> Standard Classes</a></li><li class="chapter-item expanded "><a href="type-classes/coercion.html"><strong aria-hidden="true">4.6.</strong> Coercions</a></li><li class="chapter-item expanded "><a href="type-classes/conveniences.html"><strong aria-hidden="true">4.7.</strong> Additional Conveniences</a></li><li class="chapter-item expanded "><a href="type-classes/summary.html"><strong aria-hidden="true">4.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="monads.html"><strong aria-hidden="true">5.</strong> Monads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="monads/class.html"><strong aria-hidden="true">5.1.</strong> The Monad Type Class</a></li><li class="chapter-item expanded "><a href="monads/arithmetic.html"><strong aria-hidden="true">5.2.</strong> Example: Arithmetic in Monads</a></li><li class="chapter-item expanded "><a href="monads/do.html"><strong aria-hidden="true">5.3.</strong> do-Notation for Monads</a></li><li class="chapter-item expanded "><a href="monads/io.html"><strong aria-hidden="true">5.4.</strong> The IO Monad</a></li><li class="chapter-item expanded "><a href="monads/conveniences.html"><strong aria-hidden="true">5.5.</strong> Additional Conveniences</a></li><li class="chapter-item expanded "><a href="monads/summary.html"><strong aria-hidden="true">5.6.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="functor-applicative-monad.html"><strong aria-hidden="true">6.</strong> Functors, Applicative Functors, and Monads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="functor-applicative-monad/inheritance.html"><strong aria-hidden="true">6.1.</strong> Structures and Inheritance</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/applicative.html"><strong aria-hidden="true">6.2.</strong> Applicative Functors</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/applicative-contract.html"><strong aria-hidden="true">6.3.</strong> The Applicative Contract</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/alternative.html"><strong aria-hidden="true">6.4.</strong> Alternatives</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/universes.html"><strong aria-hidden="true">6.5.</strong> Universes</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/complete.html"><strong aria-hidden="true">6.6.</strong> The Complete Definitions</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/summary.html"><strong aria-hidden="true">6.7.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Monad Transformers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Programming with Dependent Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> From Programming to Proving</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Functional Programming in Lean</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="interlude-propositions-proofs-and-indexing"><a class="header" href="#interlude-propositions-proofs-and-indexing">Interlude: Propositions, Proofs, and Indexing</a></h1>
<p>Like many languages, Lean uses square brackets for indexing into arrays and lists.
For instance, if <code>woodlandCritters</code> is defined as follows:</p>
<pre><code class="language-lean">def woodlandCritters : List String :=
  [&quot;hedgehog&quot;, &quot;deer&quot;, &quot;snail&quot;]
</code></pre>
<p>then the individual components can be extracted:</p>
<pre><code class="language-lean">def hedgehog := woodlandCritters[0]
def deer := woodlandCritters[1]
def snail := woodlandCritters[2]
</code></pre>
<p>However, attempting to extract the fourth element results in a compile-time error, rather than a run-time error:</p>
<pre><code class="language-lean">def oops := woodlandCritters[3]
</code></pre>
<pre><code class="language-output error">failed to prove index is valid, possible solutions:
  - Use `have`-expressions to prove the index is valid
  - Use `a[i]!` notation instead, runtime check is perfomed, and 'Panic' error message is produced if index is not valid
  - Use `a[i]?` notation instead, result is an `Option` type
  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid
⊢ 3 &lt; List.length woodlandCritters
</code></pre>
<p>This error message is saying Lean tried to automatically mathematically prove that <code>3 &lt; List.length woodlandCritters</code>, which would mean that the lookup was safe, but that it could not do so.
Out-of-bounds errors are a common class of bugs, and Lean uses its dual nature as a programming language and a theorem prover to rule out as many as possible.</p>
<p>Understanding how this works requires an understanding of three key ideas: propositions, proofs, and tactics.</p>
<h2 id="propositions-and-proofs"><a class="header" href="#propositions-and-proofs">Propositions and Proofs</a></h2>
<p>A <em>proposition</em> is a statement that can be true or false.
All of the following are propositions:</p>
<ul>
<li>1 + 1 = 2</li>
<li>Addition is commutative</li>
<li>There are infinitely many prime numbers</li>
<li>1 + 1 = 15</li>
<li>Paris is the capital of France</li>
<li>Buenos Aires is the capital of South Korea</li>
<li>All birds can fly</li>
</ul>
<p>On the other hand, nonsense statements are not propositions.
None of the following are propositions:</p>
<ul>
<li>1 + green = ice cream</li>
<li>All capital cities are prime numbers</li>
<li>At least one gorg is a fleep</li>
</ul>
<p>Propositions come in two varieties: those that are purely mathematical, relying only on our definitions of concepts, and those that are facts about the world.
Theorem provers like Lean are concerned with the former category, and have nothing to say about the flight capabilities of penguins or the legal status of cities.</p>
<p>A <em>proof</em> is a convincing argument that a proposition is true.
For mathematical propositions, these arguments make use of the definitions of the concepts that are involved as well as the rules of logical argumentation.
Most proofs are written for people to understand, and leave out many tedious details.
Computer-aided theorem provers like Lean are designed to allow mathematicians to write proofs while omitting many details, while the software fills in the missing explicit steps, decreasing the likelihood of oversights or mistakes.</p>
<p>In Lean, a program's type describes the ways it can be interacted with.
For instance, a program of type <code>Nat → List String</code> is a function that takes a <code>Nat</code> argument and produces a list of strings.
In other words, each type specifies what counts as a program with that type.</p>
<p>In Lean, propositions are a kind of type that describes what counts as evidence that it is true.
The proposition is proved by providing this evidence.
On the other hand, if the proposition is false, then it will be impossible to construct this evidence.</p>
<p>For example, the proposition &quot;1 + 1 = 2&quot; can be written directly in Lean.
The evidence for this proposition is the constructor <code>rfl</code>, which is short for <em>reflexivity</em>:</p>
<pre><code class="language-lean">def onePlusOneIsTwo : 1 + 1 = 2 := rfl
</code></pre>
<p>On the other hand, <code>rfl</code> does not prove the false proposition &quot;1 + 1 = 15&quot;:</p>
<pre><code class="language-lean">def onePlusOneIsFifteen : 1 + 1 = 15 := rfl
</code></pre>
<pre><code class="language-output error">type mismatch
  rfl
has type
  1 + 1 = 1 + 1 : Prop
but is expected to have type
  1 + 1 = 15 : Prop
</code></pre>
<p>This error message indicates that <code>rfl</code> can prove that two expressions are equal when both sides of the equality statement are already the same number.
Because <code>1 + 1</code> evaluates directly to <code>2</code>, they are considered to be the same, which allows <code>onePlusOneIsTwo</code> to be accepted.
Just as <code>Type</code> describes types such as <code>Nat</code>, <code>String</code>, and <code>List (Nat × String × (Int → Float))</code> that represent data structures and functions, <code>Prop</code> describes propositions.</p>
<p>When a proposition has been proven, it is called a <em>theorem</em>.
In Lean, it is conventional to declare theorems with the <code>theorem</code> keyword instead of <code>def</code>.
This helps readers see which declarations are intended to be read as mathematical proofs, and which are definitions.
Generally speaking, with a proof, what matters is that there is evidence that a proposition is true, but it's not particularly important <em>which</em> evidence was provided.
With definitions, on the other hand, it matters very much which particular value is selected—after all, a definition of addition that always returns <code>0</code> is clearly wrong.</p>
<p>The prior example could be rewritten as follows:</p>
<pre><code class="language-lean">def OnePlusOneIsTwo : Prop := 1 + 1 = 2

theorem onePlusOneIsTwo : OnePlusOneIsTwo := rfl
</code></pre>
<h2 id="tactics"><a class="header" href="#tactics">Tactics</a></h2>
<p>Proofs are normally written using <em>tactics</em>, rather than by providing evidence directly.
Tactics are small programs that construct evidence for a proposition.
These programs run in a <em>proof state</em> that tracks the statement that is to be proved (called the <em>goal</em>) along with the assumptions that are available to prove it.
Running a tactic on a goal results in a new proof state that contains new goals.
The proof is complete when all goals have been proven.</p>
<p>To write a proof with tactics, begin the definition with <code>by</code>.
Writing <code>by</code> puts Lean into tactic mode until the end of the next indented block.
While in tactic mode, Lean provides ongoing feedback about the current proof state.
Written with tactics, <code>onePlusOneIsTwo</code> is still quite short:</p>
<pre><code class="language-lean">theorem onePlusOneIsTwo : 1 + 1 = 2 := by
  simp
</code></pre>
<p>The <code>simp</code> tactic, short for &quot;simplify&quot;, is the workhorse of Lean proofs.
It rewrites the goal to as simple a form as possible, taking care of parts of the proof that are small enough.
In particular, it proves simple equality statements.
Behind the scenes, a detailed formal proof is constructed, but using <code>simp</code> hides this complexity.</p>
<p>Tactics are useful for a number of reasons:</p>
<ol>
<li>Many proofs are complicated and tedious when written out down to the smallest detail, and tactics can automate these uninteresting parts.</li>
<li>Proofs written with tactics are easier to maintain over time, because flexible automation can paper over small changes to definitions.</li>
<li>Because a single tactic can prove many different theorems, Lean can use tactics behind the scenes to free users from writing proofs by hand. For instance, an array lookup requires a proof that the index is in bounds, and a tactic can typically construct that proof without the user needing to worry about it.</li>
</ol>
<p>Behind the scenes, indexing notation uses a tactic to prove that the user's lookup operation is safe.
This tactic is <code>simp</code>, configured to take certain arithmetic identities into account.</p>
<h2 id="connectives"><a class="header" href="#connectives">Connectives</a></h2>
<p>The basic building blocks of logic, such as &quot;and&quot;, &quot;or&quot;, &quot;true&quot;, &quot;false&quot;, and &quot;not&quot;, are called <em>logical connectives</em>.
Each connective defines what counts as evidence of its truth.
For example, to prove a statement &quot;<em>A</em> and <em>B</em>&quot;, one must prove both <em>A</em> and <em>B</em>.
This means that evidence for &quot;<em>A</em> and <em>B</em>&quot; is a pair that contains both evidence for <em>A</em> and evidence for <em>B</em>.
Similarly, evidence for &quot;<em>A</em> or <em>B</em>&quot; consists of either evidence for <em>A</em> or evidence for <em>B</em>.</p>
<p>In particular, most of these connectives are defined like datatypes, and they have constructors.
If <code>A</code> and <code>B</code> are propositions, then &quot;<code>A</code> and <code>B</code>&quot; (written <code>A ∧ B</code>) is a proposition.
Evidence for <code>A ∧ B</code> consists of the constructor <code>And.intro</code>, which has the type <code>A → B → A ∧ B</code>.
Replacing <code>A</code> and <code>B</code> with concrete propositions, it is possible to prove <code>1 + 1 = 2 ∧ &quot;Str&quot;.append &quot;ing&quot; = &quot;String&quot;</code> with <code>And.intro rfl rfl</code>.
Of course, <code>simp</code> is also powerful enough to find this proof:</p>
<pre><code class="language-lean">theorem addAndAppend : 1 + 1 = 2 ∧ &quot;Str&quot;.append &quot;ing&quot; = &quot;String&quot; := by simp
</code></pre>
<p>Similarly, &quot;<code>A</code> or <code>B</code>&quot; (written <code>A ∨ B</code>) has two constructors, because a proof of &quot;<code>A</code> or <code>B</code>&quot; requires only that one of the two underlying propositions be true.
There are two constructors: <code>Or.inl</code>, with type <code>A → A ∨ B</code>, and <code>Or.inr</code>, with type <code>B → A ∨ B</code>.</p>
<p>Implication (if <em>A</em> then <em>B</em>) is represented using functions.
In particular, a function that transforms evidence for <em>A</em> into evidence for <em>B</em> is itself evidence that <em>A</em> implies <em>B</em>.
This is different from the usual description of implication, in which <code>A → B</code> is shorthand for <code>¬A ∨ B</code>, but the two formulations are equivalent.</p>
<p>Because evidence for an &quot;and&quot; is a constructor, it can be used with pattern matching.
For instance, a proof that <em>A</em> and <em>B</em> implies <em>A</em> or <em>B</em> is a function that pulls the evidence of <em>A</em> (or of <em>B</em>) out of the evidence for <em>A</em> and <em>B</em>, and then uses this evidence to produce evidence of <em>A</em> or <em>B</em>:</p>
<pre><code class="language-lean">theorem andImpliesOr : A ∧ B → A ∨ B :=
  fun andEvidence =&gt;
    match andEvidence with
    | And.intro a b =&gt; Or.inl a
</code></pre>
<table><thead><tr><th>Connective</th><th>Lean Syntax</th><th>Evidence</th></tr></thead><tbody>
<tr><td>True</td><td><code>True</code></td><td><code>True.intro : True</code></td></tr>
<tr><td>False</td><td><code>False</code></td><td>No evidence</td></tr>
<tr><td><em>A</em> and <em>B</em></td><td><code>A ∧ B</code></td><td><code>And.intro : A → B → A ∧ B</code></td></tr>
<tr><td><em>A</em> or <em>B</em></td><td><code>A ∨ B</code></td><td>Either <code>Or.inl : A → A ∨ B</code> or <code>Or.inr : B → A ∨ B</code></td></tr>
<tr><td><em>A</em> implies <em>B</em></td><td><code>A → B</code></td><td>A function that transforms evidence of <em>A</em> into evidence of <em>B</em></td></tr>
<tr><td>not <em>A</em></td><td><code>¬A</code></td><td>A function that would transform evidence of <em>A</em> into evidence of <code>False</code></td></tr>
</tbody></table>
<p>The <code>simp</code> tactic can prove theorems that use these connectives.
For example:</p>
<pre><code class="language-lean">theorem onePlusOneAndLessThan : 1 + 1 = 2 ∨ 3 &lt; 5 := by simp
theorem notTwoEqualFive : ¬(1 + 1 = 5) := by simp
theorem trueIsTrue : True := True.intro
theorem trueOrFalse : True ∨ False := by simp
theorem falseImpliesTrue : False → True := by simp
</code></pre>
<h2 id="evidence-as-arguments"><a class="header" href="#evidence-as-arguments">Evidence as Arguments</a></h2>
<p>While <code>simp</code> does a great job proving propositions that involve equalities and inequalities of specific numbers, it is not very good at proving statements that involve variables.
For instance, <code>simp</code> can prove that <code>4 &lt; 15</code>, but it can't easily tell that because <code>x &lt; 4</code>, it's also true that <code>x &lt; 15</code>.
Because index notation uses <code>simp</code> behind the scenes to prove that array access is safe, it can require a bit of hand-holding.</p>
<p>One of the easiest ways to make indexing notation work well is to have the function that performs a lookup into a data structure take the required evidence of safety as an argument.
For instance, a function that returns the third entry in a list is not generally safe because lists might contain zero, one, or two entries:</p>
<pre><code class="language-lean">def third (xs : List α) : α := xs[2]
</code></pre>
<pre><code class="language-output error">failed to prove index is valid, possible solutions:
  - Use `have`-expressions to prove the index is valid
  - Use `a[i]!` notation instead, runtime check is perfomed, and 'Panic' error message is produced if index is not valid
  - Use `a[i]?` notation instead, result is an `Option` type
  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid
α : Type ?u.3908
xs : List α
⊢ 2 &lt; List.length xs
</code></pre>
<p>However, the obligation to show that the list has at least three entries can be imposed on the caller by adding an argument that consists of evidence that the indexing operation is safe:</p>
<pre><code class="language-lean">def third (xs : List α) (ok : xs.length &gt; 2) : α := xs[2]
</code></pre>
<p>When the function is called on a concrete list, its length is known.
In these cases, <code>by simp</code> can construct the evidence automatically:</p>
<pre><code class="language-lean">#eval third woodlandCritters (by simp)
</code></pre>
<pre><code class="language-output info">&quot;snail&quot;
</code></pre>
<h2 id="indexing-without-evidence"><a class="header" href="#indexing-without-evidence">Indexing Without Evidence</a></h2>
<p>In cases where it's not practical to prove that an indexing operation is in bounds, there are other alternatives.
Adding an question mark results in an <code>Option</code>, where the result is <code>some</code> if the index is in bounds, and <code>none</code> otherwise.
For example:</p>
<pre><code class="language-lean">def thirdOption (xs : List α) : Option α := xs[2]?

#eval thirdOption woodlandCritters
</code></pre>
<pre><code class="language-output info">some &quot;snail&quot;
</code></pre>
<pre><code class="language-lean">#eval thirdOption [&quot;only&quot;, &quot;two&quot;]
</code></pre>
<pre><code class="language-output info">none
</code></pre>
<p>There is also a version that crashes the program when the index is out of bounds:</p>
<pre><code class="language-lean">#eval woodlandCritters[1]!
</code></pre>
<pre><code class="language-output info">&quot;deer&quot;
</code></pre>
<p>Be careful!
Because code that is run with <code>#eval</code> runs in the context of the Lean compiler, selecting the wrong index can crash your IDE.</p>
<h2 id="messages-you-may-meet"><a class="header" href="#messages-you-may-meet">Messages You May Meet</a></h2>
<p>In addition to the error that occurs when Lean is unable to find compile-time evidence that an indexing operation is safe, polymorphic functions that use unsafe indexing may produce the following message:</p>
<pre><code class="language-lean">def unsafeThird (xs : List α) : α := xs[2]!
</code></pre>
<pre><code class="language-output error">failed to synthesize instance
  Inhabited α
</code></pre>
<p>This is due to a technical restriction that is part of keeping Lean usable as both a logic for proving theorems and a programming language.
In particular, only programs whose types contain at least one value are allowed to crash.
This is because a proposition in Lean is a kind of type that classifies evidence of its truth.
False propositions have no such evidence.
If a program with an empty type could crash, then that crashing program could be used as a kind of fake evidence for a false proposition.</p>
<p>Internally, Lean contains a table of types that are known to have at least one value.
This error is saying that some arbitrary type <code>α</code> is not necessarily in that table.
The next chapter describes how to add to this table, and how to successfully write functions like <code>unsafeThird</code>.</p>
<p>Adding whitespace between a list and the brackets used for lookup can cause another message:</p>
<pre><code class="language-lean">#eval woodlandCritters [1]
</code></pre>
<pre><code class="language-output error">function expected at
  woodlandCritters
term has type
  List String
</code></pre>
<p>Adding a space causes Lean to treat the expression as a function application, and the index as a list that contains a single number.
This error message results from having Lean attempt to treat <code>woodlandCritters</code> as a function.</p>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<ul>
<li>Prove the following theorems using <code>rfl</code>: <code>2 + 3 = 5</code>, <code>15 - 8 = 7</code>, <code>&quot;Hello, &quot;.append &quot;world&quot; = &quot;Hello, world&quot;</code>, <code>5 &lt; 18</code>.</li>
<li>Prove the following theorems using <code>by simp</code>: <code>2 + 3 = 5</code>, <code>15 - 8 = 7</code>, <code>&quot;Hello, &quot;.append &quot;world&quot; = &quot;Hello, world&quot;</code>, <code>5 &lt; 18</code>.</li>
<li>Write a function that looks up the fifth entry in a list. Pass the evidence that this lookup is safe as an argument to the function.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="hello-world/summary.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="type-classes.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="hello-world/summary.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="type-classes.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
