<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Polymorphism - Functional Programming in Lean</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">
        <link rel="stylesheet" href="../pygments.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../title.html">Functional Programming in Lean</a></li><li class="chapter-item expanded affix "><a href="../introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="../getting-to-know.html"><strong aria-hidden="true">1.</strong> Getting to Know Lean</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-to-know/evaluating.html"><strong aria-hidden="true">1.1.</strong> Evaluating Expressions</a></li><li class="chapter-item expanded "><a href="../getting-to-know/types.html"><strong aria-hidden="true">1.2.</strong> Types</a></li><li class="chapter-item expanded "><a href="../getting-to-know/functions-and-definitions.html"><strong aria-hidden="true">1.3.</strong> Functions and Definitions</a></li><li class="chapter-item expanded "><a href="../getting-to-know/structures.html"><strong aria-hidden="true">1.4.</strong> Structures</a></li><li class="chapter-item expanded "><a href="../getting-to-know/datatypes-and-patterns.html"><strong aria-hidden="true">1.5.</strong> Datatypes, Patterns and Recursion</a></li><li class="chapter-item expanded "><a href="../getting-to-know/polymorphism.html" class="active"><strong aria-hidden="true">1.6.</strong> Polymorphism</a></li><li class="chapter-item expanded "><a href="../getting-to-know/conveniences.html"><strong aria-hidden="true">1.7.</strong> Additional Conveniences</a></li><li class="chapter-item expanded "><a href="../getting-to-know/summary.html"><strong aria-hidden="true">1.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../hello-world.html"><strong aria-hidden="true">2.</strong> Hello, World!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../hello-world/running-a-program.html"><strong aria-hidden="true">2.1.</strong> Running a Program</a></li><li class="chapter-item expanded "><a href="../hello-world/step-by-step.html"><strong aria-hidden="true">2.2.</strong> Step By Step</a></li><li class="chapter-item expanded "><a href="../hello-world/starting-a-project.html"><strong aria-hidden="true">2.3.</strong> Starting a Project</a></li><li class="chapter-item expanded "><a href="../hello-world/cat.html"><strong aria-hidden="true">2.4.</strong> Worked Example: cat</a></li><li class="chapter-item expanded "><a href="../hello-world/conveniences.html"><strong aria-hidden="true">2.5.</strong> Additional Conveniences</a></li><li class="chapter-item expanded "><a href="../hello-world/summary.html"><strong aria-hidden="true">2.6.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../props-proofs-indexing.html"><strong aria-hidden="true">3.</strong> Interlude: Propositions, Proofs, and Indexing</a></li><li class="chapter-item expanded "><a href="../type-classes.html"><strong aria-hidden="true">4.</strong> Overloading and Type Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../type-classes/pos.html"><strong aria-hidden="true">4.1.</strong> Positive Numbers</a></li><li class="chapter-item expanded "><a href="../type-classes/polymorphism.html"><strong aria-hidden="true">4.2.</strong> Type Classes and Polymorphism</a></li><li class="chapter-item expanded "><a href="../type-classes/out-params.html"><strong aria-hidden="true">4.3.</strong> Controlling Instance Search</a></li><li class="chapter-item expanded "><a href="../type-classes/indexing.html"><strong aria-hidden="true">4.4.</strong> Arrays and Indexing</a></li><li class="chapter-item expanded "><a href="../type-classes/standard-classes.html"><strong aria-hidden="true">4.5.</strong> Standard Classes</a></li><li class="chapter-item expanded "><a href="../type-classes/coercion.html"><strong aria-hidden="true">4.6.</strong> Coercions</a></li><li class="chapter-item expanded "><a href="../type-classes/conveniences.html"><strong aria-hidden="true">4.7.</strong> Additional Conveniences</a></li><li class="chapter-item expanded "><a href="../type-classes/summary.html"><strong aria-hidden="true">4.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../monads.html"><strong aria-hidden="true">5.</strong> Monads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monads/class.html"><strong aria-hidden="true">5.1.</strong> The Monad Type Class</a></li><li class="chapter-item expanded "><a href="../monads/arithmetic.html"><strong aria-hidden="true">5.2.</strong> Example: Arithmetic in Monads</a></li><li class="chapter-item expanded "><a href="../monads/do.html"><strong aria-hidden="true">5.3.</strong> do-Notation for Monads</a></li><li class="chapter-item expanded "><a href="../monads/io.html"><strong aria-hidden="true">5.4.</strong> The IO Monad</a></li><li class="chapter-item expanded "><a href="../monads/conveniences.html"><strong aria-hidden="true">5.5.</strong> Additional Conveniences</a></li><li class="chapter-item expanded "><a href="../monads/summary.html"><strong aria-hidden="true">5.6.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../functor-applicative-monad.html"><strong aria-hidden="true">6.</strong> Functors, Applicative Functors, and Monads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../functor-applicative-monad/inheritance.html"><strong aria-hidden="true">6.1.</strong> Structures and Inheritance</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative.html"><strong aria-hidden="true">6.2.</strong> Applicative Functors</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative-contract.html"><strong aria-hidden="true">6.3.</strong> The Applicative Contract</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/alternative.html"><strong aria-hidden="true">6.4.</strong> Alternatives</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/universes.html"><strong aria-hidden="true">6.5.</strong> Universes</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/complete.html"><strong aria-hidden="true">6.6.</strong> The Complete Definitions</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/summary.html"><strong aria-hidden="true">6.7.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Monad Transformers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Programming with Dependent Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> From Programming to Proving</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Functional Programming in Lean</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="polymorphism"><a class="header" href="#polymorphism">Polymorphism</a></h1>
<p>Just as in most languages, types in Lean can take arguments.
For instance, the type <code>List Nat</code> describes lists of natural numbers, <code>List String</code> describes lists of strings, and <code>List (List Point)</code> describes lists of lists of points.
This is very similar to <code>List&lt;Nat&gt;</code>, <code>List&lt;String&gt;</code>, or <code>List&lt;List&lt;Point&gt;&gt;</code> in a language like C# or Java.
Just as Lean uses a space to pass an argument to a function, it uses a space to pass an argument to a type.</p>
<p>In functional programming, the term <em>polymorphism</em> typically refers to datatypes and definitions that take types as arguments.
This is different from the object-oriented programming community, where the term typically refers to subclasses that may override some behavior of their superclass.
In this book, &quot;polymorphism&quot; always refers to the first sense of the word.
These type arguments can be used in the datatype or definition, which allows the same datatype or definition to be used with any type that results from replacing the arguments' names with some other types.</p>
<p>The <code>Point</code> structure requires that both the <code>x</code> and <code>y</code> fields are <code>Float</code>s.
There is, however, nothing about points that require a specific representation for each coordinate.
A polymorphic version of <code>Point</code>, called <code>PPoint</code>, can take a type as an argument, and then use that type for both fields:</p>
<pre><code class="language-lean">structure PPoint (α : Type) where
  x : α
  y : α
deriving Repr
</code></pre>
<p>Just as a function definition's arguments are written immediately after the name being defined, a structure's arguments are written immediately after the structure's name.
It is customary to use Greek letters to name type arguments in Lean when no more specific name suggests itself.
<code>Type</code> is a type that describes other types, so <code>Nat</code>, <code>List String</code>, and <code>PPoint Int</code> all have type <code>Type</code>.</p>
<p>Just like <code>List</code>, <code>PPoint</code> can be used by providing a specific type as its argument:</p>
<pre><code class="language-lean">def natOrigin : PPoint Nat :=
  { x := Nat.zero, y := Nat.zero }
</code></pre>
<p>In this example, both fields are expected to be <code>Nat</code>s.
Just as a function is called by replacing its argument variables with its argument values, providing <code>PPoint</code> with the type <code>Nat</code> as an argument yields a structure in which the fields <code>x</code> and <code>y</code> have the type <code>Nat</code>, because the argument name <code>α</code> has been replaced by the argument type <code>Nat</code>.
Because types are ordinary expressions in Lean, passing arguments to polymorphic types (like <code>PPoint</code>) doesn't require any special syntax.</p>
<p>Definitions may also take types as arguments, which makes them polymorphic.
The function <code>replaceX</code> replaces the <code>x</code> field of a <code>PPoint</code> with a new value.
In order to allow <code>replaceX</code> to work with <em>any</em> polymorphic point, it must be polymorphic itself.
This is achieved by having its first argument be the type of the point's fields, with later arguments referring back to the first argument's name.</p>
<pre><code class="language-lean">def replaceX (α : Type) (point : PPoint α) (newX : α) : PPoint α :=
  { point with x := newX }
</code></pre>
<p>In other words, when the types of the arguments <code>point</code> and <code>newX</code> mention <code>α</code>, they are referring to <em>whichever type was provided as the first argument</em>.
This is similar to the way that function argument names refer to the values that were provided when they occur in the function's body.</p>
<p>This can be seen by asking Lean to check the type of <code>replaceX</code>, and then asking it to check the type of <code>replaceX Nat</code>.</p>
<pre><code class="language-lean">#check (replaceX)
</code></pre>
<pre><code class="language-output info">replaceX : (α : Type) → PPoint α → α → PPoint α
</code></pre>
<p>This function type includes the <em>name</em> of the first argument, and later arguments in the type refer back to this name.
Just as the value of a function application is found by replacing the argument name with the provided argument value in the function's body, the type of a function application is found by replacing the argument's name with the provided value in the function's return type.
Providing the first argument, <code>Nat</code>, causes all occurrences of <code>α</code> in the remainder of the type to be replaced with <code>Nat</code>:</p>
<pre><code class="language-lean">#check replaceX Nat
</code></pre>
<pre><code class="language-output info">replaceX Nat : PPoint Nat → Nat → PPoint Nat
</code></pre>
<p>Because the remaining arguments are not explicitly named, no further substitution occurs as more arguments are provided:</p>
<pre><code class="language-lean">#check replaceX Nat natOrigin
</code></pre>
<pre><code class="language-output info">replaceX Nat natOrigin : Nat → PPoint Nat
</code></pre>
<pre><code class="language-lean">#check replaceX Nat natOrigin 5
</code></pre>
<pre><code class="language-output info">replaceX Nat natOrigin 5 : PPoint Nat
</code></pre>
<p>The fact that the type of the whole function application expression was determined by passing a type as an argument has no bearing on the ability to evaluate it.</p>
<pre><code class="language-lean">#eval replaceX Nat natOrigin 5
</code></pre>
<pre><code class="language-output info">{ x := 5, y := 0 }
</code></pre>
<p>Polymorphic functions work by taking a named type argument and having later types refer to the argument's name.
However, there's nothing special about type arguments that allows them to be named.
Given a datatype that represents positive or negative signs:</p>
<pre><code class="language-lean">inductive Sign where
  | pos
  | neg
</code></pre>
<p>it is possible to write a function whose argument is a sign.
If the argument is positive, the function returns a <code>Nat</code>, while if it's negative, it returns an <code>Int</code>:</p>
<pre><code class="language-lean">def posOrNegThree (s : Sign) : match s with | Sign.pos =&gt; Nat | Sign.neg =&gt; Int :=
  match s with
  | Sign.pos =&gt; (3 : Nat)
  | Sign.neg =&gt; (-3 : Int)
</code></pre>
<p>Because types are first class and can be computed using the ordinary rules of the Lean language, they can be computed by pattern-matching against a datatype.
When Lean is checking this function, it uses the fact that the function's body pattern-matches to run the same pattern in the type, showing that <code>Nat</code> is the expected type for the <code>pos</code> case and that <code>Int</code> is the expected type for the <code>neg</code> case.</p>
<h2 id="linked-lists"><a class="header" href="#linked-lists">Linked Lists</a></h2>
<p>Lean's standard library includes a canonical linked list datatype, called <code>List</code>, and special syntax that makes it more convenient to use.
Lists are written in square brackets.
For instance, a list that contains the prime numbers less than 10 can be written:</p>
<pre><code class="language-lean">def primesUnder10 : List Nat := [2, 3, 5, 7]
</code></pre>
<p>Behind the scenes, <code>List</code> is an inductive datatype, defined like this:</p>
<pre><code class="language-lean">inductive List (α : Type) where
  | nil : List α
  | cons : α → List α → List α
</code></pre>
<p>The actual definition in the standard library is slightly different, because it uses features that have not yet been presented, but it is substantially similar.
This definition says that <code>List</code> takes a single type as its argument, just as <code>PPoint</code> did.
This type is the type of the entries stored in the list.
According to the constructors, a <code>List α</code> can be built with either <code>nil</code> or <code>cons</code>.
The constructor <code>nil</code> represents empty lists, and the constructor <code>cons</code> represents a single element in the linked list.
The first argument to <code>cons</code> is the head of the list, and the second argument is its tail.</p>
<p>The <code>primesUnder10</code> example can be written more explicitly by using <code>List</code>'s constructors directly:</p>
<pre><code class="language-lean">def explicitPrimesUnder10 : List Nat :=
  List.cons 2 (List.cons 3 (List.cons 5 (List.cons 7 List.nil)))
</code></pre>
<p>These two definitions are completely equivalent, but <code>primesUnder10</code> is much easier to read than <code>explicitPrimesUnder10</code>.</p>
<p>Functions that consume <code>List</code>s can be defined in much the same way as functions that consume <code>Nat</code>s.
Indeed, one way to think of a linked list is as a <code>Nat</code> that has an extra data field dangling off each <code>succ</code> constructor.
From this point of view, computing the length of a list is the process of replacing each <code>cons</code> with a <code>succ</code> and the final <code>nil</code> with a <code>zero</code>.
Just as <code>replaceX</code> took the type of the fields of the point as an argument, <code>length</code> takes the type of the list's entries.
For example, if the list contains strings, then the first argument is <code>String</code>: <code>length String [&quot;Sourdough&quot;, &quot;bread&quot;]</code>.
It should compute like this:</p>
<pre><code>length String [&quot;Sourdough&quot;, &quot;bread&quot;]
===&gt;
length String (List.cons &quot;Sourdough&quot; (List.cons &quot;bread&quot; List.nil))
===&gt;
Nat.succ (length String (List.cons &quot;bread&quot; List.nil))
===&gt;
Nat.succ (Nat.succ (length String List.nil))
===&gt;
Nat.succ (Nat.succ Nat.zero)
===&gt;
2
</code></pre>
<p>The definition of <code>length</code> is both polymorphic (because it takes the list entry type as an argument) and recursive (because it refers to itself).
Generally, functions follow the shape of the data: recursive datatypes lead to recursive functions, and polymorphic datatypes lead to polymorphic functions.</p>
<pre><code class="language-lean">def length (α : Type) (xs : List α) : Nat :=
  match xs with
  | List.nil =&gt; Nat.zero
  | List.cons y ys =&gt; Nat.succ (length α ys)
</code></pre>
<p>Names such as <code>xs</code> and <code>ys</code> are conventionally used to stand for lists of unknown values.
The <code>s</code> in the name indicates that they are plural, so they are pronounced &quot;exes&quot; and &quot;whys&quot; rather than &quot;x s&quot; and &quot;y s&quot;.</p>
<p>To make it easier to read functions on lists, the bracket notation <code>[]</code> can be used to pattern-match against <code>nil</code>, and an infix <code>::</code> can be used in place of <code>cons</code>:</p>
<pre><code class="language-lean">def length (α : Type) (xs : List α) : Nat :=
  match xs with
  | [] =&gt; 0
  | y :: ys =&gt; Nat.succ (length α ys)
</code></pre>
<h2 id="implicit-arguments"><a class="header" href="#implicit-arguments">Implicit Arguments</a></h2>
<p>Both <code>replaceX</code> and <code>length</code> are somewhat bureaucratic to use, because the type argument is typically uniquely determined by the later values.
Indeed, in most languages, the compiler is perfectly capable of determining type arguments on its own, and only occasionally needs help from users.
This is also the case in Lean.
Arguments can be declared <em>implicit</em> by wrapping them in curly braces instead of parentheses when defining a function.
For instance, a version of <code>replaceX</code> with an implicit type argument looks like this:</p>
<pre><code class="language-lean">def replaceX {α : Type} (point : PPoint α) (newX : α) : PPoint α :=
  { point with x := newX }
</code></pre>
<p>It can be used with <code>natOrigin</code> without providing <code>Nat</code> explicitly, because Lean can <em>infer</em> the value of <code>α</code> from the later arguments:</p>
<pre><code class="language-lean">#eval replaceX natOrigin 5
</code></pre>
<pre><code class="language-output info">{ x := 5, y := 0 }
</code></pre>
<p>Similarly, <code>length</code> can be redefined to take the entry type implicitly:</p>
<pre><code class="language-lean">def length {α : Type} (xs : List α) : Nat :=
  match xs with
  | [] =&gt; 0
  | y :: ys =&gt; Nat.succ (length ys)
</code></pre>
<p>This <code>length</code> function can be applied directly to <code>primesUnder10</code>:</p>
<pre><code class="language-lean">#eval length primesUnder10
</code></pre>
<pre><code class="language-output info">4
</code></pre>
<p>In the standard library, Lean calls this function <code>List.length</code>, which means that the dot syntax that is used for structure field access can also be used to find the length of a list:</p>
<pre><code class="language-lean">#eval primesUnder10.length
</code></pre>
<pre><code class="language-output info">4
</code></pre>
<p>Just as C# and Java require type arguments to provided explicitly from time to time, Lean is not always capable of finding implicit arguments.
In these cases, they can be provided using their names.
For instance, a version of <code>List.length</code> that only works for lists of integers can be specified by setting <code>α</code> to <code>Int</code>:</p>
<pre><code class="language-lean">#check List.length (α := Int)
</code></pre>
<pre><code class="language-output info">List.length : List Int → Nat
</code></pre>
<h2 id="more-built-in-datatypes"><a class="header" href="#more-built-in-datatypes">More Built-In Datatypes</a></h2>
<p>In addition to lists, Lean's standard library contains a number of other structures and inductive datatypes that can be used in a variety of contexts.</p>
<h3 id="option"><a class="header" href="#option"><code>Option</code></a></h3>
<p>Not every list has a first entry—some lists are empty.
Many operations on collections may fail to find what they are looking for.
For instance, a function that finds the first entry in a list may not find any such entry.
It must therefore have a way to signal that there was no first entry.</p>
<p>Many languages have a <code>null</code> value that represents the absence of a value.
Instead of equipping existing types with a special <code>null</code> value, Lean provides a datatype called <code>Option</code> that equips some other type with an indicator for missing values.
For instance, a nullable <code>Int</code> is represented by <code>Option Int</code>, and a nullable list of strings is represented by the type <code>Option (List String)</code>.
Introducing a new type to represent nullability means that the type system ensures that checks for <code>null</code> cannot be forgotten, because an <code>Option Int</code> can't be used in a context where an <code>Int</code> is expected.</p>
<p><code>Option</code> has two constructors, called <code>some</code> and <code>none</code>, that respectively represent the non-null and null versions of the underlying type.
The non-null constructor, <code>some</code>, contains the underlying value, while <code>none</code> takes no arguments:</p>
<pre><code class="language-lean">inductive Option (α : Type) : Type where
  | none : Option α
  | some (val : α) : Option α
</code></pre>
<p>The <code>Option</code> type is very similar to nullable types in languages like C# and Kotlin, but it is not identical.
In these languages, if a type (say, <code>Boolean</code>) always refers to actual values of the type (<code>true</code> and <code>false</code>), the type <code>Boolean?</code> or <code>Nullable&lt;Boolean&gt;</code> additionally admits the <code>null</code> value.
Tracking this in the type system is very useful: the type checker and other tooling can help programmers remember to check for null, and APIs that explicitly describe nullability through type signatures are more informative than ones that don't.
However, these nullable types differ from Lean's <code>Option</code> in one very important way, which is that they don't allow multiple layers of optionality.
<code>Option (Option Int)</code> can be constructed with <code>none</code>, <code>some none</code>, or <code>some (some 360)</code>.
C#, on the other hand, forbids multiple layers of nullability by only allowing <code>?</code> to be added to non-nullable types, while Kotlin treats <code>T??</code> as being equivalent to <code>T?</code>.
This subtle difference is rarely relevant in practice, but it can matter from time to time.</p>
<p>To find the first entry in a list, if it exists, use <code>List.head?</code>.
The question mark is part of the name, and is not related to the use of question marks to indicate nullable types in C# or Kotlin.
In the definition of <code>List.head?</code>, an underscore is used to represent the tail of the list.
In patterns, underscores match anything at all, but do not introduce variables to refer to the matched data.
Using underscores instead of names is a way to clearly communicate to readers that part of the input is ignored.</p>
<pre><code class="language-lean">def List.head? {α : Type} (xs : List α) : Option α :=
  match xs with
  | [] =&gt; none
  | y :: _ =&gt; some y
</code></pre>
<p>A Lean naming convention is to define operations that might fail in groups using the suffixes <code>?</code> for a version that returns an <code>Option</code>, <code>!</code> for a version that crashes when provided with invalid input, and <code>D</code> for a version that returns a default value when the operation would otherwise fail.
For instance, <code>head</code> requires the caller to provide mathematical evidence that the list is not empty, <code>head?</code> returns an <code>Option</code>, <code>head!</code> crashes the program when passed an empty list, and <code>headD</code> takes a default value to return in case the list is empty.
The question mark and exclamation mark are part of the name, not special syntax, as Lean's naming rules are more liberal than many languages.</p>
<p>Because <code>head?</code> is defined in the <code>List</code> namespace, it can be used with accessor notation:</p>
<pre><code class="language-lean">#eval primesUnder10.head?
</code></pre>
<pre><code class="language-output info">some 2
</code></pre>
<p>However, attempting to test it on the empty list leads to two errors:</p>
<pre><code class="language-lean">#eval [].head?
</code></pre>
<pre><code class="language-output error">don't know how to synthesize implicit argument
  @List.nil ?m.20283
context:
⊢ Type ?u.20280

don't know how to synthesize implicit argument
  @_root_.List.head? ?m.20283 []
context:
⊢ Type ?u.20280
</code></pre>
<p>This is because Lean was unable to fully determine the expression's type.
In particular, it could neither find the implicit type argument to <code>List.head?</code>, nor could it find the implicit type argument to <code>List.nil</code>.
In Lean's output, <code>?m.XYZ</code> represents a part of a program that could not be inferred.
These unknown parts are called <em>metavariables</em>, and they occur in some error messages.
In order to evaluate an expression, Lean needs to be able to find its type, and the type was unavailable because the empty list does not have any entries from which the type can be found.
Explicitly providing a type allows Lean to proceed:</p>
<pre><code class="language-lean">#eval [].head? (α := Int)
</code></pre>
<pre><code class="language-output info">none
</code></pre>
<p>The error messages provide a useful clue.
Both messages use the <em>same</em> metavariable to describe the missing implicit argument, which means that Lean has determined that the two missing pieces will share a solution, even though it was unable to determine the actual value of the solution.</p>
<h3 id="prod"><a class="header" href="#prod"><code>Prod</code></a></h3>
<p>The <code>Prod</code> structure, short for &quot;Product&quot;, is a generic way of joining two values together.
For instance, a <code>Prod Nat String</code> contains a <code>Nat</code> and a <code>String</code>.
In other words, <code>PPoint Nat</code> could be replaced by <code>Prod Nat Nat</code>.
<code>Prod</code> is very much like C#'s tuples, the <code>Pair</code> and <code>Triple</code> types in Kotlin, and <code>tuple</code> in C++.
Many applications are best served by defining their own structures, even for simple cases like <code>Point</code>, because using domain terminology can make it easier to read the code.</p>
<p>On the other hand, there are some cases where it is not worth the overhead of defining a new type.
Additionally, some libraries are sufficiently generic that there is no more specific concept than &quot;pair&quot;.
Finally, the standard library contains a variety of convenience functions that make it easier to work with the built-in pair type.</p>
<p>The standard pair structure is called <code>Prod</code>.</p>
<pre><code class="language-lean">structure Prod (α : Type) (β : Type) : Type where
  fst : α
  snd : β
</code></pre>
<p>Lists are used so frequently that there is special syntax to make them more readable.
For the same reason, both the product type and its constructor have special syntax.
The type <code>Prod α β</code> is typically written <code>α × β</code>, mirroring the usual notation for a Cartesian product of sets.
Similarly, the usual mathematical notation for pairs is available for <code>Prod</code>.
In other words, instead of writing:</p>
<pre><code class="language-lean">def fives : String × Int := { fst := &quot;five&quot;, snd := 5 }
</code></pre>
<p>it suffices to write:</p>
<pre><code class="language-lean">def fives : String × Int := (&quot;five&quot;, 5)
</code></pre>
<p>Both notations are right-associative.
This means that the following definitions are equivalent:</p>
<pre><code class="language-lean">def sevens : String × Int × Nat := (&quot;VII&quot;, 7, 4 + 3)

def sevens : String × (Int × Nat) := (&quot;VII&quot;, (7, 4 + 3))
</code></pre>
<p>In other words, all products of more than two types, and their corresponding constructors, are actually nested products and nested pairs behind the scenes.</p>
<h3 id="sum"><a class="header" href="#sum"><code>Sum</code></a></h3>
<p>The <code>Sum</code> datatype is a generic way of allowing a choice between values of two different types.
For instance, a <code>Sum String Int</code> is either a <code>String</code> or an <code>Int</code>.
Like <code>Prod</code>, <code>Sum</code> should be used either when writing very generic code, for a very small section of code where there is no sensible domain-specific type, or when the standard library contains useful functions.
In most situations, it is more readable and maintainable to use a custom inductive type.</p>
<p>Values of type <code>Sum α β</code> are either the constructor <code>inl</code> applied to a value of type <code>α</code> or the constructor <code>inr</code> applied to a value of type <code>β</code>:</p>
<pre><code class="language-lean">inductive Sum (α : Type) (β : Type) : Type where
  | inl : α → Sum α β
  | inr : β → Sum α β
</code></pre>
<p>These names are abbreviations for &quot;left injection&quot; and &quot;right injection&quot;, respectively.
Just as the Cartesian product notation is used for <code>Prod</code>, a &quot;circled plus&quot; notation is used for <code>Sum</code>, so <code>α ⊕ β</code> is another way to write <code>Sum α β</code>.
There is no special syntax for <code>Sum.inl</code> and <code>Sum.inr</code>.</p>
<p>For instance, if pet names can either be dog names or cat names, then a type for them can be introduced as a sum of strings:</p>
<pre><code class="language-lean">def PetName : Type := String ⊕ String
</code></pre>
<p>In a real program, it would usually be better to define a custom inductive datatype for this purpose with informative constructor names.
Here, <code>Sum.inl</code> is to be used for dog names, and <code>Sum.inr</code> is to be used for cat names.
These constructors can be used to write a list of animal names:</p>
<pre><code class="language-lean">def animals : List PetName :=
  [Sum.inl &quot;Spot&quot;, Sum.inr &quot;Tiger&quot;, Sum.inl &quot;Fifi&quot;, Sum.inl &quot;Rex&quot;, Sum.inr &quot;Floof&quot;]
</code></pre>
<p>Pattern matching can be used to distinguish between the two constructors.
For instance, a function that counts the number of dogs in a list of animal names (that is, the number of <code>Sum.inl</code> constructors) looks like this:</p>
<pre><code class="language-lean">def howManyDogs (pets : List PetName) : Nat :=
  match pets with
  | [] =&gt; 0
  | Sum.inl _ :: morePets =&gt; howManyDogs morePets + 1
  | Sum.inr _ :: morePets =&gt; howManyDogs morePets
</code></pre>
<p>Function calls are evaluated before infix operators, so <code>howManyDogs morePets + 1</code> is the same as <code>(howManyDogs morePets) + 1</code>.
As expected, <code>#eval howManyDogs animals</code> yields <code>3</code>.</p>
<h3 id="unit"><a class="header" href="#unit"><code>Unit</code></a></h3>
<p><code>Unit</code> is a type with just one argumentless constructor, called <code>unit</code>.
In other words, it describes only a single value, which consists of said constructor applied to no arguments whatsoever.
<code>Unit</code> is defined as follows:</p>
<pre><code class="language-lean">inductive Unit : Type where
  | unit : Unit
</code></pre>
<p>On its own, <code>Unit</code> is not particularly useful.
However, in polymorphic code, it can be used as a placeholder for data that is missing.
For instance, the following inductive datatype represents arithmetic expressions:</p>
<pre><code class="language-lean">inductive ArithExpr (ann : Type) : Type where
  | int : ann → Int → ArithExpr ann
  | plus : ann → ArithExpr ann → ArithExpr ann → ArithExpr ann
  | minus : ann → ArithExpr ann → ArithExpr ann → ArithExpr ann
  | times : ann → ArithExpr ann → ArithExpr ann → ArithExpr ann
</code></pre>
<p>The type argument <code>ann</code> stands for annotations, and each constructor is annotated.
Expressions coming from a parser might be annotated with source locations, so a return type of <code>ArithExpr SourcePos</code> ensures that the parser put a <code>SourcePos</code> at each subexpression.
Expressions that don't come from the parser, however, will not have source locations, so their type can be <code>ArithExpr Unit</code>.</p>
<p>Additionally, because all Lean functions have arguments, zero-argument functions in other languages can be represented as functions that take a <code>Unit</code> argument.
In a return position, the <code>Unit</code> type is similar to <code>void</code> in languages derived from C.
In the C family, a function that returns <code>void</code> will return control to its caller, but it will not return any interesting value.
By being an intentionally uninteresting value, <code>Unit</code> allows this to be expressed without requiring a special-purpose <code>void</code> feature in the type system.
Unit's constructor can be written as empty parentheses: <code>() : Unit</code>.</p>
<h3 id="empty"><a class="header" href="#empty"><code>Empty</code></a></h3>
<p>The <code>Empty</code> datatype has no constructors whatsoever.
Thus, it indicates unreachable code, because no series of calls can ever terminate with a value at type <code>Empty</code>.</p>
<p><code>Empty</code> is not used nearly as often as <code>Unit</code>.
However, it is useful in some specialized contexts.
Many polymorphic datatypes do not use all of their type arguments in all of their constructors.
For instance, <code>Sum.inl</code> and <code>Sum.inr</code> each use only one of <code>Sum</code>'s type arguments.
Using <code>Empty</code> as one of the type arguments to <code>Sum</code> can rule out one of the constructors at a particular point in a program.
This can allow generic code to be used in contexts that have additional restrictions.</p>
<h3 id="naming-sums-products-and-units"><a class="header" href="#naming-sums-products-and-units">Naming: Sums, Products, and Units</a></h3>
<p>Generally speaking, types that offer multiple constructors are called <em>sum types</em>, while types whose single constructor takes multiple arguments are called <em>product types</em>.
These terms are related to sums and products used in ordinary arithmetic.
The relationship is easiest to see when the types involved contain a finite number of values.
If <code>α</code> and <code>β</code> are types that contain <em>n</em> and <em>k</em> distinct values, respectively, then <code>α ⊕ β</code> contains <em>n</em> + <em>k</em> distinct values and <code>α × β</code> contains <em>n</em> × <em>k</em> distinct values.
For instance, <code>Bool</code> has two values: <code>true</code> and <code>false</code>, and <code>Unit</code> has one value: <code>Unit.unit</code>.
The product <code>Bool × Unit</code> has the two values <code>(true, Unit.unit)</code> and <code>(false, Unit.unit)</code>, and the sum <code>Bool ⊕ Unit</code> has the three values <code>Sum.inl true</code>, <code>Sum.inl false</code>, and <code>Sum.inr unit</code>.
Similarly, 2 × 1 = 2, and 2 + 1 = 3.</p>
<h2 id="messages-you-may-meet"><a class="header" href="#messages-you-may-meet">Messages You May Meet</a></h2>
<p>Not all definable structures or inductive types can have the type <code>Type</code>.
In particular, if a constructor takes an arbitrary type as an argument, then the inductive type must have a different type.
These errors usually state something about &quot;universe levels&quot;.
For example, for this inductive type:</p>
<pre><code class="language-lean">inductive MyType : Type where
  | ctor : (α : Type) → α → MyType
</code></pre>
<p>Lean gives the following error:</p>
<pre><code class="language-output error">invalid universe level in constructor 'MyType.ctor', parameter 'α' has type
  Type
at universe level
  2
it must be smaller than or equal to the inductive datatype universe level
  1
</code></pre>
<p>A later chapter describes why this is the case, and how to modify definitions to make them work.
For now, try making the type an argument to the inductive type as a whole, rather than to the constructor.</p>
<p>Similarly, if a constructor's argument is a function that takes the datatype being defined as an argument, then the definition is rejected.
For example:</p>
<pre><code class="language-lean">inductive MyType : Type where
  | ctor : (MyType → Int) → MyType
</code></pre>
<p>yields the message:</p>
<pre><code class="language-output error">(kernel) arg #1 of 'MyType.ctor' has a non positive occurrence of the datatypes being declared
</code></pre>
<p>For technical reasons, allowing these datatypes could make it possible to undermine Lean's internal logic, making it unsuitable for use as a theorem prover.</p>
<p>Forgetting an argument to an inductive type can also yield a confusing message.
For example, when the argument <code>α</code> is not passed to <code>MyType</code> in <code>ctor</code>'s type:</p>
<pre><code class="language-lean">inductive MyType (α : Type) : Type where
  | ctor : α → MyType
</code></pre>
<p>Lean replies with the following error:</p>
<pre><code class="language-output error">type expected, got
  (MyType : Type → Type)
</code></pre>
<p>The error message is saying that <code>MyType</code>'s type, which is <code>Type → Type</code>, does not itself describe types.
<code>MyType</code> requires an argument to become an actual honest-to-goodness type.</p>
<p>The same message can appear when type arguments are omitted in other contexts, such as in a type signature for a definition:</p>
<pre><code class="language-lean">inductive MyType (α : Type) : Type where
  | ctor : α → MyType α

def ofFive : MyType := ctor 5
</code></pre>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<ul>
<li>Write a function to find the last entry in a list. It should return an <code>Option</code>.</li>
<li>Write a function that finds the first entry in a list that satisfies a given predicate. Start the definition with <code>def List.findFirst? {α : Type} (xs : List α) (predicate : α → Bool) : Option α :=</code></li>
<li>Write a function <code>Prod.swap</code> that swaps the two fields in a pair. Start the definition with <code>def Prod.swap {α β : Type} (pair : α × β) : β × α :=</code></li>
<li>Rewrite the <code>PetName</code> example to use a custom datatype and compare it to the version that uses <code>Sum</code>.</li>
<li>Write a function <code>zip</code> that combines two lists into a list of pairs. The resulting list should be as long as the shortest input list. Start the definition with <code>def zip {α β : Type} (xs : List α) (ys : List β) : List (α × β) :=</code>.</li>
<li>Write a polymorphic function <code>take</code> that returns the first <em>n</em> entries in a list, where <em>n</em> is a <code>Nat</code>. If the list contains fewer than <code>n</code> entries, then the resulting list should be the input list. <code>#eval take 3 [&quot;bolete&quot;, &quot;oyster&quot;]</code> should yield <code>[&quot;bolete&quot;, &quot;oyster&quot;]</code>, and <code>#eval take 1 [&quot;bolete&quot;, &quot;oyster&quot;]</code> should yield <code>[&quot;bolete&quot;]</code>.</li>
<li>Using the analogy between types and arithmetic, write a function that distributes products over sums. In other words, it should have type <code>α × (β ⊕ γ) → (α × β) ⊕ (α × γ)</code>.</li>
<li>Using the analogy between types and arithmetic, write a function that turns multiplication by two into a sum. In other words, it should have type <code>Bool × α → α ⊕ α</code>.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../getting-to-know/datatypes-and-patterns.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../getting-to-know/conveniences.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../getting-to-know/datatypes-and-patterns.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../getting-to-know/conveniences.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
