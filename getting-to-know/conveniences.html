<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Additional Conveniences - Functional Programming in Lean</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="../getting-to-know.html"><strong aria-hidden="true">1.</strong> Getting to Know Lean</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-to-know/evaluating.html"><strong aria-hidden="true">1.1.</strong> Evaluating Expressions</a></li><li class="chapter-item expanded "><a href="../getting-to-know/types.html"><strong aria-hidden="true">1.2.</strong> Types</a></li><li class="chapter-item expanded "><a href="../getting-to-know/functions-and-definitions.html"><strong aria-hidden="true">1.3.</strong> Functions and Definitions</a></li><li class="chapter-item expanded "><a href="../getting-to-know/structures.html"><strong aria-hidden="true">1.4.</strong> Structures</a></li><li class="chapter-item expanded "><a href="../getting-to-know/datatypes-and-patterns.html"><strong aria-hidden="true">1.5.</strong> Datatypes, Patterns and Recursion</a></li><li class="chapter-item expanded "><a href="../getting-to-know/polymorphism.html"><strong aria-hidden="true">1.6.</strong> Polymorphism</a></li><li class="chapter-item expanded "><a href="../getting-to-know/conveniences.html" class="active"><strong aria-hidden="true">1.7.</strong> Additional Conveniences</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Hello, World!</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Functional Programming in Lean</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>Intro here</p>
<h1 id="automatic-implicit-arguments"><a class="header" href="#automatic-implicit-arguments">Automatic Implicit Arguments</a></h1>
<p>When writing polymorphic functions in Lean, it is typically not necessary to list all the implicit arguments.
Instead, they can simply be mentioned.
If Lean can determine their type, then they are automatically inserted as implicit arguments.
In other words, the previous definition of <code>length</code>:</p>
<pre><code class="language-Lean">def length {α : Type} (xs : List α) : Nat :=
  match xs with
    | [] =&gt; 0
    | y :: ys =&gt; Nat.succ (length ys)
</code></pre>
<p>can be written without <code>{α : Type}</code>:</p>
<pre><code class="language-Lean">def length (xs : List α) : Nat :=
  match xs with
    | [] =&gt; 0
    | y :: ys =&gt; Nat.succ (length ys)
</code></pre>
<p>This can greatly simplify highly polymorphic definitions that take many implicit arguments.</p>
<h1 id="pattern-matching-definitions"><a class="header" href="#pattern-matching-definitions">Pattern-Matching Definitions</a></h1>
<p>When defining functions with <code>def</code>, it is quite common to name an argument and then immediately use it with pattern matching.
For instance, in <code>length</code>, the argument <code>xs</code> is used only in <code>match</code>.
In these situations, the cases of the <code>match</code> expression can be written directly, without naming the argument at all.</p>
<p>The first step is to move the arguments' types to the right of the definition's type, in the form of a function type.
For instance, the type of <code>length</code> is <code>List α → Nat</code>.
Then, replace the <code>:=</code> with each case of the pattern match:</p>
<pre><code class="language-Lean">def length : List α → Nat
  | [] =&gt; 0
  | y :: ys =&gt; Nat.succ (length ys)
</code></pre>
<p>This syntax can also be used to define functions that take more than one argument.
In this case, their patterns are separated by commas.
For instance, <code>drop</code> takes a number <em>n</em> and a list, and returns the list after removing the first <em>n</em> entries.</p>
<pre><code class="language-Lean">def drop : Nat → List α → List α
  | Nat.zero, xs =&gt; xs
  | _, [] =&gt; []
  | Nat.succ n , x :: xs =&gt; drop n xs
</code></pre>
<p>Named arguments and patterns can also be used in the same definition.
For instance, a function that takes a default value and an optional value, and returns the default when the optional value is <code>none</code>, can be written:</p>
<pre><code class="language-Lean">def fromOption (default : α) : Option α → α
  | none =&gt; default
  | some x =&gt; x
</code></pre>
<p>This function is called <code>Option.getD</code> in the standard library, and can be called with dot notation:</p>
<pre><code class="language-Lean">#eval (some &quot;salmonberry&quot;).getD &quot;&quot;
</code></pre>
<pre><code class="language-Lean info">&quot;salmonberry&quot;
</code></pre>
<pre><code class="language-Lean">#eval none.getD &quot;&quot;
</code></pre>
<pre><code class="language-Lean info">&quot;&quot;
</code></pre>
<h1 id="local-definitions"><a class="header" href="#local-definitions">Local Definitions</a></h1>
<p>It is often useful to name intermediate steps in a computation.
In many cases, intermediate values represent useful concepts all on their own, and naming them explicitly can make the program easier to read.
In other cases, the intermediate value is used more than once.
As in most other languages, writing down the same code twice in Lean causes it to be computed twice, while saving the result in a variable leads to the result of the computation being saved and re-used.</p>
<p>For instance, <code>unzip</code> is a function that transforms a list of pairs into a pair of lists.
When the list of pairs is empty, then the result of <code>unzip</code> is a pair of empty lists.
When the list of pairs has a pair at its head, then the two fields of the pair are added to the result of unzipping the rest of the list.
This definition of <code>unzip</code> follows that description exactly:</p>
<pre><code class="language-Lean">def unzip : List (α × β) → List α × List β
  | [] =&gt; ([], [])
  | (x, y) :: xys =&gt;
    (x :: (unzip xys).fst, y :: (unzip xys).snd)
</code></pre>
<p>Unfortunately, there is a problem: this code is slower than it needs to be.
Each entry in the list of pairs leads to two recursive calls, which makes this function take exponential time.
However, both recursive calls will have the same result, so there is no reason to make the recursive call twice.</p>
<p>In Lean, the result of the recursive call can be named, and thus saved, using <code>let</code>.
Local definitions with <code>let</code> resemble top-level definitions with <code>def</code>: it takes a name to be locally defined, arguments if desired, a type signature, and then a body following <code>:=</code>.
A semicolon is used after the local definition.
For instance, <code>let</code> can be used in <code>unzip</code> like this:</p>
<pre><code class="language-Lean">def unzip : List (α × β) → List α × List β
  | [] =&gt; ([], [])
  | (x, y) :: xys =&gt;
    let unzipped : List α × List β := unzip xys;
    (x :: unzipped.fst, y :: unzipped.snd)
</code></pre>
<p>The biggest difference between <code>let</code> and <code>def</code> is that recursive <code>let</code> definitions must be explicitly indicated by writing <code>let rec</code>.</p>
<h1 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h1>
<p>In many situations, Lean can automatically determine an expression's type.
In these cases, explicit types may be omitted from both top-level definitions (with <code>def</code>) and local definitions (with <code>let</code>).
For instance, the recursive call to <code>unzip</code> does not need an annotation:</p>
<pre><code class="language-Lean">def unzip : List (α × β) → List α × List β
  | [] =&gt; ([], [])
  | (x, y) :: xys =&gt;
    let unzipped : List α × List β := unzip xys;
    (x :: unzipped.fst, y :: unzipped.snd)
</code></pre>
<p>As a rule of thumb, omitting the types of literal values (like strings and numbers) usually works, although Lean may pick a type for literal numbers that is more specific than the intended type.
Lean can usually determine a type for a function application, because it already knows the argument types and the return type.
Omitting return types for function definitions will often work, but function arguments typically require annotations.
Definitions that are not functions, like <code>unzipped</code> in the example, do not need types if their bodies do not need types, and the body of this definition is a function application.</p>
<p>Omitting the return type for <code>unzip</code> is possible when using an explicit <code>match</code> expression:</p>
<pre><code class="language-Lean">def unzip (pairs : List (α × β)) :=
  match pairs with
  | [] =&gt; ([], [])
  | (x, y) :: xys =&gt;
    let unzipped := unzip xys;
    (x :: unzipped.fst, y :: unzipped.snd)
</code></pre>
<p>Generally speaking, it is a good idea to err on the side of too many, rather than too few, type annotations.
First off, explicit types communicate assumptions about the code to readers.
Even if Lean can determine the type on its own, it can still be easier to read code without having to repeatedly query Lean for type information.
Secondly, explicit types help localize errors.
The more explicit a program is about its types, the more informative the error messages can be.
This is especially important in a language like Lean that has a very expressive type system.
Thirdly, explicit types make it easier to write the program in the first place.
The type is a specification, and the compiler's feedback can be a helpful tool in writing a program that meets the specification.
Finally, Lean's type reconstruction is a best-effort system.
Because Lean's type system is so expressive, there is no &quot;best&quot; or most general type to find for all expressions.
This means that even if you get a type, there's no guarantee that it's the <em>right</em> type for a given application.
For instance, <code>14</code> can be a <code>Nat</code> or an <code>Int</code>:</p>
<pre><code class="language-Lean">#check 14
</code></pre>
<pre><code class="language-Lean info">14 : Nat
</code></pre>
<pre><code class="language-Lean">#check (14 : Int)
</code></pre>
<pre><code class="language-Lean info">14 : Int
</code></pre>
<p>Missing type annotations can give confusing error messages.
Omitting all types from the definition of <code>unzip</code>:</p>
<pre><code class="language-Lean">def unzip pairs :=
  match pairs with
    | [] =&gt; ([], [])
    | (x, y) :: xys =&gt;
      let unzipped := unzip xys;
      (x :: unzipped.fst, y :: unzipped.snd)
</code></pre>
<p>leads to a message about the <code>match</code> expression:</p>
<pre><code class="language-Lean error">invalid match-expression, pattern contains metavariables
  []
</code></pre>
<p>This is because <code>match</code> needs to know the type of the value being inspected, but that type was not available.
A &quot;metavariable&quot; is an unknown part of a program, written <code>?m.XYZ</code> in error messages—they are described in the <a href="getting-to-know/polymorphism.html">section on Polymorphism</a>.
In this program, the type annotation on the argument is required.</p>
<p>Even some very simple programs require type annotations.
For instance, the identity function just returns whatever argument it is passed.
With argument and type annotations, it looks like this:</p>
<pre><code class="language-Lean">def id (x : α) : α := x
</code></pre>
<p>Lean is capable of determining the return type on its own:</p>
<pre><code class="language-Lean">def id (x : α) : α := x
</code></pre>
<p>Omitting the argument type, however, causes an error:</p>
<pre><code class="language-Lean">def id x := x
</code></pre>
<pre><code class="language-Lean error">failed to infer binder type
</code></pre>
<p>In general, messages that say something like &quot;failed to infer&quot; or that mention metavariables are often a sign that more type annotations are necessary.
Especially while still learning Lean, it is useful to write down many types.</p>
<h1 id="simultaneous-matching"><a class="header" href="#simultaneous-matching">Simultaneous Matching</a></h1>
<p>Pattern-matching expressions, just like pattern-matching definitions, can match on multiple values at once.
Both the expressions to be inspected and the patterns that they match against are written with commas between them, similarly to the syntax used for definitions.
Here is a version of <code>drop</code> that uses simultaneous matching:</p>
<pre><code class="language-Lean">def drop (n : Nat) (xs : List α) : List α :=
  match n, xs with
    | Nat.zero, ys =&gt; ys
    | _, [] =&gt; []
    | Nat.succ n , y :: ys =&gt; drop n ys
</code></pre>
<h1 id="lambda"><a class="header" href="#lambda">Lambda</a></h1>
<h1 id="namespaces"><a class="header" href="#namespaces">Namespaces</a></h1>
<h1 id="sections-and-variables"><a class="header" href="#sections-and-variables">Sections and Variables</a></h1>
<h1 id="if-let"><a class="header" href="#if-let">if let</a></h1>
<h1 id="positional-structure-arguments"><a class="header" href="#positional-structure-arguments">Positional Structure Arguments</a></h1>
<h1 id="string-interpolation"><a class="header" href="#string-interpolation">String Interpolation</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../getting-to-know/polymorphism.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../getting-to-know/polymorphism.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
