<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Interlude: Tactics, Induction, and Proofs - Functional Programming in Lean</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">
        <link rel="stylesheet" href="pygments.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title.html">Functional Programming in Lean</a></li><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="getting-to-know.html"><strong aria-hidden="true">1.</strong> Getting to Know Lean</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-to-know/evaluating.html"><strong aria-hidden="true">1.1.</strong> Evaluating Expressions</a></li><li class="chapter-item expanded "><a href="getting-to-know/types.html"><strong aria-hidden="true">1.2.</strong> Types</a></li><li class="chapter-item expanded "><a href="getting-to-know/functions-and-definitions.html"><strong aria-hidden="true">1.3.</strong> Functions and Definitions</a></li><li class="chapter-item expanded "><a href="getting-to-know/structures.html"><strong aria-hidden="true">1.4.</strong> Structures</a></li><li class="chapter-item expanded "><a href="getting-to-know/datatypes-and-patterns.html"><strong aria-hidden="true">1.5.</strong> Datatypes, Patterns and Recursion</a></li><li class="chapter-item expanded "><a href="getting-to-know/polymorphism.html"><strong aria-hidden="true">1.6.</strong> Polymorphism</a></li><li class="chapter-item expanded "><a href="getting-to-know/conveniences.html"><strong aria-hidden="true">1.7.</strong> Additional Conveniences</a></li><li class="chapter-item expanded "><a href="getting-to-know/summary.html"><strong aria-hidden="true">1.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="hello-world.html"><strong aria-hidden="true">2.</strong> Hello, World!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hello-world/running-a-program.html"><strong aria-hidden="true">2.1.</strong> Running a Program</a></li><li class="chapter-item expanded "><a href="hello-world/step-by-step.html"><strong aria-hidden="true">2.2.</strong> Step By Step</a></li><li class="chapter-item expanded "><a href="hello-world/starting-a-project.html"><strong aria-hidden="true">2.3.</strong> Starting a Project</a></li><li class="chapter-item expanded "><a href="hello-world/cat.html"><strong aria-hidden="true">2.4.</strong> Worked Example: cat</a></li><li class="chapter-item expanded "><a href="hello-world/conveniences.html"><strong aria-hidden="true">2.5.</strong> Additional Conveniences</a></li><li class="chapter-item expanded "><a href="hello-world/summary.html"><strong aria-hidden="true">2.6.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="props-proofs-indexing.html"><strong aria-hidden="true">3.</strong> Interlude: Propositions, Proofs, and Indexing</a></li><li class="chapter-item expanded "><a href="type-classes.html"><strong aria-hidden="true">4.</strong> Overloading and Type Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="type-classes/pos.html"><strong aria-hidden="true">4.1.</strong> Positive Numbers</a></li><li class="chapter-item expanded "><a href="type-classes/polymorphism.html"><strong aria-hidden="true">4.2.</strong> Type Classes and Polymorphism</a></li><li class="chapter-item expanded "><a href="type-classes/out-params.html"><strong aria-hidden="true">4.3.</strong> Controlling Instance Search</a></li><li class="chapter-item expanded "><a href="type-classes/indexing.html"><strong aria-hidden="true">4.4.</strong> Arrays and Indexing</a></li><li class="chapter-item expanded "><a href="type-classes/standard-classes.html"><strong aria-hidden="true">4.5.</strong> Standard Classes</a></li><li class="chapter-item expanded "><a href="type-classes/coercion.html"><strong aria-hidden="true">4.6.</strong> Coercions</a></li><li class="chapter-item expanded "><a href="type-classes/conveniences.html"><strong aria-hidden="true">4.7.</strong> Additional Conveniences</a></li><li class="chapter-item expanded "><a href="type-classes/summary.html"><strong aria-hidden="true">4.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="monads.html"><strong aria-hidden="true">5.</strong> Monads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="monads/class.html"><strong aria-hidden="true">5.1.</strong> The Monad Type Class</a></li><li class="chapter-item expanded "><a href="monads/arithmetic.html"><strong aria-hidden="true">5.2.</strong> Example: Arithmetic in Monads</a></li><li class="chapter-item expanded "><a href="monads/do.html"><strong aria-hidden="true">5.3.</strong> do-Notation for Monads</a></li><li class="chapter-item expanded "><a href="monads/io.html"><strong aria-hidden="true">5.4.</strong> The IO Monad</a></li><li class="chapter-item expanded "><a href="monads/conveniences.html"><strong aria-hidden="true">5.5.</strong> Additional Conveniences</a></li><li class="chapter-item expanded "><a href="monads/summary.html"><strong aria-hidden="true">5.6.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="functor-applicative-monad.html"><strong aria-hidden="true">6.</strong> Functors, Applicative Functors, and Monads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="functor-applicative-monad/inheritance.html"><strong aria-hidden="true">6.1.</strong> Structures and Inheritance</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/applicative.html"><strong aria-hidden="true">6.2.</strong> Applicative Functors</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/applicative-contract.html"><strong aria-hidden="true">6.3.</strong> The Applicative Contract</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/alternative.html"><strong aria-hidden="true">6.4.</strong> Alternatives</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/universes.html"><strong aria-hidden="true">6.5.</strong> Universes</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/complete.html"><strong aria-hidden="true">6.6.</strong> The Complete Definitions</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/summary.html"><strong aria-hidden="true">6.7.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="monad-transformers.html"><strong aria-hidden="true">7.</strong> Monad Transformers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="monad-transformers/reader-io.html"><strong aria-hidden="true">7.1.</strong> Combining IO and Reader</a></li><li class="chapter-item expanded "><a href="monad-transformers/transformers.html"><strong aria-hidden="true">7.2.</strong> A Monad Construction Kit</a></li><li class="chapter-item expanded "><a href="monad-transformers/order.html"><strong aria-hidden="true">7.3.</strong> Ordering Monad Transformers</a></li><li class="chapter-item expanded "><a href="monad-transformers/do.html"><strong aria-hidden="true">7.4.</strong> More do Features</a></li><li class="chapter-item expanded "><a href="monad-transformers/conveniences.html"><strong aria-hidden="true">7.5.</strong> Additional Conveniences</a></li><li class="chapter-item expanded "><a href="monad-transformers/summary.html"><strong aria-hidden="true">7.6.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="dependent-types.html"><strong aria-hidden="true">8.</strong> Programming with Dependent Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dependent-types/indexed-families.html"><strong aria-hidden="true">8.1.</strong> Indexed Families</a></li><li class="chapter-item expanded "><a href="dependent-types/universe-pattern.html"><strong aria-hidden="true">8.2.</strong> The Universe Design Pattern</a></li><li class="chapter-item expanded "><a href="dependent-types/typed-queries.html"><strong aria-hidden="true">8.3.</strong> Worked Example: Typed Queries</a></li><li class="chapter-item expanded "><a href="dependent-types/indices-parameters-universes.html"><strong aria-hidden="true">8.4.</strong> Indices, Parameters, and Universe Levels</a></li><li class="chapter-item expanded "><a href="dependent-types/pitfalls.html"><strong aria-hidden="true">8.5.</strong> Pitfalls of Programming with Dependent Types</a></li><li class="chapter-item expanded "><a href="dependent-types/summary.html"><strong aria-hidden="true">8.6.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="tactics-induction-proofs.html" class="active"><strong aria-hidden="true">9.</strong> Interlude: Tactics, Induction, and Proofs</a></li><li class="chapter-item expanded "><a href="programs-proofs.html"><strong aria-hidden="true">10.</strong> Programming, Proving, and Performance</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programs-proofs/tail-recursion.html"><strong aria-hidden="true">10.1.</strong> Tail Recursion</a></li><li class="chapter-item expanded "><a href="programs-proofs/tail-recursion-proofs.html"><strong aria-hidden="true">10.2.</strong> Proving Equivalence</a></li><li class="chapter-item expanded "><a href="programs-proofs/arrays-termination.html"><strong aria-hidden="true">10.3.</strong> Arrays and Termination</a></li><li class="chapter-item expanded "><a href="programs-proofs/inequalities.html"><strong aria-hidden="true">10.4.</strong> More Inequalities</a></li><li class="chapter-item expanded "><a href="programs-proofs/fin.html"><strong aria-hidden="true">10.5.</strong> Safe Array Indices</a></li><li class="chapter-item expanded "><a href="programs-proofs/insertion-sort.html"><strong aria-hidden="true">10.6.</strong> Insertion Sort and Array Mutation</a></li><li class="chapter-item expanded "><a href="programs-proofs/special-types.html"><strong aria-hidden="true">10.7.</strong> Special Types</a></li><li class="chapter-item expanded "><a href="programs-proofs/summary.html"><strong aria-hidden="true">10.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="next-steps.html">Next Steps</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Functional Programming in Lean</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="interlude-tactics-induction-and-proofs"><a class="header" href="#interlude-tactics-induction-and-proofs">Interlude: Tactics, Induction, and Proofs</a></h1>
<h2 id="a-note-on-proofs-and-user-interfaces"><a class="header" href="#a-note-on-proofs-and-user-interfaces">A Note on Proofs and User Interfaces</a></h2>
<p>This book presents the process of writing proofs as if they are written in one go and submitted to Lean, which then replies with error messages that describe what remains to be done.
The actual process of interacting with Lean is much more pleasant.
Lean provides information about the proof as the cursor is moved through it and there are a number of interactive features that make proving easier.
Please consult the documentation of your Lean development environment for more information.</p>
<p>The approach in this book that focuses on incrementally building a proof and showing the messages that result demonstrates the kinds of interactive feedback that Lean provides while writing a proof, even though it is much slower than the process used by experts.
At the same time, seeing incomplete proofs evolve towards completeness is a useful perspective on proving.
As your skill in writing proofs increases, Lean's feedback will come to feel less like errors and more like support for your own thought processes.
Learning the interactive approach is very important.</p>
<h2 id="recursion-and-induction"><a class="header" href="#recursion-and-induction">Recursion and Induction</a></h2>
<p>The functions <code>plusR_succ_left</code> and <code>plusR_zero_left</code> from the preceding chapter can be seen from two perspectives.
On the one hand, they are recursive functions that build up evidence for a proposition, just as other recursive functions might construct a list, a string, or any other data structure.
On the other, they also correspond to proofs by <em>mathematical induction</em>.</p>
<p>Mathematical induction is a proof technique where a statement is proven for <em>all</em> natural numbers in two steps:</p>
<ol>
<li>The statement is shown to hold for \( 0 \). This is called the <em>base case</em>.</li>
<li>Under the assumption that the statement holds for some arbitrarily chosen number \( n \), it is shown to hold for \( n + 1 \). This is called the <em>induction step</em>. The assumption that the statement holds for \( n \) is called the <em>induction hypothesis</em>.</li>
</ol>
<p>Because it's impossible to check the statement for <em>every</em> natural number, induction provides a means of writing a proof that could, in principle, be expanded to any particular natural number.
For example, if a concrete proof were desired for the number 3, then it could be constructed by using first the base case and then the induction step three times, to show the statement for 0, 1, 2, and finally 3.
Thus, it proves the statement for all natural numbers.</p>
<h2 id="the-induction-tactic"><a class="header" href="#the-induction-tactic">The Induction Tactic</a></h2>
<p>Writing proofs by induction as recursive functions that use helpers such as <code>congrArg</code> does not always do a good job of expressing the intentions behind the proof.
While recursive functions indeed have the structure of induction, they should probably be viewed as an <em>encoding</em> of a proof.
Furthermore, Lean's tactic system provides a number of opportunities to automate the construction of a proof that are not available when writing the recursive function explicitly.
Lean provides an induction <em>tactic</em> that can carry out an entire proof by induction in a single tactic block.
Behind the scenes, Lean constructs the recursive function that corresponds the use of induction.</p>
<p>To prove <code>plusR_zero_left</code> with the induction tactic, begin by writing its signature (using <code>theorem</code>, because this really is a proof).
Then, use <code>by induction k</code> as the body of the definition:</p>
<pre><code class="language-lean">theorem plusR_zero_left (k : Nat) : k = Nat.plusR 0 k := by
  induction k
</code></pre>
<p>The resulting message states that there are two goals:</p>
<pre><code class="language-output error">unsolved goals
case zero
⊢ Nat.zero = Nat.plusR 0 Nat.zero

case succ
n✝ : Nat
n_ih✝ : n✝ = Nat.plusR 0 n✝
⊢ Nat.succ n✝ = Nat.plusR 0 (Nat.succ n✝)
</code></pre>
<p>A tactic block is a program that is run while the Lean type checker processes a file, somewhat like a much more powerful C preprocessor macro.
The tactics generate the actual program.</p>
<p>In the tactic language, there can be a number of goals.
Each goal consists of a type together with some assumptions.
These are analogous to using underscores as placeholders—the type in the goal represents what is to be proved, and the assumptions represent what is in-scope and can be used.
In the case of the goal <code>case zero</code>, there are no assumptions and the type is <code>Nat.zero = Nat.plusR 0 Nat.zero</code>—this is the theorem statement with <code>0</code> instead of <code>k</code>.
In the goal <code>case succ</code>, there are two assumptions, named <code>n✝</code> and <code>n_ih✝</code>.
Behind the scenes, the <code>induction</code> tactic creates a dependent pattern match that refines the overall type, and <code>n✝</code> represents the argument to <code>Nat.succ</code> in the pattern.
The assumption <code>n_ih✝</code> represents the result of calling the generated function recursively on <code>n✝</code>.
Its type is the overall type of the theorem, just with <code>n✝</code> instead of <code>k</code>.
The type to be fulfilled as part of the goal <code>case succ</code> is the overall theorem statement, with <code>Nat.succ n✝</code> instead of <code>k</code>.</p>
<p>The two goals that result from the use of the <code>induction</code> tactic correspond to the base case and the induction step in the description of mathematical induction.
The base case is <code>case zero</code>.
In <code>case succ</code>, <code>n_ih✝</code> corresponds to the induction hypothesis, while the whole of <code>case succ</code> is the induction step.</p>
<p>The next step in writing the proof is to focus on each of the two goals in turn.
Just as <code>pure ()</code> can be used in a <code>do</code> block to indicate &quot;do nothing&quot;, the tactic language has a statement <code>skip</code> that also does nothing.
This can be used when Lean's syntax requires a tactic, but it's not yet clear which one should be used.
Adding <code>with</code> to the end of the <code>induction</code> statement provides a syntax that is similar to pattern matching:</p>
<pre><code class="language-lean">theorem plusR_zero_left (k : Nat) : k = Nat.plusR 0 k := by
  induction k with
  | zero =&gt; skip
  | succ n ih =&gt; skip
</code></pre>
<p>Each of the two <code>skip</code> statements has a message associated with it.
The first shows the base case:</p>
<pre><code class="language-output error">unsolved goals
case zero
⊢ Nat.zero = Nat.plusR 0 Nat.zero
</code></pre>
<p>The second shows the induction step:</p>
<pre><code class="language-output error">unsolved goals
case succ
n : Nat
ih : n = Nat.plusR 0 n
⊢ Nat.succ n = Nat.plusR 0 (Nat.succ n)
</code></pre>
<p>In the induction step, the inaccessible names with daggers have been replaced with the names provided after <code>succ</code>, namely <code>n</code> and <code>ih</code>.</p>
<p>The cases after <code>induction ... with</code> are not patterns: they consist of the name of a goal followed by zero or more names.
The names are used for assumptions introduced in the goal; it is an error to provide more names than the goal introduces:</p>
<pre><code class="language-lean">theorem plusR_zero_left (k : Nat) : k = Nat.plusR 0 k := by
  induction k with
  | zero =&gt; skip
  | succ n ih lots of names =&gt; skip
</code></pre>
<pre><code class="language-output error">too many variable names provided at alternative 'succ', #5 provided, but #2 expected
</code></pre>
<p>Focusing on the base case, the <code>rfl</code> tactic works just as well inside of the <code>induction</code> tactic as it does in a recursive function:</p>
<pre><code class="language-lean">theorem plusR_zero_left (k : Nat) : k = Nat.plusR 0 k := by
  induction k with
  | zero =&gt; rfl
  | succ n ih =&gt; skip
</code></pre>
<p>In the recursive function version of the proof, a type annotation made the expected type something that was easier to understand.
In the tactic language, there are a number of specific ways to transform a goal to make it easier to solve.
The <code>unfold</code> tactic replaces a defined name with its definition:</p>
<pre><code class="language-lean">theorem plusR_zero_left (k : Nat) : k = Nat.plusR 0 k := by
  induction k with
  | zero =&gt; rfl
  | succ n ih =&gt;
    unfold Nat.plusR
</code></pre>
<p>Now, the right-hand side of the equality in the goal has become <code>Nat.plusR 0 n + 1</code> instead of <code>Nat.plusR 0 (Nat.succ n)</code>:</p>
<pre><code class="language-output error">unsolved goals
case succ
n : Nat
ih : n = Nat.plusR 0 n
⊢ Nat.succ n = Nat.plusR 0 n + 1
</code></pre>
<p>Instead of appealing to functions like <code>congrArg</code> and operators like <code>▸</code>, there are tactics that allow equality proofs to be used to transform proof goals.
One of the most important is <code>rw</code>, which takes a list of equality proofs and replaces the left side with the right side in the goal.
This almost does the right thing in <code>plusR_zero_left</code>:</p>
<pre><code class="language-lean">theorem plusR_zero_left (k : Nat) : k = Nat.plusR 0 k := by
  induction k with
  | zero =&gt; rfl
  | succ n ih =&gt;
    unfold Nat.plusR
    rw [ih]
</code></pre>
<p>However, the direction of the rewrite was incorrect.
Replacing <code>n</code> with <code>Nat.plusR 0 n</code> made the goal more complicated rather than less complicated:</p>
<pre><code class="language-output info">unsolved goals
case succ
n : Nat
ih : n = Nat.plusR 0 n
⊢ Nat.succ (Nat.plusR 0 n) = Nat.plusR 0 (Nat.plusR 0 n) + 1
</code></pre>
<p>This can be remedied by placing a left arrow before <code>ih</code> in the call to <code>rewrite</code>, which instructs it to replace the right-hand side of the equality with the left-hand side:</p>
<pre><code class="language-lean">theorem plusR_zero_left (k : Nat) : k = Nat.plusR 0 k := by
  induction k with
  | zero =&gt; rfl
  | succ n ih =&gt;
    unfold Nat.plusR
    rw [←ih]
</code></pre>
<p>This rewrite makes both sides of the equation identical, and Lean takes care of the <code>rfl</code> on its own.
The proof is complete.</p>
<h2 id="tactic-golf"><a class="header" href="#tactic-golf">Tactic Golf</a></h2>
<p>So far, the tactic language has not shown its true value.
The above proof is no shorter than the recursive function; it's merely written in a domain-specific language instead of the full Lean language.
But proofs with tactics can be shorter, easier, and more maintainable.
Just as a lower score is better in the game of golf, a shorter proof is better in the game of tactic golf.</p>
<p>The induction step of <code>plusR_zero_left</code> can be proved using the simplification tactic <code>simp</code>.
Using <code>simp</code> on its own does not help, and the goal is left unmodified:</p>
<pre><code class="language-lean">theorem plusR_zero_left (k : Nat) : k = Nat.plusR 0 k := by
  induction k with
  | zero =&gt; rfl
  | succ n ih =&gt;
    simp
</code></pre>
<pre><code class="language-output error">unsolved goals
case succ
n : Nat
ih : n = Nat.plusR 0 n
⊢ Nat.succ n = Nat.plusR 0 (Nat.succ n)
</code></pre>
<p>However, <code>simp</code> can be configured to make use of a set of definitions.
Just like <code>rw</code>, these arguments are provided in a list.
Asking <code>simp</code> to take the definition of <code>Nat.plusR</code> into account leads to a simpler goal:</p>
<pre><code class="language-lean">theorem plusR_zero_left (k : Nat) : k = Nat.plusR 0 k := by
  induction k with
  | zero =&gt; rfl
  | succ n ih =&gt;
    simp [Nat.plusR]
</code></pre>
<pre><code class="language-output info">unsolved goals
case succ
n : Nat
ih : n = Nat.plusR 0 n
⊢ n = Nat.plusR 0 n
</code></pre>
<p>In particular, the goal is now identical to the induction hypothesis.
In addition to automatically proving simple equality statements, the simplifier automatically replaces goals like <code>Nat.succ A = Nat.succ B</code> with <code>A = B</code>.
Because the induction hypothesis <code>ih</code> has exactly the right type, the <code>exact</code> tactic can indicate that it should be used:</p>
<pre><code class="language-lean">theorem plusR_zero_left (k : Nat) : k = Nat.plusR 0 k := by
  induction k with
  | zero =&gt; rfl
  | succ n ih =&gt;
    simp [Nat.plusR]
    exact ih
</code></pre>
<p>However, the use of <code>exact</code> is somewhat fragile.
Renaming the induction hypothesis, which may happen while &quot;golfing&quot; the proof, would cause this proof to stop working.
The <code>assumption</code> tactic solves the current goal if <em>any</em> of the assumptions match it:</p>
<pre><code class="language-lean">theorem plusR_zero_left (k : Nat) : k = Nat.plusR 0 k := by
  induction k with
  | zero =&gt; rfl
  | succ n ih =&gt;
    simp [Nat.plusR]
    assumption
</code></pre>
<p>This proof is no shorter than the prior proof that used unfolding and explicit rewriting.
However, a series of transformations can make it much shorter, taking advantage of the fact that <code>simp</code> can solve many kinds of goals.
The first step is to drop the <code>with</code> at the end of <code>induction</code>.
For structured, readable proofs, the <code>with</code> syntax is convenient.
It complains if any cases are missing, and it shows the structure of the induction clearly.
But shortening proofs can often require a more liberal approach.</p>
<p>Using <code>induction</code> without <code>with</code> simply results in a proof state with two goals.
The <code>case</code> tactic can be used to select one of them, just in the branches of the <code>induction ... with</code> tactic.
In other words, the following proof is equivalent to the prior proof:</p>
<pre><code class="language-lean">theorem plusR_zero_left (k : Nat) : k = Nat.plusR 0 k := by
  induction k
  case zero =&gt; rfl
  case succ n ih =&gt;
    simp [Nat.plusR]
    assumption
</code></pre>
<p>In a context with a single goal (namely, <code>k = Nat.plusR 0 k</code>), the <code>induction k</code> tactic yields two goals.
In general, a tactic will either fail with an error or take a goal and transform it in to zero or more new goals.
Each new goal represents what remains to be proved.
If the result is zero goals, then the tactic was a success, and that part of the proof is done.</p>
<p>The <code>&lt;;&gt;</code> operator takes two tactics as arguments, resulting in a new tactic.
<code>T1 &lt;;&gt; T2</code> applies <code>T1</code> to the current goal, and then applies <code>T2</code> in <em>all</em> goals created by <code>T1</code>.
In other words, <code>&lt;;&gt;</code> enables a general tactic that can solve many kinds of goals to be used on multiple new goals all at once.
One such general tactic is <code>simp</code>.</p>
<p>Because <code>simp</code> can both complete the proof of the base case and make progress on the proof of the induction step, using with <code>induction</code> and <code>&lt;;&gt;</code> shortens the proof:</p>
<pre><code class="language-lean">theorem plusR_zero_left (k : Nat) : k = Nat.plusR 0 k := by
  induction k &lt;;&gt; simp [Nat.plusR]
</code></pre>
<p>This results in only a single goal, the transformed induction step:</p>
<pre><code class="language-output error">unsolved goals
case succ
n✝ : Nat
n_ih✝ : n✝ = Nat.plusR 0 n✝
⊢ n✝ = Nat.plusR 0 n✝
</code></pre>
<p>Running <code>assumption</code> in this goal completes the proof:</p>
<pre><code class="language-lean">theorem plusR_zero_left (k : Nat) : k = Nat.plusR 0 k := by
  induction k &lt;;&gt; simp [Nat.plusR] &lt;;&gt; assumption
</code></pre>
<p>Here, <code>exact</code> would not have been possible, because <code>ih</code> was never explicitly named.</p>
<p>For beginners, this proof is not easier to read.
However, a common pattern for expert users is to take care of a number of simple cases with powerful tactics like <code>simp</code>, allowing them to focus the text of the proof on the interesting cases.
Additionally, these proofs tend to be more robust in the face of small changes to the functions and datatypes involved in the proof.
The game of tactic golf is a useful part of developing good taste and style when writing proofs.</p>
<h2 id="induction-on-other-datatypes"><a class="header" href="#induction-on-other-datatypes">Induction on Other Datatypes</a></h2>
<p>Mathematical induction proves a statement for natural numbers by providing a base case for <code>Nat.zero</code> and an induction step for <code>Nat.succ</code>.
The principle of induction is also valid for other datatypes.
Constructors without recursive arguments form the base cases, while constructors with recursive arguments form the induction steps.
The ability to carry out proofs by induction is the very reason why they are called <em>inductive</em> datatypes.</p>
<p>One example of this is induction on binary trees.
Induction on binary trees is a proof technique where a statement is proven for <em>all</em> binary trees in two steps:</p>
<ol>
<li>The statement is shown to hold for <code>BinTree.leaf</code>. This is called the base case.</li>
<li>Under the assumption that the statement holds for some arbitrarily chosen trees <code>l</code> and <code>r</code>, it is shown to hold for <code>BinTree.branch l x r</code>, where <code>x</code> is an arbitrarily-chosen new data point. This is called the <em>induction step</em>. The assumptions that the statement holds for <code>l</code> and <code>r</code> are called the <em>induction hypotheses</em>.</li>
</ol>
<p><code>BinTree.count</code> counts the number of branches in a tree:</p>
<pre><code class="language-lean">def BinTree.count : BinTree α → Nat
  | .leaf =&gt; 0
  | .branch l _ r =&gt;
    1 + l.count + r.count
</code></pre>
<p><a href="monads/conveniences.html#leading-dot-notation">Mirroring a tree</a> does not change the number of branches in it.
This can be proven using induction on trees.
The first step is to state the theorem and invoke <code>induction</code>:</p>
<pre><code class="language-lean">theorem BinTree.mirror_count (t : BinTree α) : t.mirror.count = t.count := by
  induction t with
  | leaf =&gt; skip
  | branch l x r ihl ihr =&gt; skip
</code></pre>
<p>The base case states that counting the mirror of a leaf is the same as counting the leaf:</p>
<pre><code class="language-output error">unsolved goals
case leaf
α : Type
⊢ count (mirror leaf) = count leaf
</code></pre>
<p>The induction step allows the assumption that mirroring the left and right subtrees won't affect their branch counts, and requests a proof that mirroring a branch with these subtrees also preserves the overall branch count:</p>
<pre><code class="language-output error">unsolved goals
case branch
α : Type
l : BinTree α
x : α
r : BinTree α
ihl : count (mirror l) = count l
ihr : count (mirror r) = count r
⊢ count (mirror (branch l x r)) = count (branch l x r)
</code></pre>
<p>The base case is true because mirroring <code>leaf</code> results in <code>leaf</code>, so the left and right sides are definitionally equal.
This can be expressed by using <code>simp</code> with instructions to unfold <code>BinTree.mirror</code>:</p>
<pre><code class="language-lean">theorem BinTree.mirror_count (t : BinTree α) : t.mirror.count = t.count := by
  induction t with
  | leaf =&gt; simp [BinTree.mirror]
  | branch l x r ihl ihr =&gt; skip
</code></pre>
<p>In the induction step, nothing in the goal immediately matches the induction hypotheses.
Simplifying using the definitions of <code>BinTree.count</code> and <code>BinTree.mirror</code> reveals the relationship:</p>
<pre><code class="language-lean">theorem BinTree.mirror_count (t : BinTree α) : t.mirror.count = t.count := by
  induction t with
  | leaf =&gt; simp [BinTree.mirror]
  | branch l x r ihl ihr =&gt;
    simp [BinTree.mirror, BinTree.count]
</code></pre>
<pre><code class="language-output error">unsolved goals
case branch
α : Type
l : BinTree α
x : α
r : BinTree α
ihl : count (mirror l) = count l
ihr : count (mirror r) = count r
⊢ 1 + count (mirror r) + count (mirror l) = 1 + count l + count r
</code></pre>
<p>Both induction hypotheses can be used to rewrite the left-hand side of the goal into something almost like the right-hand side:</p>
<pre><code class="language-lean">theorem BinTree.mirror_count (t : BinTree α) : t.mirror.count = t.count := by
  induction t with
  | leaf =&gt; simp [BinTree.mirror]
  | branch l x r ihl ihr =&gt;
    simp [BinTree.mirror, BinTree.count]
    rw [ihl, ihr]
</code></pre>
<pre><code class="language-output info">unsolved goals
case branch
α : Type
l : BinTree α
x : α
r : BinTree α
ihl : count (mirror l) = count l
ihr : count (mirror r) = count r
⊢ 1 + count r + count l = 1 + count l + count r
</code></pre>
<p>The <code>simp_arith</code> tactic, a version of <code>simp</code> that can use additional arithmetic identities, is enough to prove this goal, yielding:</p>
<pre><code class="language-lean">theorem BinTree.mirror_count (t : BinTree α) : t.mirror.count = t.count := by
  induction t with
  | leaf =&gt; simp [BinTree.mirror]
  | branch l x r ihl ihr =&gt;
    simp [BinTree.mirror, BinTree.count]
    rw [ihl, ihr]
    simp_arith
</code></pre>
<p>In addition to definitions to be unfolded, the simplifier can also be passed names of equality proofs to use as rewrites while it simplifies proof goals.
<code>BinTree.mirror_count</code> can also be written:</p>
<pre><code class="language-lean">theorem BinTree.mirror_count (t : BinTree α) : t.mirror.count = t.count := by
  induction t with
  | leaf =&gt; simp [BinTree.mirror]
  | branch l x r ihl ihr =&gt;
    simp_arith [BinTree.mirror, BinTree.count, ihl, ihr]
</code></pre>
<p>As proofs grow more complicated, listing assumptions by hand can become tedious.
Furthermore, manually writing assumption names can make it more difficult to re-use proof steps for multiple subgoals.
The argument <code>*</code> to <code>simp</code> or <code>simp_arith</code> instructs them to use <em>all</em> assumptions while simplifying or solving the goal.
In other words, the proof could also be written:</p>
<pre><code class="language-lean">theorem BinTree.mirror_count (t : BinTree α) : t.mirror.count = t.count := by
  induction t with
  | leaf =&gt; simp [BinTree.mirror]
  | branch l x r ihl ihr =&gt;
    simp_arith [BinTree.mirror, BinTree.count, *]
</code></pre>
<p>Because both branches are using the simplifier, the proof can be reduced to:</p>
<pre><code class="language-lean">theorem BinTree.mirror_count (t : BinTree α) : t.mirror.count = t.count := by
  induction t &lt;;&gt; simp_arith [BinTree.mirror, BinTree.count, *]
</code></pre>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<ul>
<li>Prove <code>plusR_succ_left</code> using the <code>induction ... with</code> tactic.</li>
<li>Rewrite the proof of <code>plus_succ_left</code> to use <code>&lt;;&gt;</code> in a single line.</li>
<li>Prove that appending lists is associative using induction on lists: <code>theorem List.append_assoc (xs ys zs : List α) : xs ++ (ys ++ zs) = (xs ++ ys) ++ zs</code></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="dependent-types/summary.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="programs-proofs.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="dependent-types/summary.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="programs-proofs.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
